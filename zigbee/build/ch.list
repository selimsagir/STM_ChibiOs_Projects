
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4821      	ldr	r0, [pc, #132]	; (8000248 <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f005 fb6d 	bl	80058b0 <__early_init>
 80001d6:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 80001da:	491c      	ldr	r1, [pc, #112]	; (800024c <endfiniloop+0xa>)
 80001dc:	4a1c      	ldr	r2, [pc, #112]	; (8000250 <endfiniloop+0xe>)

080001de <msloop>:
 80001de:	4291      	cmp	r1, r2
 80001e0:	bf3c      	itt	cc
 80001e2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e6:	e7fa      	bcc.n	80001de <msloop>
 80001e8:	491a      	ldr	r1, [pc, #104]	; (8000254 <endfiniloop+0x12>)
 80001ea:	4a17      	ldr	r2, [pc, #92]	; (8000248 <endfiniloop+0x6>)

080001ec <psloop>:
 80001ec:	4291      	cmp	r1, r2
 80001ee:	bf3c      	itt	cc
 80001f0:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f4:	e7fa      	bcc.n	80001ec <psloop>
 80001f6:	4918      	ldr	r1, [pc, #96]	; (8000258 <endfiniloop+0x16>)
 80001f8:	4a18      	ldr	r2, [pc, #96]	; (800025c <endfiniloop+0x1a>)
 80001fa:	4b19      	ldr	r3, [pc, #100]	; (8000260 <endfiniloop+0x1e>)

080001fc <dloop>:
 80001fc:	429a      	cmp	r2, r3
 80001fe:	bf3e      	ittt	cc
 8000200:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000204:	f842 0b04 	strcc.w	r0, [r2], #4
 8000208:	e7f8      	bcc.n	80001fc <dloop>
 800020a:	2000      	movs	r0, #0
 800020c:	4915      	ldr	r1, [pc, #84]	; (8000264 <endfiniloop+0x22>)
 800020e:	4a16      	ldr	r2, [pc, #88]	; (8000268 <endfiniloop+0x26>)

08000210 <bloop>:
 8000210:	4291      	cmp	r1, r2
 8000212:	bf3c      	itt	cc
 8000214:	f841 0b04 	strcc.w	r0, [r1], #4
 8000218:	e7fa      	bcc.n	8000210 <bloop>
 800021a:	f000 ff91 	bl	8001140 <__late_init>
 800021e:	4c13      	ldr	r4, [pc, #76]	; (800026c <endfiniloop+0x2a>)
 8000220:	4d13      	ldr	r5, [pc, #76]	; (8000270 <endfiniloop+0x2e>)

08000222 <initloop>:
 8000222:	42ac      	cmp	r4, r5
 8000224:	da03      	bge.n	800022e <endinitloop>
 8000226:	f854 1b04 	ldr.w	r1, [r4], #4
 800022a:	4788      	blx	r1
 800022c:	e7f9      	b.n	8000222 <initloop>

0800022e <endinitloop>:
 800022e:	f009 ff67 	bl	800a100 <main>
 8000232:	4c10      	ldr	r4, [pc, #64]	; (8000274 <endfiniloop+0x32>)
 8000234:	4d10      	ldr	r5, [pc, #64]	; (8000278 <endfiniloop+0x36>)

08000236 <finiloop>:
 8000236:	42ac      	cmp	r4, r5
 8000238:	da03      	bge.n	8000242 <endfiniloop>
 800023a:	f854 1b04 	ldr.w	r1, [r4], #4
 800023e:	4788      	blx	r1
 8000240:	e7f9      	b.n	8000236 <finiloop>

08000242 <endfiniloop>:
 8000242:	f000 bf85 	b.w	8001150 <__default_exit>
 8000246:	0000      	.short	0x0000
 8000248:	20000800 	.word	0x20000800
 800024c:	20000000 	.word	0x20000000
 8000250:	20000400 	.word	0x20000400
 8000254:	20000400 	.word	0x20000400
 8000258:	0800bab8 	.word	0x0800bab8
 800025c:	20000800 	.word	0x20000800
 8000260:	20000e74 	.word	0x20000e74
 8000264:	20000e78 	.word	0x20000e78
 8000268:	200020ac 	.word	0x200020ac
 800026c:	080001c0 	.word	0x080001c0
 8000270:	080001c0 	.word	0x080001c0
 8000274:	080001c0 	.word	0x080001c0
 8000278:	080001c0 	.word	0x080001c0
 800027c:	00000000 	.word	0x00000000

08000280 <_port_switch>:
 8000280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000284:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800028c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000290 <_port_thread_start>:
 8000290:	2300      	movs	r3, #0
 8000292:	f383 8811 	msr	BASEPRI, r3
 8000296:	4628      	mov	r0, r5
 8000298:	47a0      	blx	r4
 800029a:	2000      	movs	r0, #0
 800029c:	f001 fb78 	bl	8001990 <chThdExit>

080002a0 <_port_switch_from_isr>:
 80002a0:	f001 fa56 	bl	8001750 <chSchDoReschedule>

080002a4 <_port_exit_from_isr>:
 80002a4:	df00      	svc	0
 80002a6:	e7fe      	b.n	80002a6 <_port_exit_from_isr+0x2>
	...

080002b0 <__aeabi_drsub>:
 80002b0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002b4:	e002      	b.n	80002bc <__adddf3>
 80002b6:	bf00      	nop

080002b8 <__aeabi_dsub>:
 80002b8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002bc <__adddf3>:
 80002bc:	b530      	push	{r4, r5, lr}
 80002be:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002c2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002c6:	ea94 0f05 	teq	r4, r5
 80002ca:	bf08      	it	eq
 80002cc:	ea90 0f02 	teqeq	r0, r2
 80002d0:	bf1f      	itttt	ne
 80002d2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002d6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002da:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002de:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002e2:	f000 80e2 	beq.w	80004aa <__adddf3+0x1ee>
 80002e6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ea:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ee:	bfb8      	it	lt
 80002f0:	426d      	neglt	r5, r5
 80002f2:	dd0c      	ble.n	800030e <__adddf3+0x52>
 80002f4:	442c      	add	r4, r5
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	ea82 0000 	eor.w	r0, r2, r0
 8000302:	ea83 0101 	eor.w	r1, r3, r1
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	2d36      	cmp	r5, #54	; 0x36
 8000310:	bf88      	it	hi
 8000312:	bd30      	pophi	{r4, r5, pc}
 8000314:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000318:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800031c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000320:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x70>
 8000326:	4240      	negs	r0, r0
 8000328:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800032c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000330:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000334:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000338:	d002      	beq.n	8000340 <__adddf3+0x84>
 800033a:	4252      	negs	r2, r2
 800033c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000340:	ea94 0f05 	teq	r4, r5
 8000344:	f000 80a7 	beq.w	8000496 <__adddf3+0x1da>
 8000348:	f1a4 0401 	sub.w	r4, r4, #1
 800034c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000350:	db0d      	blt.n	800036e <__adddf3+0xb2>
 8000352:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000356:	fa22 f205 	lsr.w	r2, r2, r5
 800035a:	1880      	adds	r0, r0, r2
 800035c:	f141 0100 	adc.w	r1, r1, #0
 8000360:	fa03 f20e 	lsl.w	r2, r3, lr
 8000364:	1880      	adds	r0, r0, r2
 8000366:	fa43 f305 	asr.w	r3, r3, r5
 800036a:	4159      	adcs	r1, r3
 800036c:	e00e      	b.n	800038c <__adddf3+0xd0>
 800036e:	f1a5 0520 	sub.w	r5, r5, #32
 8000372:	f10e 0e20 	add.w	lr, lr, #32
 8000376:	2a01      	cmp	r2, #1
 8000378:	fa03 fc0e 	lsl.w	ip, r3, lr
 800037c:	bf28      	it	cs
 800037e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000382:	fa43 f305 	asr.w	r3, r3, r5
 8000386:	18c0      	adds	r0, r0, r3
 8000388:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800038c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000390:	d507      	bpl.n	80003a2 <__adddf3+0xe6>
 8000392:	f04f 0e00 	mov.w	lr, #0
 8000396:	f1dc 0c00 	rsbs	ip, ip, #0
 800039a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800039e:	eb6e 0101 	sbc.w	r1, lr, r1
 80003a2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003a6:	d31b      	bcc.n	80003e0 <__adddf3+0x124>
 80003a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003ac:	d30c      	bcc.n	80003c8 <__adddf3+0x10c>
 80003ae:	0849      	lsrs	r1, r1, #1
 80003b0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003b4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003b8:	f104 0401 	add.w	r4, r4, #1
 80003bc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003c0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003c4:	f080 809a 	bcs.w	80004fc <__adddf3+0x240>
 80003c8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003cc:	bf08      	it	eq
 80003ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003d2:	f150 0000 	adcs.w	r0, r0, #0
 80003d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003da:	ea41 0105 	orr.w	r1, r1, r5
 80003de:	bd30      	pop	{r4, r5, pc}
 80003e0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003e4:	4140      	adcs	r0, r0
 80003e6:	eb41 0101 	adc.w	r1, r1, r1
 80003ea:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003ee:	f1a4 0401 	sub.w	r4, r4, #1
 80003f2:	d1e9      	bne.n	80003c8 <__adddf3+0x10c>
 80003f4:	f091 0f00 	teq	r1, #0
 80003f8:	bf04      	itt	eq
 80003fa:	4601      	moveq	r1, r0
 80003fc:	2000      	moveq	r0, #0
 80003fe:	fab1 f381 	clz	r3, r1
 8000402:	bf08      	it	eq
 8000404:	3320      	addeq	r3, #32
 8000406:	f1a3 030b 	sub.w	r3, r3, #11
 800040a:	f1b3 0220 	subs.w	r2, r3, #32
 800040e:	da0c      	bge.n	800042a <__adddf3+0x16e>
 8000410:	320c      	adds	r2, #12
 8000412:	dd08      	ble.n	8000426 <__adddf3+0x16a>
 8000414:	f102 0c14 	add.w	ip, r2, #20
 8000418:	f1c2 020c 	rsb	r2, r2, #12
 800041c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000420:	fa21 f102 	lsr.w	r1, r1, r2
 8000424:	e00c      	b.n	8000440 <__adddf3+0x184>
 8000426:	f102 0214 	add.w	r2, r2, #20
 800042a:	bfd8      	it	le
 800042c:	f1c2 0c20 	rsble	ip, r2, #32
 8000430:	fa01 f102 	lsl.w	r1, r1, r2
 8000434:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000438:	bfdc      	itt	le
 800043a:	ea41 010c 	orrle.w	r1, r1, ip
 800043e:	4090      	lslle	r0, r2
 8000440:	1ae4      	subs	r4, r4, r3
 8000442:	bfa2      	ittt	ge
 8000444:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000448:	4329      	orrge	r1, r5
 800044a:	bd30      	popge	{r4, r5, pc}
 800044c:	ea6f 0404 	mvn.w	r4, r4
 8000450:	3c1f      	subs	r4, #31
 8000452:	da1c      	bge.n	800048e <__adddf3+0x1d2>
 8000454:	340c      	adds	r4, #12
 8000456:	dc0e      	bgt.n	8000476 <__adddf3+0x1ba>
 8000458:	f104 0414 	add.w	r4, r4, #20
 800045c:	f1c4 0220 	rsb	r2, r4, #32
 8000460:	fa20 f004 	lsr.w	r0, r0, r4
 8000464:	fa01 f302 	lsl.w	r3, r1, r2
 8000468:	ea40 0003 	orr.w	r0, r0, r3
 800046c:	fa21 f304 	lsr.w	r3, r1, r4
 8000470:	ea45 0103 	orr.w	r1, r5, r3
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f1c4 040c 	rsb	r4, r4, #12
 800047a:	f1c4 0220 	rsb	r2, r4, #32
 800047e:	fa20 f002 	lsr.w	r0, r0, r2
 8000482:	fa01 f304 	lsl.w	r3, r1, r4
 8000486:	ea40 0003 	orr.w	r0, r0, r3
 800048a:	4629      	mov	r1, r5
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	fa21 f004 	lsr.w	r0, r1, r4
 8000492:	4629      	mov	r1, r5
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f094 0f00 	teq	r4, #0
 800049a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800049e:	bf06      	itte	eq
 80004a0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004a4:	3401      	addeq	r4, #1
 80004a6:	3d01      	subne	r5, #1
 80004a8:	e74e      	b.n	8000348 <__adddf3+0x8c>
 80004aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ae:	bf18      	it	ne
 80004b0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004b4:	d029      	beq.n	800050a <__adddf3+0x24e>
 80004b6:	ea94 0f05 	teq	r4, r5
 80004ba:	bf08      	it	eq
 80004bc:	ea90 0f02 	teqeq	r0, r2
 80004c0:	d005      	beq.n	80004ce <__adddf3+0x212>
 80004c2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004c6:	bf04      	itt	eq
 80004c8:	4619      	moveq	r1, r3
 80004ca:	4610      	moveq	r0, r2
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	ea91 0f03 	teq	r1, r3
 80004d2:	bf1e      	ittt	ne
 80004d4:	2100      	movne	r1, #0
 80004d6:	2000      	movne	r0, #0
 80004d8:	bd30      	popne	{r4, r5, pc}
 80004da:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004de:	d105      	bne.n	80004ec <__adddf3+0x230>
 80004e0:	0040      	lsls	r0, r0, #1
 80004e2:	4149      	adcs	r1, r1
 80004e4:	bf28      	it	cs
 80004e6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ea:	bd30      	pop	{r4, r5, pc}
 80004ec:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004f0:	bf3c      	itt	cc
 80004f2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004f6:	bd30      	popcc	{r4, r5, pc}
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000500:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000504:	f04f 0000 	mov.w	r0, #0
 8000508:	bd30      	pop	{r4, r5, pc}
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf1a      	itte	ne
 8000510:	4619      	movne	r1, r3
 8000512:	4610      	movne	r0, r2
 8000514:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000518:	bf1c      	itt	ne
 800051a:	460b      	movne	r3, r1
 800051c:	4602      	movne	r2, r0
 800051e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000522:	bf06      	itte	eq
 8000524:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000528:	ea91 0f03 	teqeq	r1, r3
 800052c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	bf00      	nop

08000534 <__aeabi_ui2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f04f 0500 	mov.w	r5, #0
 800054c:	f04f 0100 	mov.w	r1, #0
 8000550:	e750      	b.n	80003f4 <__adddf3+0x138>
 8000552:	bf00      	nop

08000554 <__aeabi_i2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800056c:	bf48      	it	mi
 800056e:	4240      	negmi	r0, r0
 8000570:	f04f 0100 	mov.w	r1, #0
 8000574:	e73e      	b.n	80003f4 <__adddf3+0x138>
 8000576:	bf00      	nop

08000578 <__aeabi_f2d>:
 8000578:	0042      	lsls	r2, r0, #1
 800057a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800057e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000582:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000586:	bf1f      	itttt	ne
 8000588:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000594:	4770      	bxne	lr
 8000596:	f092 0f00 	teq	r2, #0
 800059a:	bf14      	ite	ne
 800059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a0:	4770      	bxeq	lr
 80005a2:	b530      	push	{r4, r5, lr}
 80005a4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005b0:	e720      	b.n	80003f4 <__adddf3+0x138>
 80005b2:	bf00      	nop

080005b4 <__aeabi_ul2d>:
 80005b4:	ea50 0201 	orrs.w	r2, r0, r1
 80005b8:	bf08      	it	eq
 80005ba:	4770      	bxeq	lr
 80005bc:	b530      	push	{r4, r5, lr}
 80005be:	f04f 0500 	mov.w	r5, #0
 80005c2:	e00a      	b.n	80005da <__aeabi_l2d+0x16>

080005c4 <__aeabi_l2d>:
 80005c4:	ea50 0201 	orrs.w	r2, r0, r1
 80005c8:	bf08      	it	eq
 80005ca:	4770      	bxeq	lr
 80005cc:	b530      	push	{r4, r5, lr}
 80005ce:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005d2:	d502      	bpl.n	80005da <__aeabi_l2d+0x16>
 80005d4:	4240      	negs	r0, r0
 80005d6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005da:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005de:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005e2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005e6:	f43f aedc 	beq.w	80003a2 <__adddf3+0xe6>
 80005ea:	f04f 0203 	mov.w	r2, #3
 80005ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005f2:	bf18      	it	ne
 80005f4:	3203      	addne	r2, #3
 80005f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005fa:	bf18      	it	ne
 80005fc:	3203      	addne	r2, #3
 80005fe:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000602:	f1c2 0320 	rsb	r3, r2, #32
 8000606:	fa00 fc03 	lsl.w	ip, r0, r3
 800060a:	fa20 f002 	lsr.w	r0, r0, r2
 800060e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000612:	ea40 000e 	orr.w	r0, r0, lr
 8000616:	fa21 f102 	lsr.w	r1, r1, r2
 800061a:	4414      	add	r4, r2
 800061c:	e6c1      	b.n	80003a2 <__adddf3+0xe6>
 800061e:	bf00      	nop

08000620 <__aeabi_dmul>:
 8000620:	b570      	push	{r4, r5, r6, lr}
 8000622:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000626:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800062a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800062e:	bf1d      	ittte	ne
 8000630:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000634:	ea94 0f0c 	teqne	r4, ip
 8000638:	ea95 0f0c 	teqne	r5, ip
 800063c:	f000 f8de 	bleq	80007fc <__aeabi_dmul+0x1dc>
 8000640:	442c      	add	r4, r5
 8000642:	ea81 0603 	eor.w	r6, r1, r3
 8000646:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800064a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800064e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000652:	bf18      	it	ne
 8000654:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000658:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800065c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000660:	d038      	beq.n	80006d4 <__aeabi_dmul+0xb4>
 8000662:	fba0 ce02 	umull	ip, lr, r0, r2
 8000666:	f04f 0500 	mov.w	r5, #0
 800066a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800066e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000672:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000676:	f04f 0600 	mov.w	r6, #0
 800067a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800067e:	f09c 0f00 	teq	ip, #0
 8000682:	bf18      	it	ne
 8000684:	f04e 0e01 	orrne.w	lr, lr, #1
 8000688:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800068c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000690:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000694:	d204      	bcs.n	80006a0 <__aeabi_dmul+0x80>
 8000696:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800069a:	416d      	adcs	r5, r5
 800069c:	eb46 0606 	adc.w	r6, r6, r6
 80006a0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006a4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006a8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006ac:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006b0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006b4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006b8:	bf88      	it	hi
 80006ba:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006be:	d81e      	bhi.n	80006fe <__aeabi_dmul+0xde>
 80006c0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006c4:	bf08      	it	eq
 80006c6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006ca:	f150 0000 	adcs.w	r0, r0, #0
 80006ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006d2:	bd70      	pop	{r4, r5, r6, pc}
 80006d4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006d8:	ea46 0101 	orr.w	r1, r6, r1
 80006dc:	ea40 0002 	orr.w	r0, r0, r2
 80006e0:	ea81 0103 	eor.w	r1, r1, r3
 80006e4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006e8:	bfc2      	ittt	gt
 80006ea:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006ee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006f2:	bd70      	popgt	{r4, r5, r6, pc}
 80006f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006f8:	f04f 0e00 	mov.w	lr, #0
 80006fc:	3c01      	subs	r4, #1
 80006fe:	f300 80ab 	bgt.w	8000858 <__aeabi_dmul+0x238>
 8000702:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000706:	bfde      	ittt	le
 8000708:	2000      	movle	r0, #0
 800070a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800070e:	bd70      	pople	{r4, r5, r6, pc}
 8000710:	f1c4 0400 	rsb	r4, r4, #0
 8000714:	3c20      	subs	r4, #32
 8000716:	da35      	bge.n	8000784 <__aeabi_dmul+0x164>
 8000718:	340c      	adds	r4, #12
 800071a:	dc1b      	bgt.n	8000754 <__aeabi_dmul+0x134>
 800071c:	f104 0414 	add.w	r4, r4, #20
 8000720:	f1c4 0520 	rsb	r5, r4, #32
 8000724:	fa00 f305 	lsl.w	r3, r0, r5
 8000728:	fa20 f004 	lsr.w	r0, r0, r4
 800072c:	fa01 f205 	lsl.w	r2, r1, r5
 8000730:	ea40 0002 	orr.w	r0, r0, r2
 8000734:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000738:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800073c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000740:	fa21 f604 	lsr.w	r6, r1, r4
 8000744:	eb42 0106 	adc.w	r1, r2, r6
 8000748:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800074c:	bf08      	it	eq
 800074e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000752:	bd70      	pop	{r4, r5, r6, pc}
 8000754:	f1c4 040c 	rsb	r4, r4, #12
 8000758:	f1c4 0520 	rsb	r5, r4, #32
 800075c:	fa00 f304 	lsl.w	r3, r0, r4
 8000760:	fa20 f005 	lsr.w	r0, r0, r5
 8000764:	fa01 f204 	lsl.w	r2, r1, r4
 8000768:	ea40 0002 	orr.w	r0, r0, r2
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000774:	f141 0100 	adc.w	r1, r1, #0
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f1c4 0520 	rsb	r5, r4, #32
 8000788:	fa00 f205 	lsl.w	r2, r0, r5
 800078c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000790:	fa20 f304 	lsr.w	r3, r0, r4
 8000794:	fa01 f205 	lsl.w	r2, r1, r5
 8000798:	ea43 0302 	orr.w	r3, r3, r2
 800079c:	fa21 f004 	lsr.w	r0, r1, r4
 80007a0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a4:	fa21 f204 	lsr.w	r2, r1, r4
 80007a8:	ea20 0002 	bic.w	r0, r0, r2
 80007ac:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007b4:	bf08      	it	eq
 80007b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ba:	bd70      	pop	{r4, r5, r6, pc}
 80007bc:	f094 0f00 	teq	r4, #0
 80007c0:	d10f      	bne.n	80007e2 <__aeabi_dmul+0x1c2>
 80007c2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007c6:	0040      	lsls	r0, r0, #1
 80007c8:	eb41 0101 	adc.w	r1, r1, r1
 80007cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007d0:	bf08      	it	eq
 80007d2:	3c01      	subeq	r4, #1
 80007d4:	d0f7      	beq.n	80007c6 <__aeabi_dmul+0x1a6>
 80007d6:	ea41 0106 	orr.w	r1, r1, r6
 80007da:	f095 0f00 	teq	r5, #0
 80007de:	bf18      	it	ne
 80007e0:	4770      	bxne	lr
 80007e2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007e6:	0052      	lsls	r2, r2, #1
 80007e8:	eb43 0303 	adc.w	r3, r3, r3
 80007ec:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007f0:	bf08      	it	eq
 80007f2:	3d01      	subeq	r5, #1
 80007f4:	d0f7      	beq.n	80007e6 <__aeabi_dmul+0x1c6>
 80007f6:	ea43 0306 	orr.w	r3, r3, r6
 80007fa:	4770      	bx	lr
 80007fc:	ea94 0f0c 	teq	r4, ip
 8000800:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000804:	bf18      	it	ne
 8000806:	ea95 0f0c 	teqne	r5, ip
 800080a:	d00c      	beq.n	8000826 <__aeabi_dmul+0x206>
 800080c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000810:	bf18      	it	ne
 8000812:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000816:	d1d1      	bne.n	80007bc <__aeabi_dmul+0x19c>
 8000818:	ea81 0103 	eor.w	r1, r1, r3
 800081c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000820:	f04f 0000 	mov.w	r0, #0
 8000824:	bd70      	pop	{r4, r5, r6, pc}
 8000826:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800082a:	bf06      	itte	eq
 800082c:	4610      	moveq	r0, r2
 800082e:	4619      	moveq	r1, r3
 8000830:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000834:	d019      	beq.n	800086a <__aeabi_dmul+0x24a>
 8000836:	ea94 0f0c 	teq	r4, ip
 800083a:	d102      	bne.n	8000842 <__aeabi_dmul+0x222>
 800083c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000840:	d113      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000842:	ea95 0f0c 	teq	r5, ip
 8000846:	d105      	bne.n	8000854 <__aeabi_dmul+0x234>
 8000848:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800084c:	bf1c      	itt	ne
 800084e:	4610      	movne	r0, r2
 8000850:	4619      	movne	r1, r3
 8000852:	d10a      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000854:	ea81 0103 	eor.w	r1, r1, r3
 8000858:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800085c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000860:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000864:	f04f 0000 	mov.w	r0, #0
 8000868:	bd70      	pop	{r4, r5, r6, pc}
 800086a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800086e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000872:	bd70      	pop	{r4, r5, r6, pc}

08000874 <__aeabi_ddiv>:
 8000874:	b570      	push	{r4, r5, r6, lr}
 8000876:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800087a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800087e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000882:	bf1d      	ittte	ne
 8000884:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000888:	ea94 0f0c 	teqne	r4, ip
 800088c:	ea95 0f0c 	teqne	r5, ip
 8000890:	f000 f8a7 	bleq	80009e2 <__aeabi_ddiv+0x16e>
 8000894:	eba4 0405 	sub.w	r4, r4, r5
 8000898:	ea81 0e03 	eor.w	lr, r1, r3
 800089c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008a4:	f000 8088 	beq.w	80009b8 <__aeabi_ddiv+0x144>
 80008a8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008ac:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008b0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008b4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008b8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008bc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008c0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008c4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008c8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008cc:	429d      	cmp	r5, r3
 80008ce:	bf08      	it	eq
 80008d0:	4296      	cmpeq	r6, r2
 80008d2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008d6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008da:	d202      	bcs.n	80008e2 <__aeabi_ddiv+0x6e>
 80008dc:	085b      	lsrs	r3, r3, #1
 80008de:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e2:	1ab6      	subs	r6, r6, r2
 80008e4:	eb65 0503 	sbc.w	r5, r5, r3
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008f2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fe:	bf22      	ittt	cs
 8000900:	1ab6      	subcs	r6, r6, r2
 8000902:	4675      	movcs	r5, lr
 8000904:	ea40 000c 	orrcs.w	r0, r0, ip
 8000908:	085b      	lsrs	r3, r3, #1
 800090a:	ea4f 0232 	mov.w	r2, r2, rrx
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000950:	ea55 0e06 	orrs.w	lr, r5, r6
 8000954:	d018      	beq.n	8000988 <__aeabi_ddiv+0x114>
 8000956:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800095a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800095e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000962:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000966:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800096a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800096e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000972:	d1c0      	bne.n	80008f6 <__aeabi_ddiv+0x82>
 8000974:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000978:	d10b      	bne.n	8000992 <__aeabi_ddiv+0x11e>
 800097a:	ea41 0100 	orr.w	r1, r1, r0
 800097e:	f04f 0000 	mov.w	r0, #0
 8000982:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000986:	e7b6      	b.n	80008f6 <__aeabi_ddiv+0x82>
 8000988:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800098c:	bf04      	itt	eq
 800098e:	4301      	orreq	r1, r0
 8000990:	2000      	moveq	r0, #0
 8000992:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000996:	bf88      	it	hi
 8000998:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800099c:	f63f aeaf 	bhi.w	80006fe <__aeabi_dmul+0xde>
 80009a0:	ebb5 0c03 	subs.w	ip, r5, r3
 80009a4:	bf04      	itt	eq
 80009a6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009aa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009ae:	f150 0000 	adcs.w	r0, r0, #0
 80009b2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009b6:	bd70      	pop	{r4, r5, r6, pc}
 80009b8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009bc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009c0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009c4:	bfc2      	ittt	gt
 80009c6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009ca:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	popgt	{r4, r5, r6, pc}
 80009d0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009d4:	f04f 0e00 	mov.w	lr, #0
 80009d8:	3c01      	subs	r4, #1
 80009da:	e690      	b.n	80006fe <__aeabi_dmul+0xde>
 80009dc:	ea45 0e06 	orr.w	lr, r5, r6
 80009e0:	e68d      	b.n	80006fe <__aeabi_dmul+0xde>
 80009e2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009e6:	ea94 0f0c 	teq	r4, ip
 80009ea:	bf08      	it	eq
 80009ec:	ea95 0f0c 	teqeq	r5, ip
 80009f0:	f43f af3b 	beq.w	800086a <__aeabi_dmul+0x24a>
 80009f4:	ea94 0f0c 	teq	r4, ip
 80009f8:	d10a      	bne.n	8000a10 <__aeabi_ddiv+0x19c>
 80009fa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009fe:	f47f af34 	bne.w	800086a <__aeabi_dmul+0x24a>
 8000a02:	ea95 0f0c 	teq	r5, ip
 8000a06:	f47f af25 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a0a:	4610      	mov	r0, r2
 8000a0c:	4619      	mov	r1, r3
 8000a0e:	e72c      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a10:	ea95 0f0c 	teq	r5, ip
 8000a14:	d106      	bne.n	8000a24 <__aeabi_ddiv+0x1b0>
 8000a16:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a1a:	f43f aefd 	beq.w	8000818 <__aeabi_dmul+0x1f8>
 8000a1e:	4610      	mov	r0, r2
 8000a20:	4619      	mov	r1, r3
 8000a22:	e722      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a24:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a28:	bf18      	it	ne
 8000a2a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a2e:	f47f aec5 	bne.w	80007bc <__aeabi_dmul+0x19c>
 8000a32:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a36:	f47f af0d 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a3a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a3e:	f47f aeeb 	bne.w	8000818 <__aeabi_dmul+0x1f8>
 8000a42:	e712      	b.n	800086a <__aeabi_dmul+0x24a>
	...

08000a50 <__aeabi_d2iz>:
 8000a50:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a54:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a58:	d215      	bcs.n	8000a86 <__aeabi_d2iz+0x36>
 8000a5a:	d511      	bpl.n	8000a80 <__aeabi_d2iz+0x30>
 8000a5c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a60:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a64:	d912      	bls.n	8000a8c <__aeabi_d2iz+0x3c>
 8000a66:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a6a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a6e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a72:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000a76:	fa23 f002 	lsr.w	r0, r3, r2
 8000a7a:	bf18      	it	ne
 8000a7c:	4240      	negne	r0, r0
 8000a7e:	4770      	bx	lr
 8000a80:	f04f 0000 	mov.w	r0, #0
 8000a84:	4770      	bx	lr
 8000a86:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a8a:	d105      	bne.n	8000a98 <__aeabi_d2iz+0x48>
 8000a8c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000a90:	bf08      	it	eq
 8000a92:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000a96:	4770      	bx	lr
 8000a98:	f04f 0000 	mov.w	r0, #0
 8000a9c:	4770      	bx	lr
 8000a9e:	bf00      	nop

08000aa0 <__aeabi_d2f>:
 8000aa0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000aa4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000aa8:	bf24      	itt	cs
 8000aaa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000aae:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000ab2:	d90d      	bls.n	8000ad0 <__aeabi_d2f+0x30>
 8000ab4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000ab8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000abc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000ac0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000ac4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000ac8:	bf08      	it	eq
 8000aca:	f020 0001 	biceq.w	r0, r0, #1
 8000ace:	4770      	bx	lr
 8000ad0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000ad4:	d121      	bne.n	8000b1a <__aeabi_d2f+0x7a>
 8000ad6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000ada:	bfbc      	itt	lt
 8000adc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000ae0:	4770      	bxlt	lr
 8000ae2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000ae6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000aea:	f1c2 0218 	rsb	r2, r2, #24
 8000aee:	f1c2 0c20 	rsb	ip, r2, #32
 8000af2:	fa10 f30c 	lsls.w	r3, r0, ip
 8000af6:	fa20 f002 	lsr.w	r0, r0, r2
 8000afa:	bf18      	it	ne
 8000afc:	f040 0001 	orrne.w	r0, r0, #1
 8000b00:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b04:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000b08:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000b0c:	ea40 000c 	orr.w	r0, r0, ip
 8000b10:	fa23 f302 	lsr.w	r3, r3, r2
 8000b14:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000b18:	e7cc      	b.n	8000ab4 <__aeabi_d2f+0x14>
 8000b1a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b1e:	d107      	bne.n	8000b30 <__aeabi_d2f+0x90>
 8000b20:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b24:	bf1e      	ittt	ne
 8000b26:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000b2a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000b2e:	4770      	bxne	lr
 8000b30:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000b34:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000b38:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b3c:	4770      	bx	lr
 8000b3e:	bf00      	nop

08000b40 <__aeabi_frsub>:
 8000b40:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000b44:	e002      	b.n	8000b4c <__addsf3>
 8000b46:	bf00      	nop

08000b48 <__aeabi_fsub>:
 8000b48:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000b4c <__addsf3>:
 8000b4c:	0042      	lsls	r2, r0, #1
 8000b4e:	bf1f      	itttt	ne
 8000b50:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000b54:	ea92 0f03 	teqne	r2, r3
 8000b58:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000b5c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000b60:	d06a      	beq.n	8000c38 <__addsf3+0xec>
 8000b62:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000b66:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000b6a:	bfc1      	itttt	gt
 8000b6c:	18d2      	addgt	r2, r2, r3
 8000b6e:	4041      	eorgt	r1, r0
 8000b70:	4048      	eorgt	r0, r1
 8000b72:	4041      	eorgt	r1, r0
 8000b74:	bfb8      	it	lt
 8000b76:	425b      	neglt	r3, r3
 8000b78:	2b19      	cmp	r3, #25
 8000b7a:	bf88      	it	hi
 8000b7c:	4770      	bxhi	lr
 8000b7e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000b82:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b86:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000b8a:	bf18      	it	ne
 8000b8c:	4240      	negne	r0, r0
 8000b8e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b92:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000b96:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000b9a:	bf18      	it	ne
 8000b9c:	4249      	negne	r1, r1
 8000b9e:	ea92 0f03 	teq	r2, r3
 8000ba2:	d03f      	beq.n	8000c24 <__addsf3+0xd8>
 8000ba4:	f1a2 0201 	sub.w	r2, r2, #1
 8000ba8:	fa41 fc03 	asr.w	ip, r1, r3
 8000bac:	eb10 000c 	adds.w	r0, r0, ip
 8000bb0:	f1c3 0320 	rsb	r3, r3, #32
 8000bb4:	fa01 f103 	lsl.w	r1, r1, r3
 8000bb8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000bbc:	d502      	bpl.n	8000bc4 <__addsf3+0x78>
 8000bbe:	4249      	negs	r1, r1
 8000bc0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000bc4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000bc8:	d313      	bcc.n	8000bf2 <__addsf3+0xa6>
 8000bca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000bce:	d306      	bcc.n	8000bde <__addsf3+0x92>
 8000bd0:	0840      	lsrs	r0, r0, #1
 8000bd2:	ea4f 0131 	mov.w	r1, r1, rrx
 8000bd6:	f102 0201 	add.w	r2, r2, #1
 8000bda:	2afe      	cmp	r2, #254	; 0xfe
 8000bdc:	d251      	bcs.n	8000c82 <__addsf3+0x136>
 8000bde:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000be2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000be6:	bf08      	it	eq
 8000be8:	f020 0001 	biceq.w	r0, r0, #1
 8000bec:	ea40 0003 	orr.w	r0, r0, r3
 8000bf0:	4770      	bx	lr
 8000bf2:	0049      	lsls	r1, r1, #1
 8000bf4:	eb40 0000 	adc.w	r0, r0, r0
 8000bf8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000bfc:	f1a2 0201 	sub.w	r2, r2, #1
 8000c00:	d1ed      	bne.n	8000bde <__addsf3+0x92>
 8000c02:	fab0 fc80 	clz	ip, r0
 8000c06:	f1ac 0c08 	sub.w	ip, ip, #8
 8000c0a:	ebb2 020c 	subs.w	r2, r2, ip
 8000c0e:	fa00 f00c 	lsl.w	r0, r0, ip
 8000c12:	bfaa      	itet	ge
 8000c14:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000c18:	4252      	neglt	r2, r2
 8000c1a:	4318      	orrge	r0, r3
 8000c1c:	bfbc      	itt	lt
 8000c1e:	40d0      	lsrlt	r0, r2
 8000c20:	4318      	orrlt	r0, r3
 8000c22:	4770      	bx	lr
 8000c24:	f092 0f00 	teq	r2, #0
 8000c28:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000c2c:	bf06      	itte	eq
 8000c2e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000c32:	3201      	addeq	r2, #1
 8000c34:	3b01      	subne	r3, #1
 8000c36:	e7b5      	b.n	8000ba4 <__addsf3+0x58>
 8000c38:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000c3c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000c40:	bf18      	it	ne
 8000c42:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000c46:	d021      	beq.n	8000c8c <__addsf3+0x140>
 8000c48:	ea92 0f03 	teq	r2, r3
 8000c4c:	d004      	beq.n	8000c58 <__addsf3+0x10c>
 8000c4e:	f092 0f00 	teq	r2, #0
 8000c52:	bf08      	it	eq
 8000c54:	4608      	moveq	r0, r1
 8000c56:	4770      	bx	lr
 8000c58:	ea90 0f01 	teq	r0, r1
 8000c5c:	bf1c      	itt	ne
 8000c5e:	2000      	movne	r0, #0
 8000c60:	4770      	bxne	lr
 8000c62:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000c66:	d104      	bne.n	8000c72 <__addsf3+0x126>
 8000c68:	0040      	lsls	r0, r0, #1
 8000c6a:	bf28      	it	cs
 8000c6c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000c70:	4770      	bx	lr
 8000c72:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000c76:	bf3c      	itt	cc
 8000c78:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000c7c:	4770      	bxcc	lr
 8000c7e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c82:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000c86:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c8a:	4770      	bx	lr
 8000c8c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000c90:	bf16      	itet	ne
 8000c92:	4608      	movne	r0, r1
 8000c94:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000c98:	4601      	movne	r1, r0
 8000c9a:	0242      	lsls	r2, r0, #9
 8000c9c:	bf06      	itte	eq
 8000c9e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000ca2:	ea90 0f01 	teqeq	r0, r1
 8000ca6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000caa:	4770      	bx	lr

08000cac <__aeabi_ui2f>:
 8000cac:	f04f 0300 	mov.w	r3, #0
 8000cb0:	e004      	b.n	8000cbc <__aeabi_i2f+0x8>
 8000cb2:	bf00      	nop

08000cb4 <__aeabi_i2f>:
 8000cb4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000cb8:	bf48      	it	mi
 8000cba:	4240      	negmi	r0, r0
 8000cbc:	ea5f 0c00 	movs.w	ip, r0
 8000cc0:	bf08      	it	eq
 8000cc2:	4770      	bxeq	lr
 8000cc4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000cc8:	4601      	mov	r1, r0
 8000cca:	f04f 0000 	mov.w	r0, #0
 8000cce:	e01c      	b.n	8000d0a <__aeabi_l2f+0x2a>

08000cd0 <__aeabi_ul2f>:
 8000cd0:	ea50 0201 	orrs.w	r2, r0, r1
 8000cd4:	bf08      	it	eq
 8000cd6:	4770      	bxeq	lr
 8000cd8:	f04f 0300 	mov.w	r3, #0
 8000cdc:	e00a      	b.n	8000cf4 <__aeabi_l2f+0x14>
 8000cde:	bf00      	nop

08000ce0 <__aeabi_l2f>:
 8000ce0:	ea50 0201 	orrs.w	r2, r0, r1
 8000ce4:	bf08      	it	eq
 8000ce6:	4770      	bxeq	lr
 8000ce8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000cec:	d502      	bpl.n	8000cf4 <__aeabi_l2f+0x14>
 8000cee:	4240      	negs	r0, r0
 8000cf0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000cf4:	ea5f 0c01 	movs.w	ip, r1
 8000cf8:	bf02      	ittt	eq
 8000cfa:	4684      	moveq	ip, r0
 8000cfc:	4601      	moveq	r1, r0
 8000cfe:	2000      	moveq	r0, #0
 8000d00:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000d04:	bf08      	it	eq
 8000d06:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000d0a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000d0e:	fabc f28c 	clz	r2, ip
 8000d12:	3a08      	subs	r2, #8
 8000d14:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000d18:	db10      	blt.n	8000d3c <__aeabi_l2f+0x5c>
 8000d1a:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d1e:	4463      	add	r3, ip
 8000d20:	fa00 fc02 	lsl.w	ip, r0, r2
 8000d24:	f1c2 0220 	rsb	r2, r2, #32
 8000d28:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000d2c:	fa20 f202 	lsr.w	r2, r0, r2
 8000d30:	eb43 0002 	adc.w	r0, r3, r2
 8000d34:	bf08      	it	eq
 8000d36:	f020 0001 	biceq.w	r0, r0, #1
 8000d3a:	4770      	bx	lr
 8000d3c:	f102 0220 	add.w	r2, r2, #32
 8000d40:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d44:	f1c2 0220 	rsb	r2, r2, #32
 8000d48:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000d4c:	fa21 f202 	lsr.w	r2, r1, r2
 8000d50:	eb43 0002 	adc.w	r0, r3, r2
 8000d54:	bf08      	it	eq
 8000d56:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000d5a:	4770      	bx	lr
 8000d5c:	0000      	movs	r0, r0
	...

08000d60 <__aeabi_fmul>:
 8000d60:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000d64:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000d68:	bf1e      	ittt	ne
 8000d6a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000d6e:	ea92 0f0c 	teqne	r2, ip
 8000d72:	ea93 0f0c 	teqne	r3, ip
 8000d76:	d06f      	beq.n	8000e58 <__aeabi_fmul+0xf8>
 8000d78:	441a      	add	r2, r3
 8000d7a:	ea80 0c01 	eor.w	ip, r0, r1
 8000d7e:	0240      	lsls	r0, r0, #9
 8000d80:	bf18      	it	ne
 8000d82:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000d86:	d01e      	beq.n	8000dc6 <__aeabi_fmul+0x66>
 8000d88:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000d8c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000d90:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000d94:	fba0 3101 	umull	r3, r1, r0, r1
 8000d98:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000d9c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000da0:	bf3e      	ittt	cc
 8000da2:	0049      	lslcc	r1, r1, #1
 8000da4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000da8:	005b      	lslcc	r3, r3, #1
 8000daa:	ea40 0001 	orr.w	r0, r0, r1
 8000dae:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000db2:	2afd      	cmp	r2, #253	; 0xfd
 8000db4:	d81d      	bhi.n	8000df2 <__aeabi_fmul+0x92>
 8000db6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000dba:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000dbe:	bf08      	it	eq
 8000dc0:	f020 0001 	biceq.w	r0, r0, #1
 8000dc4:	4770      	bx	lr
 8000dc6:	f090 0f00 	teq	r0, #0
 8000dca:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000dce:	bf08      	it	eq
 8000dd0:	0249      	lsleq	r1, r1, #9
 8000dd2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000dd6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000dda:	3a7f      	subs	r2, #127	; 0x7f
 8000ddc:	bfc2      	ittt	gt
 8000dde:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000de2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000de6:	4770      	bxgt	lr
 8000de8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000dec:	f04f 0300 	mov.w	r3, #0
 8000df0:	3a01      	subs	r2, #1
 8000df2:	dc5d      	bgt.n	8000eb0 <__aeabi_fmul+0x150>
 8000df4:	f112 0f19 	cmn.w	r2, #25
 8000df8:	bfdc      	itt	le
 8000dfa:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000dfe:	4770      	bxle	lr
 8000e00:	f1c2 0200 	rsb	r2, r2, #0
 8000e04:	0041      	lsls	r1, r0, #1
 8000e06:	fa21 f102 	lsr.w	r1, r1, r2
 8000e0a:	f1c2 0220 	rsb	r2, r2, #32
 8000e0e:	fa00 fc02 	lsl.w	ip, r0, r2
 8000e12:	ea5f 0031 	movs.w	r0, r1, rrx
 8000e16:	f140 0000 	adc.w	r0, r0, #0
 8000e1a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000e1e:	bf08      	it	eq
 8000e20:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000e24:	4770      	bx	lr
 8000e26:	f092 0f00 	teq	r2, #0
 8000e2a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000e2e:	bf02      	ittt	eq
 8000e30:	0040      	lsleq	r0, r0, #1
 8000e32:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000e36:	3a01      	subeq	r2, #1
 8000e38:	d0f9      	beq.n	8000e2e <__aeabi_fmul+0xce>
 8000e3a:	ea40 000c 	orr.w	r0, r0, ip
 8000e3e:	f093 0f00 	teq	r3, #0
 8000e42:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000e46:	bf02      	ittt	eq
 8000e48:	0049      	lsleq	r1, r1, #1
 8000e4a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000e4e:	3b01      	subeq	r3, #1
 8000e50:	d0f9      	beq.n	8000e46 <__aeabi_fmul+0xe6>
 8000e52:	ea41 010c 	orr.w	r1, r1, ip
 8000e56:	e78f      	b.n	8000d78 <__aeabi_fmul+0x18>
 8000e58:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000e5c:	ea92 0f0c 	teq	r2, ip
 8000e60:	bf18      	it	ne
 8000e62:	ea93 0f0c 	teqne	r3, ip
 8000e66:	d00a      	beq.n	8000e7e <__aeabi_fmul+0x11e>
 8000e68:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000e6c:	bf18      	it	ne
 8000e6e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000e72:	d1d8      	bne.n	8000e26 <__aeabi_fmul+0xc6>
 8000e74:	ea80 0001 	eor.w	r0, r0, r1
 8000e78:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000e7c:	4770      	bx	lr
 8000e7e:	f090 0f00 	teq	r0, #0
 8000e82:	bf17      	itett	ne
 8000e84:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000e88:	4608      	moveq	r0, r1
 8000e8a:	f091 0f00 	teqne	r1, #0
 8000e8e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000e92:	d014      	beq.n	8000ebe <__aeabi_fmul+0x15e>
 8000e94:	ea92 0f0c 	teq	r2, ip
 8000e98:	d101      	bne.n	8000e9e <__aeabi_fmul+0x13e>
 8000e9a:	0242      	lsls	r2, r0, #9
 8000e9c:	d10f      	bne.n	8000ebe <__aeabi_fmul+0x15e>
 8000e9e:	ea93 0f0c 	teq	r3, ip
 8000ea2:	d103      	bne.n	8000eac <__aeabi_fmul+0x14c>
 8000ea4:	024b      	lsls	r3, r1, #9
 8000ea6:	bf18      	it	ne
 8000ea8:	4608      	movne	r0, r1
 8000eaa:	d108      	bne.n	8000ebe <__aeabi_fmul+0x15e>
 8000eac:	ea80 0001 	eor.w	r0, r0, r1
 8000eb0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000eb4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000eb8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ebc:	4770      	bx	lr
 8000ebe:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000ec2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000ec6:	4770      	bx	lr

08000ec8 <__aeabi_fdiv>:
 8000ec8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000ecc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000ed0:	bf1e      	ittt	ne
 8000ed2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000ed6:	ea92 0f0c 	teqne	r2, ip
 8000eda:	ea93 0f0c 	teqne	r3, ip
 8000ede:	d069      	beq.n	8000fb4 <__aeabi_fdiv+0xec>
 8000ee0:	eba2 0203 	sub.w	r2, r2, r3
 8000ee4:	ea80 0c01 	eor.w	ip, r0, r1
 8000ee8:	0249      	lsls	r1, r1, #9
 8000eea:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000eee:	d037      	beq.n	8000f60 <__aeabi_fdiv+0x98>
 8000ef0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000ef4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000ef8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000efc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000f00:	428b      	cmp	r3, r1
 8000f02:	bf38      	it	cc
 8000f04:	005b      	lslcc	r3, r3, #1
 8000f06:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000f0a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000f0e:	428b      	cmp	r3, r1
 8000f10:	bf24      	itt	cs
 8000f12:	1a5b      	subcs	r3, r3, r1
 8000f14:	ea40 000c 	orrcs.w	r0, r0, ip
 8000f18:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000f1c:	bf24      	itt	cs
 8000f1e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000f22:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000f26:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000f2a:	bf24      	itt	cs
 8000f2c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000f30:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000f34:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000f38:	bf24      	itt	cs
 8000f3a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000f3e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000f42:	011b      	lsls	r3, r3, #4
 8000f44:	bf18      	it	ne
 8000f46:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000f4a:	d1e0      	bne.n	8000f0e <__aeabi_fdiv+0x46>
 8000f4c:	2afd      	cmp	r2, #253	; 0xfd
 8000f4e:	f63f af50 	bhi.w	8000df2 <__aeabi_fmul+0x92>
 8000f52:	428b      	cmp	r3, r1
 8000f54:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000f58:	bf08      	it	eq
 8000f5a:	f020 0001 	biceq.w	r0, r0, #1
 8000f5e:	4770      	bx	lr
 8000f60:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000f64:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000f68:	327f      	adds	r2, #127	; 0x7f
 8000f6a:	bfc2      	ittt	gt
 8000f6c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000f70:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000f74:	4770      	bxgt	lr
 8000f76:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f7a:	f04f 0300 	mov.w	r3, #0
 8000f7e:	3a01      	subs	r2, #1
 8000f80:	e737      	b.n	8000df2 <__aeabi_fmul+0x92>
 8000f82:	f092 0f00 	teq	r2, #0
 8000f86:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000f8a:	bf02      	ittt	eq
 8000f8c:	0040      	lsleq	r0, r0, #1
 8000f8e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000f92:	3a01      	subeq	r2, #1
 8000f94:	d0f9      	beq.n	8000f8a <__aeabi_fdiv+0xc2>
 8000f96:	ea40 000c 	orr.w	r0, r0, ip
 8000f9a:	f093 0f00 	teq	r3, #0
 8000f9e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000fa2:	bf02      	ittt	eq
 8000fa4:	0049      	lsleq	r1, r1, #1
 8000fa6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000faa:	3b01      	subeq	r3, #1
 8000fac:	d0f9      	beq.n	8000fa2 <__aeabi_fdiv+0xda>
 8000fae:	ea41 010c 	orr.w	r1, r1, ip
 8000fb2:	e795      	b.n	8000ee0 <__aeabi_fdiv+0x18>
 8000fb4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000fb8:	ea92 0f0c 	teq	r2, ip
 8000fbc:	d108      	bne.n	8000fd0 <__aeabi_fdiv+0x108>
 8000fbe:	0242      	lsls	r2, r0, #9
 8000fc0:	f47f af7d 	bne.w	8000ebe <__aeabi_fmul+0x15e>
 8000fc4:	ea93 0f0c 	teq	r3, ip
 8000fc8:	f47f af70 	bne.w	8000eac <__aeabi_fmul+0x14c>
 8000fcc:	4608      	mov	r0, r1
 8000fce:	e776      	b.n	8000ebe <__aeabi_fmul+0x15e>
 8000fd0:	ea93 0f0c 	teq	r3, ip
 8000fd4:	d104      	bne.n	8000fe0 <__aeabi_fdiv+0x118>
 8000fd6:	024b      	lsls	r3, r1, #9
 8000fd8:	f43f af4c 	beq.w	8000e74 <__aeabi_fmul+0x114>
 8000fdc:	4608      	mov	r0, r1
 8000fde:	e76e      	b.n	8000ebe <__aeabi_fmul+0x15e>
 8000fe0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000fe4:	bf18      	it	ne
 8000fe6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000fea:	d1ca      	bne.n	8000f82 <__aeabi_fdiv+0xba>
 8000fec:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8000ff0:	f47f af5c 	bne.w	8000eac <__aeabi_fmul+0x14c>
 8000ff4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8000ff8:	f47f af3c 	bne.w	8000e74 <__aeabi_fmul+0x114>
 8000ffc:	e75f      	b.n	8000ebe <__aeabi_fmul+0x15e>
 8000ffe:	bf00      	nop

08001000 <__gesf2>:
 8001000:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8001004:	e006      	b.n	8001014 <__cmpsf2+0x4>
 8001006:	bf00      	nop

08001008 <__lesf2>:
 8001008:	f04f 0c01 	mov.w	ip, #1
 800100c:	e002      	b.n	8001014 <__cmpsf2+0x4>
 800100e:	bf00      	nop

08001010 <__cmpsf2>:
 8001010:	f04f 0c01 	mov.w	ip, #1
 8001014:	f84d cd04 	str.w	ip, [sp, #-4]!
 8001018:	ea4f 0240 	mov.w	r2, r0, lsl #1
 800101c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8001020:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001024:	bf18      	it	ne
 8001026:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800102a:	d011      	beq.n	8001050 <__cmpsf2+0x40>
 800102c:	b001      	add	sp, #4
 800102e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8001032:	bf18      	it	ne
 8001034:	ea90 0f01 	teqne	r0, r1
 8001038:	bf58      	it	pl
 800103a:	ebb2 0003 	subspl.w	r0, r2, r3
 800103e:	bf88      	it	hi
 8001040:	17c8      	asrhi	r0, r1, #31
 8001042:	bf38      	it	cc
 8001044:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8001048:	bf18      	it	ne
 800104a:	f040 0001 	orrne.w	r0, r0, #1
 800104e:	4770      	bx	lr
 8001050:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001054:	d102      	bne.n	800105c <__cmpsf2+0x4c>
 8001056:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 800105a:	d105      	bne.n	8001068 <__cmpsf2+0x58>
 800105c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001060:	d1e4      	bne.n	800102c <__cmpsf2+0x1c>
 8001062:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8001066:	d0e1      	beq.n	800102c <__cmpsf2+0x1c>
 8001068:	f85d 0b04 	ldr.w	r0, [sp], #4
 800106c:	4770      	bx	lr
 800106e:	bf00      	nop

08001070 <__aeabi_cfrcmple>:
 8001070:	4684      	mov	ip, r0
 8001072:	4608      	mov	r0, r1
 8001074:	4661      	mov	r1, ip
 8001076:	e7ff      	b.n	8001078 <__aeabi_cfcmpeq>

08001078 <__aeabi_cfcmpeq>:
 8001078:	b50f      	push	{r0, r1, r2, r3, lr}
 800107a:	f7ff ffc9 	bl	8001010 <__cmpsf2>
 800107e:	2800      	cmp	r0, #0
 8001080:	bf48      	it	mi
 8001082:	f110 0f00 	cmnmi.w	r0, #0
 8001086:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001088 <__aeabi_fcmpeq>:
 8001088:	f84d ed08 	str.w	lr, [sp, #-8]!
 800108c:	f7ff fff4 	bl	8001078 <__aeabi_cfcmpeq>
 8001090:	bf0c      	ite	eq
 8001092:	2001      	moveq	r0, #1
 8001094:	2000      	movne	r0, #0
 8001096:	f85d fb08 	ldr.w	pc, [sp], #8
 800109a:	bf00      	nop

0800109c <__aeabi_fcmplt>:
 800109c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010a0:	f7ff ffea 	bl	8001078 <__aeabi_cfcmpeq>
 80010a4:	bf34      	ite	cc
 80010a6:	2001      	movcc	r0, #1
 80010a8:	2000      	movcs	r0, #0
 80010aa:	f85d fb08 	ldr.w	pc, [sp], #8
 80010ae:	bf00      	nop

080010b0 <__aeabi_fcmple>:
 80010b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010b4:	f7ff ffe0 	bl	8001078 <__aeabi_cfcmpeq>
 80010b8:	bf94      	ite	ls
 80010ba:	2001      	movls	r0, #1
 80010bc:	2000      	movhi	r0, #0
 80010be:	f85d fb08 	ldr.w	pc, [sp], #8
 80010c2:	bf00      	nop

080010c4 <__aeabi_fcmpge>:
 80010c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010c8:	f7ff ffd2 	bl	8001070 <__aeabi_cfrcmple>
 80010cc:	bf94      	ite	ls
 80010ce:	2001      	movls	r0, #1
 80010d0:	2000      	movhi	r0, #0
 80010d2:	f85d fb08 	ldr.w	pc, [sp], #8
 80010d6:	bf00      	nop

080010d8 <__aeabi_fcmpgt>:
 80010d8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010dc:	f7ff ffc8 	bl	8001070 <__aeabi_cfrcmple>
 80010e0:	bf34      	ite	cc
 80010e2:	2001      	movcc	r0, #1
 80010e4:	2000      	movcs	r0, #0
 80010e6:	f85d fb08 	ldr.w	pc, [sp], #8
 80010ea:	bf00      	nop
 80010ec:	0000      	movs	r0, r0
	...

080010f0 <__aeabi_f2iz>:
 80010f0:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80010f4:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80010f8:	d30f      	bcc.n	800111a <__aeabi_f2iz+0x2a>
 80010fa:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80010fe:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8001102:	d90d      	bls.n	8001120 <__aeabi_f2iz+0x30>
 8001104:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8001108:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800110c:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8001110:	fa23 f002 	lsr.w	r0, r3, r2
 8001114:	bf18      	it	ne
 8001116:	4240      	negne	r0, r0
 8001118:	4770      	bx	lr
 800111a:	f04f 0000 	mov.w	r0, #0
 800111e:	4770      	bx	lr
 8001120:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8001124:	d101      	bne.n	800112a <__aeabi_f2iz+0x3a>
 8001126:	0242      	lsls	r2, r0, #9
 8001128:	d105      	bne.n	8001136 <__aeabi_f2iz+0x46>
 800112a:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 800112e:	bf08      	it	eq
 8001130:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8001134:	4770      	bx	lr
 8001136:	f04f 0000 	mov.w	r0, #0
 800113a:	4770      	bx	lr
 800113c:	0000      	movs	r0, r0
	...

08001140 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001140:	4770      	bx	lr
 8001142:	bf00      	nop
	...

08001150 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001150:	e7fe      	b.n	8001150 <__default_exit>
 8001152:	bf00      	nop
	...

08001160 <_unhandled_exception>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001160:	e7fe      	b.n	8001160 <_unhandled_exception>
 8001162:	bf00      	nop
	...

08001170 <_idle_thread>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8001170:	4b02      	ldr	r3, [pc, #8]	; (800117c <_idle_thread+0xc>)
 8001172:	4a03      	ldr	r2, [pc, #12]	; (8001180 <_idle_thread+0x10>)
 8001174:	699b      	ldr	r3, [r3, #24]
 8001176:	619a      	str	r2, [r3, #24]
 8001178:	e7fe      	b.n	8001178 <_idle_thread+0x8>
 800117a:	bf00      	nop
 800117c:	20000e78 	.word	0x20000e78
 8001180:	0800a430 	.word	0x0800a430
	...

08001190 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8001190:	4b1e      	ldr	r3, [pc, #120]	; (800120c <chSysInit+0x7c>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8001192:	4a1f      	ldr	r2, [pc, #124]	; (8001210 <chSysInit+0x80>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001194:	481f      	ldr	r0, [pc, #124]	; (8001214 <chSysInit+0x84>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001196:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8001198:	2400      	movs	r4, #0
 800119a:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800119c:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800119e:	4e1e      	ldr	r6, [pc, #120]	; (8001218 <chSysInit+0x88>)
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80011a0:	4d1e      	ldr	r5, [pc, #120]	; (800121c <chSysInit+0x8c>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 80011a2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 80011a6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 80011a8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80011aa:	60da      	str	r2, [r3, #12]
 80011ac:	68f2      	ldr	r2, [r6, #12]
 80011ae:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80011b2:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80011b4:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80011b6:	2120      	movs	r1, #32
 80011b8:	f042 0201 	orr.w	r2, r2, #1
 80011bc:	2610      	movs	r6, #16
 80011be:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80011c0:	b083      	sub	sp, #12
 80011c2:	77de      	strb	r6, [r3, #31]
 80011c4:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 80011c8:	f000 f9ca 	bl	8001560 <_scheduler_init>
  _vt_init();
 80011cc:	f000 f908 	bl	80013e0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80011d0:	f000 fc96 	bl	8001b00 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80011d4:	f001 fcac 	bl	8002b30 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80011d8:	f001 fcf2 	bl	8002bc0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80011dc:	4628      	mov	r0, r5
 80011de:	2140      	movs	r1, #64	; 0x40
 80011e0:	f000 fabe 	bl	8001760 <_thread_init>
 80011e4:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80011e8:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80011ea:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80011ec:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80011ee:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011f2:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 80011f4:	699b      	ldr	r3, [r3, #24]
 80011f6:	490a      	ldr	r1, [pc, #40]	; (8001220 <chSysInit+0x90>)
 80011f8:	6199      	str	r1, [r3, #24]

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  (void) chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa),
 80011fa:	f105 0048 	add.w	r0, r5, #72	; 0x48
 80011fe:	9400      	str	r4, [sp, #0]
 8001200:	4b08      	ldr	r3, [pc, #32]	; (8001224 <chSysInit+0x94>)
 8001202:	21d8      	movs	r1, #216	; 0xd8
 8001204:	f000 fafc 	bl	8001800 <chThdCreateStatic>
                           IDLEPRIO, (tfunc_t)_idle_thread, NULL);
#endif
}
 8001208:	b003      	add	sp, #12
 800120a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800120c:	e000ed00 	.word	0xe000ed00
 8001210:	05fa0300 	.word	0x05fa0300
 8001214:	e0001000 	.word	0xe0001000
 8001218:	e000edf0 	.word	0xe000edf0
 800121c:	20000ea8 	.word	0x20000ea8
 8001220:	0800a440 	.word	0x0800a440
 8001224:	08001171 	.word	0x08001171
	...

08001230 <chSysHalt>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001230:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001232:	4b01      	ldr	r3, [pc, #4]	; (8001238 <chSysHalt+0x8>)
 8001234:	62d8      	str	r0, [r3, #44]	; 0x2c
 8001236:	e7fe      	b.n	8001236 <chSysHalt+0x6>
 8001238:	20000e78 	.word	0x20000e78
 800123c:	00000000 	.word	0x00000000

08001240 <chSysIntegrityCheckI>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001240:	07c2      	lsls	r2, r0, #31
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8001242:	b410      	push	{r4}
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001244:	d512      	bpl.n	800126c <chSysIntegrityCheckI+0x2c>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 8001246:	4a2c      	ldr	r2, [pc, #176]	; (80012f8 <chSysIntegrityCheckI+0xb8>)
 8001248:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800124a:	4291      	cmp	r1, r2
 800124c:	d042      	beq.n	80012d4 <chSysIntegrityCheckI+0x94>
 800124e:	2300      	movs	r3, #0
      n++;
      tp = tp->p_next;
 8001250:	6809      	ldr	r1, [r1, #0]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001252:	4291      	cmp	r1, r2
      n++;
 8001254:	f103 0301 	add.w	r3, r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001258:	d1fa      	bne.n	8001250 <chSysIntegrityCheckI+0x10>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800125a:	684c      	ldr	r4, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800125c:	428c      	cmp	r4, r1
 800125e:	d036      	beq.n	80012ce <chSysIntegrityCheckI+0x8e>
      n--;
      tp = tp->p_prev;
 8001260:	6864      	ldr	r4, [r4, #4]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001262:	4294      	cmp	r4, r2
      n--;
 8001264:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001268:	d1fa      	bne.n	8001260 <chSysIntegrityCheckI+0x20>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800126a:	bb83      	cbnz	r3, 80012ce <chSysIntegrityCheckI+0x8e>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800126c:	0783      	lsls	r3, r0, #30
 800126e:	d514      	bpl.n	800129a <chSysIntegrityCheckI+0x5a>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 8001270:	4a21      	ldr	r2, [pc, #132]	; (80012f8 <chSysIntegrityCheckI+0xb8>)
 8001272:	4614      	mov	r4, r2
 8001274:	f854 1f1c 	ldr.w	r1, [r4, #28]!
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001278:	42a1      	cmp	r1, r4
 800127a:	d031      	beq.n	80012e0 <chSysIntegrityCheckI+0xa0>
 800127c:	2300      	movs	r3, #0
      n++;
      vtp = vtp->vt_next;
 800127e:	6809      	ldr	r1, [r1, #0]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001280:	42a1      	cmp	r1, r4
      n++;
 8001282:	f103 0301 	add.w	r3, r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001286:	d1fa      	bne.n	800127e <chSysIntegrityCheckI+0x3e>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 8001288:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800128a:	428a      	cmp	r2, r1
 800128c:	d01f      	beq.n	80012ce <chSysIntegrityCheckI+0x8e>
      n--;
      vtp = vtp->vt_prev;
 800128e:	6852      	ldr	r2, [r2, #4]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001290:	42a2      	cmp	r2, r4
      n--;
 8001292:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001296:	d1fa      	bne.n	800128e <chSysIntegrityCheckI+0x4e>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001298:	b9cb      	cbnz	r3, 80012ce <chSysIntegrityCheckI+0x8e>
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800129a:	f010 0004 	ands.w	r0, r0, #4
 800129e:	d014      	beq.n	80012ca <chSysIntegrityCheckI+0x8a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
 80012a0:	4a15      	ldr	r2, [pc, #84]	; (80012f8 <chSysIntegrityCheckI+0xb8>)
 80012a2:	6913      	ldr	r3, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 80012a4:	4293      	cmp	r3, r2
 80012a6:	d021      	beq.n	80012ec <chSysIntegrityCheckI+0xac>
 80012a8:	2000      	movs	r0, #0
      n++;
      tp = tp->p_newer;
 80012aa:	691b      	ldr	r3, [r3, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 80012ac:	4293      	cmp	r3, r2
      n++;
 80012ae:	f100 0001 	add.w	r0, r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 80012b2:	d1fa      	bne.n	80012aa <chSysIntegrityCheckI+0x6a>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 80012b4:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80012b6:	4299      	cmp	r1, r3
 80012b8:	d009      	beq.n	80012ce <chSysIntegrityCheckI+0x8e>
      n--;
      tp = tp->p_older;
 80012ba:	6949      	ldr	r1, [r1, #20]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 80012bc:	4291      	cmp	r1, r2
      n--;
 80012be:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 80012c2:	d1fa      	bne.n	80012ba <chSysIntegrityCheckI+0x7a>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80012c4:	3000      	adds	r0, #0
 80012c6:	bf18      	it	ne
 80012c8:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80012ca:	bc10      	pop	{r4}
 80012cc:	4770      	bx	lr
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80012ce:	2001      	movs	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80012d0:	bc10      	pop	{r4}
 80012d2:	4770      	bx	lr
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 80012d4:	6854      	ldr	r4, [r2, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80012d6:	4294      	cmp	r4, r2
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80012d8:	bf18      	it	ne
 80012da:	2300      	movne	r3, #0
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80012dc:	d1c0      	bne.n	8001260 <chSysIntegrityCheckI+0x20>
 80012de:	e7c5      	b.n	800126c <chSysIntegrityCheckI+0x2c>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80012e0:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80012e2:	42a2      	cmp	r2, r4
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 80012e4:	bf18      	it	ne
 80012e6:	2300      	movne	r3, #0
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80012e8:	d1d1      	bne.n	800128e <chSysIntegrityCheckI+0x4e>
 80012ea:	e7d6      	b.n	800129a <chSysIntegrityCheckI+0x5a>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 80012ec:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80012ee:	4299      	cmp	r1, r3
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80012f0:	f04f 0000 	mov.w	r0, #0
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 80012f4:	d1e1      	bne.n	80012ba <chSysIntegrityCheckI+0x7a>
 80012f6:	e7e8      	b.n	80012ca <chSysIntegrityCheckI+0x8a>
 80012f8:	20000e78 	.word	0x20000e78
 80012fc:	00000000 	.word	0x00000000

08001300 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001300:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001304:	4d1b      	ldr	r5, [pc, #108]	; (8001374 <chSysTimerHandlerI+0x74>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001306:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 800130a:	69ec      	ldr	r4, [r5, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800130c:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800130e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8001310:	68a3      	ldr	r3, [r4, #8]
 8001312:	1a42      	subs	r2, r0, r1
 8001314:	429a      	cmp	r2, r3
 8001316:	f105 091c 	add.w	r9, r5, #28
 800131a:	d31a      	bcc.n	8001352 <chSysTimerHandlerI+0x52>
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800131c:	2600      	movs	r6, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800131e:	f04f 0820 	mov.w	r8, #32
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001322:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8001324:	f8d4 a00c 	ldr.w	sl, [r4, #12]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001328:	440b      	add	r3, r1
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800132a:	454a      	cmp	r2, r9
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800132c:	62ab      	str	r3, [r5, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800132e:	f8c2 9004 	str.w	r9, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8001332:	61ea      	str	r2, [r5, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8001334:	60e6      	str	r6, [r4, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001336:	d018      	beq.n	800136a <chSysTimerHandlerI+0x6a>
 8001338:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 800133c:	6920      	ldr	r0, [r4, #16]
 800133e:	47d0      	blx	sl
 8001340:	f388 8811 	msr	BASEPRI, r8
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8001344:	69ec      	ldr	r4, [r5, #28]
 8001346:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001348:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800134a:	68a3      	ldr	r3, [r4, #8]
 800134c:	1a42      	subs	r2, r0, r1
 800134e:	4293      	cmp	r3, r2
 8001350:	d9e7      	bls.n	8001322 <chSysTimerHandlerI+0x22>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001352:	454c      	cmp	r4, r9
 8001354:	d00c      	beq.n	8001370 <chSysTimerHandlerI+0x70>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8001356:	440b      	add	r3, r1
 8001358:	1a1b      	subs	r3, r3, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800135a:	2b01      	cmp	r3, #1
 800135c:	bf98      	it	ls
 800135e:	2302      	movls	r3, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001360:	4418      	add	r0, r3
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8001362:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001366:	f001 bdc3 	b.w	8002ef0 <stSetAlarm>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 800136a:	f001 fdb9 	bl	8002ee0 <stStopAlarm>
 800136e:	e7e3      	b.n	8001338 <chSysTimerHandlerI+0x38>
 8001370:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001374:	20000e78 	.word	0x20000e78
	...

08001380 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 8001380:	f3ef 8012 	mrs	r0, BASEPRI_MAX
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8001384:	b920      	cbnz	r0, 8001390 <chSysGetStatusAndLockX+0x10>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001386:	f3ef 8305 	mrs	r3, IPSR

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800138a:	2320      	movs	r3, #32
 800138c:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8001390:	4770      	bx	lr
 8001392:	bf00      	nop
	...

080013a0 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 80013a0:	b968      	cbnz	r0, 80013be <chSysRestoreStatusX+0x1e>
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80013a2:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80013a4:	f3ef 8405 	mrs	r4, IPSR

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80013a8:	f3c4 0408 	ubfx	r4, r4, #0, #9
 80013ac:	b114      	cbz	r4, 80013b4 <chSysRestoreStatusX+0x14>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80013ae:	f380 8811 	msr	BASEPRI, r0
 80013b2:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 80013b4:	f000 f9bc 	bl	8001730 <chSchRescheduleS>
 80013b8:	f384 8811 	msr	BASEPRI, r4
 80013bc:	bd10      	pop	{r4, pc}
 80013be:	4770      	bx	lr

080013c0 <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80013c0:	4a03      	ldr	r2, [pc, #12]	; (80013d0 <chSysPolledDelayX+0x10>)
 80013c2:	6851      	ldr	r1, [r2, #4]
 80013c4:	6853      	ldr	r3, [r2, #4]
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80013c6:	1a5b      	subs	r3, r3, r1
 80013c8:	4283      	cmp	r3, r0
 80013ca:	d3fb      	bcc.n	80013c4 <chSysPolledDelayX+0x4>
  }
}
 80013cc:	4770      	bx	lr
 80013ce:	bf00      	nop
 80013d0:	e0001000 	.word	0xe0001000
	...

080013e0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80013e0:	4b05      	ldr	r3, [pc, #20]	; (80013f8 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 80013e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80013e6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80013ea:	2100      	movs	r1, #0
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 80013ec:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80013ee:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80013f0:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80013f2:	621a      	str	r2, [r3, #32]
 80013f4:	4770      	bx	lr
 80013f6:	bf00      	nop
 80013f8:	20000e78 	.word	0x20000e78
 80013fc:	00000000 	.word	0x00000000

08001400 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001402:	4e1c      	ldr	r6, [pc, #112]	; (8001474 <chVTDoSetI+0x74>)
 8001404:	4634      	mov	r4, r6
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001406:	2901      	cmp	r1, #1
 8001408:	bf98      	it	ls
 800140a:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800140c:	f854 7f1c 	ldr.w	r7, [r4, #28]!
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001410:	6103      	str	r3, [r0, #16]
 8001412:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001416:	42a7      	cmp	r7, r4
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001418:	4605      	mov	r5, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800141a:	60c2      	str	r2, [r0, #12]
 800141c:	6a58      	ldr	r0, [r3, #36]	; 0x24
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800141e:	d01e      	beq.n	800145e <chVTDoSetI+0x5e>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001420:	6ab4      	ldr	r4, [r6, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001422:	68bb      	ldr	r3, [r7, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001424:	4408      	add	r0, r1
 8001426:	1b04      	subs	r4, r0, r4
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001428:	429c      	cmp	r4, r3
 800142a:	d315      	bcc.n	8001458 <chVTDoSetI+0x58>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800142c:	69f3      	ldr	r3, [r6, #28]
  while (p->vt_delta < delta) {
 800142e:	689a      	ldr	r2, [r3, #8]
 8001430:	4294      	cmp	r4, r2
 8001432:	d904      	bls.n	800143e <chVTDoSetI+0x3e>
    delta -= p->vt_delta;
    p = p->vt_next;
 8001434:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001436:	1aa4      	subs	r4, r4, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001438:	689a      	ldr	r2, [r3, #8]
 800143a:	42a2      	cmp	r2, r4
 800143c:	d3fa      	bcc.n	8001434 <chVTDoSetI+0x34>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800143e:	685a      	ldr	r2, [r3, #4]
 8001440:	606a      	str	r2, [r5, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001442:	602b      	str	r3, [r5, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8001444:	6015      	str	r5, [r2, #0]
  p->vt_prev = vtp;
 8001446:	605d      	str	r5, [r3, #4]
  vtp->vt_delta = delta
 8001448:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800144a:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800144c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001450:	1b14      	subs	r4, r2, r4
 8001452:	609c      	str	r4, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001454:	6271      	str	r1, [r6, #36]	; 0x24
 8001456:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001458:	f001 fd4a 	bl	8002ef0 <stSetAlarm>
 800145c:	e7e6      	b.n	800142c <chVTDoSetI+0x2c>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800145e:	62b0      	str	r0, [r6, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8001460:	61f5      	str	r5, [r6, #28]
      ch.vtlist.vt_prev = vtp;
 8001462:	6235      	str	r5, [r6, #32]
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 8001464:	4408      	add	r0, r1
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8001466:	602f      	str	r7, [r5, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001468:	606f      	str	r7, [r5, #4]
      vtp->vt_delta = delay;
 800146a:	60a9      	str	r1, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
}
 800146c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8001470:	f001 bd2e 	b.w	8002ed0 <stStartAlarm>
 8001474:	20000e78 	.word	0x20000e78
	...

08001480 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001480:	4b19      	ldr	r3, [pc, #100]	; (80014e8 <chVTDoResetI+0x68>)
 8001482:	69da      	ldr	r2, [r3, #28]
 8001484:	4282      	cmp	r2, r0
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001486:	b410      	push	{r4}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001488:	d00f      	beq.n	80014aa <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800148a:	6841      	ldr	r1, [r0, #4]
 800148c:	6802      	ldr	r2, [r0, #0]
 800148e:	600a      	str	r2, [r1, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001490:	6802      	ldr	r2, [r0, #0]
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001492:	331c      	adds	r3, #28
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 8001494:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001496:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001498:	6051      	str	r1, [r2, #4]
    vtp->vt_func = NULL;
 800149a:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800149c:	d003      	beq.n	80014a6 <chVTDoResetI+0x26>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 800149e:	6883      	ldr	r3, [r0, #8]
 80014a0:	6891      	ldr	r1, [r2, #8]
 80014a2:	440b      	add	r3, r1
 80014a4:	6093      	str	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80014a6:	bc10      	pop	{r4}
 80014a8:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80014aa:	4618      	mov	r0, r3
 80014ac:	6811      	ldr	r1, [r2, #0]
 80014ae:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80014b2:	2400      	movs	r4, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80014b4:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80014b6:	6048      	str	r0, [r1, #4]
  vtp->vt_func = NULL;
 80014b8:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80014ba:	d012      	beq.n	80014e2 <chVTDoResetI+0x62>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80014bc:	6892      	ldr	r2, [r2, #8]
 80014be:	6888      	ldr	r0, [r1, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80014c0:	6a9c      	ldr	r4, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80014c2:	1883      	adds	r3, r0, r2
 80014c4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80014c8:	608b      	str	r3, [r1, #8]
 80014ca:	6a50      	ldr	r0, [r2, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80014cc:	1b02      	subs	r2, r0, r4

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80014ce:	4293      	cmp	r3, r2
 80014d0:	d9e9      	bls.n	80014a6 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80014d2:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80014d4:	2b01      	cmp	r3, #1
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80014d6:	bf98      	it	ls
 80014d8:	2302      	movls	r3, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80014da:	4418      	add	r0, r3
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80014dc:	bc10      	pop	{r4}
 80014de:	f001 bd07 	b.w	8002ef0 <stSetAlarm>
 80014e2:	bc10      	pop	{r4}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80014e4:	f001 bcfc 	b.w	8002ee0 <stStopAlarm>
 80014e8:	20000e78 	.word	0x20000e78
 80014ec:	00000000 	.word	0x00000000

080014f0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80014f0:	b410      	push	{r4}
 80014f2:	2320      	movs	r3, #32
 80014f4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80014f8:	7f03      	ldrb	r3, [r0, #28]
 80014fa:	2b07      	cmp	r3, #7
 80014fc:	d80e      	bhi.n	800151c <wakeup+0x2c>
 80014fe:	e8df f003 	tbb	[pc, r3]
 8001502:	0d26      	.short	0x0d26
 8001504:	0408220d 	.word	0x0408220d
 8001508:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800150a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800150c:	6893      	ldr	r3, [r2, #8]
 800150e:	3301      	adds	r3, #1
 8001510:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001512:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001516:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001518:	6802      	ldr	r2, [r0, #0]
 800151a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800151c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001520:	2200      	movs	r2, #0
 8001522:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001524:	4b0c      	ldr	r3, [pc, #48]	; (8001558 <wakeup+0x68>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001526:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001528:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800152a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800152c:	689a      	ldr	r2, [r3, #8]
 800152e:	428a      	cmp	r2, r1
 8001530:	d2fb      	bcs.n	800152a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001532:	685a      	ldr	r2, [r3, #4]
 8001534:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001536:	6003      	str	r3, [r0, #0]
 8001538:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800153a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800153c:	6058      	str	r0, [r3, #4]
 800153e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001542:	bc10      	pop	{r4}
 8001544:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001546:	6a03      	ldr	r3, [r0, #32]
 8001548:	2200      	movs	r2, #0
 800154a:	601a      	str	r2, [r3, #0]
    break;
 800154c:	e7e6      	b.n	800151c <wakeup+0x2c>
 800154e:	2300      	movs	r3, #0
 8001550:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001554:	bc10      	pop	{r4}
 8001556:	4770      	bx	lr
 8001558:	20000e78 	.word	0x20000e78
 800155c:	00000000 	.word	0x00000000

08001560 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001560:	4b03      	ldr	r3, [pc, #12]	; (8001570 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001562:	2200      	movs	r2, #0
 8001564:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001566:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8001568:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800156a:	615b      	str	r3, [r3, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800156c:	609a      	str	r2, [r3, #8]
 800156e:	4770      	bx	lr
 8001570:	20000e78 	.word	0x20000e78
	...

08001580 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001580:	2200      	movs	r2, #0
 8001582:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001584:	4b07      	ldr	r3, [pc, #28]	; (80015a4 <chSchReadyI+0x24>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001586:	b410      	push	{r4}
 8001588:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800158a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800158c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800158e:	689a      	ldr	r2, [r3, #8]
 8001590:	428a      	cmp	r2, r1
 8001592:	d2fb      	bcs.n	800158c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001594:	685a      	ldr	r2, [r3, #4]
 8001596:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001598:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 800159a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800159c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800159e:	605c      	str	r4, [r3, #4]

  return tp;
}
 80015a0:	bc10      	pop	{r4}
 80015a2:	4770      	bx	lr
 80015a4:	20000e78 	.word	0x20000e78
	...

080015b0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80015b0:	4b07      	ldr	r3, [pc, #28]	; (80015d0 <chSchGoSleepS+0x20>)
 80015b2:	6999      	ldr	r1, [r3, #24]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80015b4:	681a      	ldr	r2, [r3, #0]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80015b6:	b410      	push	{r4}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 80015b8:	7708      	strb	r0, [r1, #28]

  tqp->p_next = tp->p_next;
 80015ba:	6810      	ldr	r0, [r2, #0]
 80015bc:	6018      	str	r0, [r3, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80015be:	2401      	movs	r4, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 80015c0:	6043      	str	r3, [r0, #4]
 80015c2:	7714      	strb	r4, [r2, #28]
  chSysSwitch(currp, otp);
 80015c4:	4610      	mov	r0, r2
}
 80015c6:	bc10      	pop	{r4}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80015c8:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 80015ca:	f7fe be59 	b.w	8000280 <_port_switch>
 80015ce:	bf00      	nop
 80015d0:	20000e78 	.word	0x20000e78
	...

080015e0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80015e0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80015e2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80015e4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80015e6:	d012      	beq.n	800160e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80015e8:	4c0c      	ldr	r4, [pc, #48]	; (800161c <chSchGoSleepTimeoutS+0x3c>)
 80015ea:	4a0d      	ldr	r2, [pc, #52]	; (8001620 <chSchGoSleepTimeoutS+0x40>)
 80015ec:	69a3      	ldr	r3, [r4, #24]
 80015ee:	4605      	mov	r5, r0
 80015f0:	a801      	add	r0, sp, #4
 80015f2:	f7ff ff05 	bl	8001400 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80015f6:	4628      	mov	r0, r5
 80015f8:	f7ff ffda 	bl	80015b0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80015fc:	9b04      	ldr	r3, [sp, #16]
 80015fe:	b113      	cbz	r3, 8001606 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8001600:	a801      	add	r0, sp, #4
 8001602:	f7ff ff3d 	bl	8001480 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8001606:	69a3      	ldr	r3, [r4, #24]
}
 8001608:	6a18      	ldr	r0, [r3, #32]
 800160a:	b007      	add	sp, #28
 800160c:	bd30      	pop	{r4, r5, pc}
 800160e:	4c03      	ldr	r4, [pc, #12]	; (800161c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001610:	f7ff ffce 	bl	80015b0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8001614:	69a3      	ldr	r3, [r4, #24]
}
 8001616:	6a18      	ldr	r0, [r3, #32]
 8001618:	b007      	add	sp, #28
 800161a:	bd30      	pop	{r4, r5, pc}
 800161c:	20000e78 	.word	0x20000e78
 8001620:	080014f1 	.word	0x080014f1
	...

08001630 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001630:	4b14      	ldr	r3, [pc, #80]	; (8001684 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001632:	b470      	push	{r4, r5, r6}
 8001634:	4604      	mov	r4, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001636:	699d      	ldr	r5, [r3, #24]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8001638:	6201      	str	r1, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800163a:	68a8      	ldr	r0, [r5, #8]
 800163c:	68a1      	ldr	r1, [r4, #8]
 800163e:	4281      	cmp	r1, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001640:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001644:	d80b      	bhi.n	800165e <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001646:	7722      	strb	r2, [r4, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001648:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800164a:	689a      	ldr	r2, [r3, #8]
 800164c:	4291      	cmp	r1, r2
 800164e:	d9fb      	bls.n	8001648 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001650:	685a      	ldr	r2, [r3, #4]
 8001652:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001654:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001656:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8001658:	605c      	str	r4, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800165a:	bc70      	pop	{r4, r5, r6}
 800165c:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800165e:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001660:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 8001662:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001664:	6891      	ldr	r1, [r2, #8]
 8001666:	4288      	cmp	r0, r1
 8001668:	d9fb      	bls.n	8001662 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800166a:	6850      	ldr	r0, [r2, #4]
 800166c:	6068      	str	r0, [r5, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800166e:	2601      	movs	r6, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001670:	602a      	str	r2, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001672:	6005      	str	r5, [r0, #0]
  cp->p_prev = tp;
 8001674:	6055      	str	r5, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001676:	7726      	strb	r6, [r4, #28]
    chSysSwitch(ntp, otp);
 8001678:	4629      	mov	r1, r5
 800167a:	4620      	mov	r0, r4
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800167c:	619c      	str	r4, [r3, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800167e:	bc70      	pop	{r4, r5, r6}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001680:	f7fe bdfe 	b.w	8000280 <_port_switch>
 8001684:	20000e78 	.word	0x20000e78
	...

08001690 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001690:	4b04      	ldr	r3, [pc, #16]	; (80016a4 <chSchIsPreemptionRequired+0x14>)
 8001692:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8001694:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001696:	6890      	ldr	r0, [r2, #8]
 8001698:	689b      	ldr	r3, [r3, #8]
#endif
}
 800169a:	4298      	cmp	r0, r3
 800169c:	bf94      	ite	ls
 800169e:	2000      	movls	r0, #0
 80016a0:	2001      	movhi	r0, #1
 80016a2:	4770      	bx	lr
 80016a4:	20000e78 	.word	0x20000e78
	...

080016b0 <chSchDoRescheduleBehind>:
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
 80016b0:	4a0d      	ldr	r2, [pc, #52]	; (80016e8 <chSchDoRescheduleBehind+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80016b2:	6810      	ldr	r0, [r2, #0]

  tqp->p_next = tp->p_next;
 80016b4:	6803      	ldr	r3, [r0, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 80016b6:	b430      	push	{r4, r5}
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80016b8:	2101      	movs	r1, #1
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
 80016ba:	6994      	ldr	r4, [r2, #24]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80016bc:	605a      	str	r2, [r3, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80016be:	2500      	movs	r5, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80016c0:	7701      	strb	r1, [r0, #28]
 80016c2:	68a1      	ldr	r1, [r4, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80016c4:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80016c6:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80016c8:	7725      	strb	r5, [r4, #28]
 80016ca:	e000      	b.n	80016ce <chSchDoRescheduleBehind+0x1e>
 80016cc:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 80016ce:	689a      	ldr	r2, [r3, #8]
 80016d0:	428a      	cmp	r2, r1
 80016d2:	d2fb      	bcs.n	80016cc <chSchDoRescheduleBehind+0x1c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80016d4:	685a      	ldr	r2, [r3, #4]
 80016d6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80016d8:	6023      	str	r3, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80016da:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80016dc:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80016de:	605c      	str	r4, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
}
 80016e0:	bc30      	pop	{r4, r5}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80016e2:	f7fe bdcd 	b.w	8000280 <_port_switch>
 80016e6:	bf00      	nop
 80016e8:	20000e78 	.word	0x20000e78
 80016ec:	00000000 	.word	0x00000000

080016f0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80016f0:	4a0d      	ldr	r2, [pc, #52]	; (8001728 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80016f2:	6810      	ldr	r0, [r2, #0]

  tqp->p_next = tp->p_next;
 80016f4:	6803      	ldr	r3, [r0, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80016f6:	b430      	push	{r4, r5}
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80016f8:	2101      	movs	r1, #1
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80016fa:	6994      	ldr	r4, [r2, #24]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80016fc:	605a      	str	r2, [r3, #4]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 80016fe:	2500      	movs	r5, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001700:	7701      	strb	r1, [r0, #28]
 8001702:	68a1      	ldr	r1, [r4, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001704:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001706:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001708:	7725      	strb	r5, [r4, #28]
 800170a:	e000      	b.n	800170e <chSchDoRescheduleAhead+0x1e>
 800170c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800170e:	689a      	ldr	r2, [r3, #8]
 8001710:	428a      	cmp	r2, r1
 8001712:	d8fb      	bhi.n	800170c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001714:	685a      	ldr	r2, [r3, #4]
 8001716:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001718:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800171a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 800171c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 800171e:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 8001720:	bc30      	pop	{r4, r5}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8001722:	f7fe bdad 	b.w	8000280 <_port_switch>
 8001726:	bf00      	nop
 8001728:	20000e78 	.word	0x20000e78
 800172c:	00000000 	.word	0x00000000

08001730 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8001730:	4b04      	ldr	r3, [pc, #16]	; (8001744 <chSchRescheduleS+0x14>)
 8001732:	681a      	ldr	r2, [r3, #0]
 8001734:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8001736:	6892      	ldr	r2, [r2, #8]
 8001738:	689b      	ldr	r3, [r3, #8]
 800173a:	429a      	cmp	r2, r3
 800173c:	d800      	bhi.n	8001740 <chSchRescheduleS+0x10>
 800173e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8001740:	f7ff bfd6 	b.w	80016f0 <chSchDoRescheduleAhead>
 8001744:	20000e78 	.word	0x20000e78
	...

08001750 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8001750:	f7ff bfce 	b.w	80016f0 <chSchDoRescheduleAhead>
	...

08001760 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001760:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001762:	4c0d      	ldr	r4, [pc, #52]	; (8001798 <_thread_init+0x38>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001764:	63c1      	str	r1, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001766:	6965      	ldr	r5, [r4, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001768:	6081      	str	r1, [r0, #8]
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800176a:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800176c:	f100 0128 	add.w	r1, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001770:	f04f 0e02 	mov.w	lr, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001774:	2701      	movs	r7, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001776:	f100 0624 	add.w	r6, r0, #36	; 0x24
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800177a:	6145      	str	r5, [r0, #20]
 800177c:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800177e:	f880 e01c 	strb.w	lr, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001782:	7787      	strb	r7, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001784:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001786:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001788:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800178a:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 800178c:	6128      	str	r0, [r5, #16]
 800178e:	6160      	str	r0, [r4, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001790:	6246      	str	r6, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001792:	6281      	str	r1, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8001794:	62c1      	str	r1, [r0, #44]	; 0x2c
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8001796:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001798:	20000e78 	.word	0x20000e78
 800179c:	00000000 	.word	0x00000000

080017a0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80017a0:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80017a2:	4d13      	ldr	r5, [pc, #76]	; (80017f0 <chThdCreateI+0x50>)
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80017a4:	9f05      	ldr	r7, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80017a6:	f1a1 0e24 	sub.w	lr, r1, #36	; 0x24
 80017aa:	eb00 060e 	add.w	r6, r0, lr
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80017ae:	6969      	ldr	r1, [r5, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80017b0:	60c6      	str	r6, [r0, #12]
 80017b2:	f840 300e 	str.w	r3, [r0, lr]
 80017b6:	4b0f      	ldr	r3, [pc, #60]	; (80017f4 <chThdCreateI+0x54>)
 80017b8:	6077      	str	r7, [r6, #4]
 80017ba:	6233      	str	r3, [r6, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80017bc:	f04f 0e02 	mov.w	lr, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80017c0:	2300      	movs	r3, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80017c2:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80017c4:	63c2      	str	r2, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80017c6:	2701      	movs	r7, #1
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80017c8:	f100 0228 	add.w	r2, r0, #40	; 0x28
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80017cc:	f100 0624 	add.w	r6, r0, #36	; 0x24
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80017d0:	6105      	str	r5, [r0, #16]
 80017d2:	6141      	str	r1, [r0, #20]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80017d4:	f880 e01c 	strb.w	lr, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80017d8:	7787      	strb	r7, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80017da:	7743      	strb	r3, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80017dc:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80017de:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80017e0:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 80017e2:	6108      	str	r0, [r1, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80017e4:	6246      	str	r6, [r0, #36]	; 0x24
 80017e6:	6168      	str	r0, [r5, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80017e8:	6282      	str	r2, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 80017ea:	62c2      	str	r2, [r0, #44]	; 0x2c
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 80017ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80017ee:	bf00      	nop
 80017f0:	20000e78 	.word	0x20000e78
 80017f4:	08000291 	.word	0x08000291
	...

08001800 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001802:	4604      	mov	r4, r0
 8001804:	2520      	movs	r5, #32
 8001806:	f385 8811 	msr	BASEPRI, r5
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800180a:	4e14      	ldr	r6, [pc, #80]	; (800185c <chThdCreateStatic+0x5c>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800180c:	3924      	subs	r1, #36	; 0x24
 800180e:	1845      	adds	r5, r0, r1
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001810:	6977      	ldr	r7, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001812:	60c5      	str	r5, [r0, #12]
 8001814:	5043      	str	r3, [r0, r1]
 8001816:	9b06      	ldr	r3, [sp, #24]
 8001818:	606b      	str	r3, [r5, #4]
 800181a:	4911      	ldr	r1, [pc, #68]	; (8001860 <chThdCreateStatic+0x60>)
 800181c:	6229      	str	r1, [r5, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800181e:	2302      	movs	r3, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001820:	2500      	movs	r5, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001822:	7703      	strb	r3, [r0, #28]
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001824:	f100 0e24 	add.w	lr, r0, #36	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001828:	f100 0328 	add.w	r3, r0, #40	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800182c:	2101      	movs	r1, #1
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800182e:	6082      	str	r2, [r0, #8]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001830:	7781      	strb	r1, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001832:	6106      	str	r6, [r0, #16]
 8001834:	6147      	str	r7, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001836:	63c2      	str	r2, [r0, #60]	; 0x3c
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001838:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800183a:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800183c:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800183e:	6185      	str	r5, [r0, #24]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8001840:	4629      	mov	r1, r5
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001842:	6138      	str	r0, [r7, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001844:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001848:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 800184a:	62c3      	str	r3, [r0, #44]	; 0x2c
 800184c:	6170      	str	r0, [r6, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 800184e:	f7ff feef 	bl	8001630 <chSchWakeupS>
 8001852:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8001856:	4620      	mov	r0, r4
 8001858:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800185a:	bf00      	nop
 800185c:	20000e78 	.word	0x20000e78
 8001860:	08000291 	.word	0x08000291
	...

08001870 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001870:	b508      	push	{r3, lr}
 8001872:	2320      	movs	r3, #32
 8001874:	f383 8811 	msr	BASEPRI, r3
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8001878:	f7ff fe82 	bl	8001580 <chSchReadyI>
 800187c:	2300      	movs	r3, #0
 800187e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  tp = chThdStartI(tp);
  chSysUnlock();

  return tp;
}
 8001882:	bd08      	pop	{r3, pc}
	...

08001890 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001890:	b510      	push	{r4, lr}
 8001892:	2320      	movs	r3, #32
 8001894:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 8001898:	4b08      	ldr	r3, [pc, #32]	; (80018bc <chThdSetPriority+0x2c>)
 800189a:	699b      	ldr	r3, [r3, #24]
 800189c:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 800189e:	6899      	ldr	r1, [r3, #8]
 80018a0:	428c      	cmp	r4, r1
 80018a2:	d001      	beq.n	80018a8 <chThdSetPriority+0x18>
 80018a4:	4281      	cmp	r1, r0
 80018a6:	d200      	bcs.n	80018aa <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
 80018a8:	6098      	str	r0, [r3, #8]
  }
  currp->p_realprio = newprio;
 80018aa:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 80018ac:	f7ff ff40 	bl	8001730 <chSchRescheduleS>
 80018b0:	2300      	movs	r3, #0
 80018b2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 80018b6:	4620      	mov	r0, r4
 80018b8:	bd10      	pop	{r4, pc}
 80018ba:	bf00      	nop
 80018bc:	20000e78 	.word	0x20000e78

080018c0 <chThdTerminate>:
 80018c0:	2320      	movs	r3, #32
 80018c2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 80018c6:	7f43      	ldrb	r3, [r0, #29]
 80018c8:	f043 0304 	orr.w	r3, r3, #4
 80018cc:	7743      	strb	r3, [r0, #29]
 80018ce:	2300      	movs	r3, #0
 80018d0:	f383 8811 	msr	BASEPRI, r3
 80018d4:	4770      	bx	lr
 80018d6:	bf00      	nop
	...

080018e0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80018e0:	b508      	push	{r3, lr}
 80018e2:	4601      	mov	r1, r0
 80018e4:	2320      	movs	r3, #32
 80018e6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80018ea:	2008      	movs	r0, #8
 80018ec:	f7ff fe78 	bl	80015e0 <chSchGoSleepTimeoutS>
 80018f0:	2300      	movs	r3, #0
 80018f2:	f383 8811 	msr	BASEPRI, r3
 80018f6:	bd08      	pop	{r3, pc}
	...

08001900 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8001900:	b508      	push	{r3, lr}
 8001902:	2320      	movs	r3, #32
 8001904:	f383 8811 	msr	BASEPRI, r3
 8001908:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800190c:	6a59      	ldr	r1, [r3, #36]	; 0x24

  chSysLock();
  time -= chVTGetSystemTimeX();
  if (time > (systime_t)0) {
 800190e:	1a41      	subs	r1, r0, r1
 8001910:	d002      	beq.n	8001918 <chThdSleepUntil+0x18>
 8001912:	2008      	movs	r0, #8
 8001914:	f7ff fe64 	bl	80015e0 <chSchGoSleepTimeoutS>
 8001918:	2300      	movs	r3, #0
 800191a:	f383 8811 	msr	BASEPRI, r3
 800191e:	bd08      	pop	{r3, pc}

08001920 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001920:	b508      	push	{r3, lr}
 8001922:	2320      	movs	r3, #32
 8001924:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8001928:	4b06      	ldr	r3, [pc, #24]	; (8001944 <chThdYield+0x24>)
 800192a:	681a      	ldr	r2, [r3, #0]
 800192c:	699b      	ldr	r3, [r3, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800192e:	6892      	ldr	r2, [r2, #8]
 8001930:	689b      	ldr	r3, [r3, #8]
 8001932:	429a      	cmp	r2, r3
 8001934:	d301      	bcc.n	800193a <chThdYield+0x1a>
    chSchDoRescheduleBehind();
 8001936:	f7ff febb 	bl	80016b0 <chSchDoRescheduleBehind>
 800193a:	2300      	movs	r3, #0
 800193c:	f383 8811 	msr	BASEPRI, r3
 8001940:	bd08      	pop	{r3, pc}
 8001942:	bf00      	nop
 8001944:	20000e78 	.word	0x20000e78
	...

08001950 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001950:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8001952:	4b0e      	ldr	r3, [pc, #56]	; (800198c <chThdExitS+0x3c>)
 8001954:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001956:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8001958:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800195a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 800195e:	429d      	cmp	r5, r3
 8001960:	d007      	beq.n	8001972 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001962:	681a      	ldr	r2, [r3, #0]
 8001964:	6262      	str	r2, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001966:	4618      	mov	r0, r3
 8001968:	f7ff fe0a 	bl	8001580 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800196c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800196e:	42ab      	cmp	r3, r5
 8001970:	d1f7      	bne.n	8001962 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001972:	7f63      	ldrb	r3, [r4, #29]
 8001974:	079b      	lsls	r3, r3, #30
 8001976:	d104      	bne.n	8001982 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8001978:	6963      	ldr	r3, [r4, #20]
 800197a:	6922      	ldr	r2, [r4, #16]
 800197c:	611a      	str	r2, [r3, #16]
 800197e:	6922      	ldr	r2, [r4, #16]
 8001980:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001982:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001984:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001988:	f7ff be12 	b.w	80015b0 <chSchGoSleepS>
 800198c:	20000e78 	.word	0x20000e78

08001990 <chThdExit>:
 8001990:	2320      	movs	r3, #32
 8001992:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001996:	f7ff bfdb 	b.w	8001950 <chThdExitS>
 800199a:	bf00      	nop
 800199c:	0000      	movs	r0, r0
	...

080019a0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 80019a0:	b538      	push	{r3, r4, r5, lr}
 80019a2:	4604      	mov	r4, r0
 80019a4:	2320      	movs	r3, #32
 80019a6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 80019aa:	7f03      	ldrb	r3, [r0, #28]
 80019ac:	2b0f      	cmp	r3, #15
 80019ae:	d007      	beq.n	80019c0 <chThdWait+0x20>
    list_insert(currp, &tp->p_waiting);
 80019b0:	4b08      	ldr	r3, [pc, #32]	; (80019d4 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 80019b2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80019b4:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 80019b6:	2009      	movs	r0, #9
 80019b8:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 80019ba:	6263      	str	r3, [r4, #36]	; 0x24
 80019bc:	f7ff fdf8 	bl	80015b0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 80019c0:	6a25      	ldr	r5, [r4, #32]
 80019c2:	2300      	movs	r3, #0
 80019c4:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 80019c8:	4620      	mov	r0, r4
 80019ca:	f000 f8c9 	bl	8001b60 <chThdRelease>
#endif

  return msg;
}
 80019ce:	4628      	mov	r0, r5
 80019d0:	bd38      	pop	{r3, r4, r5, pc}
 80019d2:	bf00      	nop
 80019d4:	20000e78 	.word	0x20000e78
	...

080019e0 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 80019e0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80019e2:	4c05      	ldr	r4, [pc, #20]	; (80019f8 <chThdSuspendS+0x18>)
 80019e4:	69a3      	ldr	r3, [r4, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 80019e6:	6003      	str	r3, [r0, #0]
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 80019e8:	4602      	mov	r2, r0
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 80019ea:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80019ec:	2003      	movs	r0, #3
 80019ee:	f7ff fddf 	bl	80015b0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 80019f2:	69a3      	ldr	r3, [r4, #24]
}
 80019f4:	6a18      	ldr	r0, [r3, #32]
 80019f6:	bd10      	pop	{r4, pc}
 80019f8:	20000e78 	.word	0x20000e78
 80019fc:	00000000 	.word	0x00000000

08001a00 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001a00:	6803      	ldr	r3, [r0, #0]
 8001a02:	b12b      	cbz	r3, 8001a10 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001a04:	2200      	movs	r2, #0
 8001a06:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001a08:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001a0a:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 8001a0c:	f7ff bdb8 	b.w	8001580 <chSchReadyI>
 8001a10:	4770      	bx	lr
 8001a12:	bf00      	nop
	...

08001a20 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8001a20:	b161      	cbz	r1, 8001a3c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001a22:	4b08      	ldr	r3, [pc, #32]	; (8001a44 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001a24:	b410      	push	{r4}
 8001a26:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001a28:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001a2a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001a2c:	2004      	movs	r0, #4
 8001a2e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8001a32:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8001a34:	6053      	str	r3, [r2, #4]
}
 8001a36:	bc10      	pop	{r4}
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001a38:	f7ff bdd2 	b.w	80015e0 <chSchGoSleepTimeoutS>
}
 8001a3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001a40:	4770      	bx	lr
 8001a42:	bf00      	nop
 8001a44:	20000e78 	.word	0x20000e78
	...

08001a50 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001a50:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8001a52:	4290      	cmp	r0, r2
 8001a54:	d009      	beq.n	8001a6a <chThdDequeueNextI+0x1a>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001a56:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001a58:	6814      	ldr	r4, [r2, #0]
 8001a5a:	6004      	str	r4, [r0, #0]
 8001a5c:	4603      	mov	r3, r0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a5e:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001a60:	6211      	str	r1, [r2, #32]
  (void) chSchReadyI(tp);
 8001a62:	4610      	mov	r0, r2

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001a64:	bc10      	pop	{r4}
 8001a66:	f7ff bd8b 	b.w	8001580 <chSchReadyI>
 8001a6a:	4770      	bx	lr
 8001a6c:	0000      	movs	r0, r0
	...

08001a70 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001a70:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001a72:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8001a74:	4298      	cmp	r0, r3
 8001a76:	d00b      	beq.n	8001a90 <chThdDequeueAllI+0x20>
 8001a78:	4604      	mov	r4, r0
 8001a7a:	460d      	mov	r5, r1
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001a7c:	681a      	ldr	r2, [r3, #0]
 8001a7e:	6022      	str	r2, [r4, #0]
 8001a80:	4618      	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a82:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001a84:	621d      	str	r5, [r3, #32]
  (void) chSchReadyI(tp);
 8001a86:	f7ff fd7b 	bl	8001580 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001a8a:	6823      	ldr	r3, [r4, #0]
 8001a8c:	429c      	cmp	r4, r3
 8001a8e:	d1f5      	bne.n	8001a7c <chThdDequeueAllI+0xc>
 8001a90:	bd38      	pop	{r3, r4, r5, pc}
 8001a92:	bf00      	nop
	...

08001aa0 <chTMStartMeasurementX>:
 8001aa0:	4b01      	ldr	r3, [pc, #4]	; (8001aa8 <chTMStartMeasurementX+0x8>)
 8001aa2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001aa4:	6083      	str	r3, [r0, #8]
 8001aa6:	4770      	bx	lr
 8001aa8:	e0001000 	.word	0xe0001000
 8001aac:	00000000 	.word	0x00000000

08001ab0 <chTMStopMeasurementX>:
 8001ab0:	4b0f      	ldr	r3, [pc, #60]	; (8001af0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001ab2:	4910      	ldr	r1, [pc, #64]	; (8001af4 <chTMStopMeasurementX+0x44>)
 8001ab4:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001ab6:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001ab8:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001aba:	6f4f      	ldr	r7, [r1, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001abc:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8001abe:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001ac0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001ac4:	1ad3      	subs	r3, r2, r3
 8001ac6:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8001ac8:	18e4      	adds	r4, r4, r3
 8001aca:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001ace:	3601      	adds	r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8001ad0:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001ad2:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8001ad4:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001ad6:	e9c0 4504 	strd	r4, r5, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8001ada:	d805      	bhi.n	8001ae8 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 8001adc:	6802      	ldr	r2, [r0, #0]
 8001ade:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8001ae0:	bf38      	it	cc
 8001ae2:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001ae4:	bcf0      	pop	{r4, r5, r6, r7}
 8001ae6:	4770      	bx	lr
  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8001ae8:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001aea:	bcf0      	pop	{r4, r5, r6, r7}
 8001aec:	4770      	bx	lr
 8001aee:	bf00      	nop
 8001af0:	e0001000 	.word	0xe0001000
 8001af4:	20000e78 	.word	0x20000e78
	...

08001b00 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001b00:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001b02:	4c0c      	ldr	r4, [pc, #48]	; (8001b34 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001b04:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001b06:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001b08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001b0c:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001b0e:	2600      	movs	r6, #0
 8001b10:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001b12:	6763      	str	r3, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8001b14:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8001b16:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8001b18:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001b1a:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001b1c:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001b20:	f7ff ffbe 	bl	8001aa0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8001b24:	4668      	mov	r0, sp
 8001b26:	f7ff ffc3 	bl	8001ab0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001b2a:	9b02      	ldr	r3, [sp, #8]
 8001b2c:	6763      	str	r3, [r4, #116]	; 0x74
}
 8001b2e:	b006      	add	sp, #24
 8001b30:	bdd0      	pop	{r4, r6, r7, pc}
 8001b32:	bf00      	nop
 8001b34:	20000e78 	.word	0x20000e78
	...

08001b40 <chThdAddRef>:
 8001b40:	2320      	movs	r3, #32
 8001b42:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chThdAddRef(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 8001b46:	7f83      	ldrb	r3, [r0, #30]
 8001b48:	3301      	adds	r3, #1
 8001b4a:	7783      	strb	r3, [r0, #30]
 8001b4c:	2300      	movs	r3, #0
 8001b4e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8001b52:	4770      	bx	lr
	...

08001b60 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001b60:	4601      	mov	r1, r0
 8001b62:	2320      	movs	r3, #32
 8001b64:	f383 8811 	msr	BASEPRI, r3
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 8001b68:	7f83      	ldrb	r3, [r0, #30]
 8001b6a:	3b01      	subs	r3, #1
 8001b6c:	b2db      	uxtb	r3, r3
 8001b6e:	7783      	strb	r3, [r0, #30]
 8001b70:	2200      	movs	r2, #0
 8001b72:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8001b76:	b913      	cbnz	r3, 8001b7e <chThdRelease+0x1e>
 8001b78:	7f03      	ldrb	r3, [r0, #28]
 8001b7a:	2b0f      	cmp	r3, #15
 8001b7c:	d000      	beq.n	8001b80 <chThdRelease+0x20>
 8001b7e:	4770      	bx	lr
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8001b80:	7f43      	ldrb	r3, [r0, #29]
 8001b82:	f003 0303 	and.w	r3, r3, #3
 8001b86:	2b01      	cmp	r3, #1
 8001b88:	d002      	beq.n	8001b90 <chThdRelease+0x30>
 8001b8a:	2b02      	cmp	r3, #2
 8001b8c:	d007      	beq.n	8001b9e <chThdRelease+0x3e>
 8001b8e:	4770      	bx	lr
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001b90:	6943      	ldr	r3, [r0, #20]
 8001b92:	6902      	ldr	r2, [r0, #16]
 8001b94:	611a      	str	r2, [r3, #16]
 8001b96:	6902      	ldr	r2, [r0, #16]
 8001b98:	6153      	str	r3, [r2, #20]
#endif
      chHeapFree(tp);
 8001b9a:	f001 b879 	b.w	8002c90 <chHeapFree>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001b9e:	6943      	ldr	r3, [r0, #20]
 8001ba0:	6902      	ldr	r2, [r0, #16]
 8001ba2:	611a      	str	r2, [r3, #16]
 8001ba4:	6902      	ldr	r2, [r0, #16]
#endif
      chPoolFree(tp->p_mpool, tp);
 8001ba6:	6c00      	ldr	r0, [r0, #64]	; 0x40
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001ba8:	6153      	str	r3, [r2, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
 8001baa:	f001 b921 	b.w	8002df0 <chPoolFree>
 8001bae:	bf00      	nop

08001bb0 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001bb2:	b083      	sub	sp, #12
 8001bb4:	4616      	mov	r6, r2
 8001bb6:	461f      	mov	r7, r3
 8001bb8:	460d      	mov	r5, r1
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 8001bba:	f001 f821 	bl	8002c00 <chHeapAlloc>
  if (wsp == NULL) {
 8001bbe:	b198      	cbz	r0, 8001be8 <chThdCreateFromHeap+0x38>
 8001bc0:	2320      	movs	r3, #32
 8001bc2:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001bc6:	9b08      	ldr	r3, [sp, #32]
 8001bc8:	9300      	str	r3, [sp, #0]
 8001bca:	4632      	mov	r2, r6
 8001bcc:	463b      	mov	r3, r7
 8001bce:	4629      	mov	r1, r5
 8001bd0:	f7ff fde6 	bl	80017a0 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8001bd4:	2301      	movs	r3, #1
 8001bd6:	7743      	strb	r3, [r0, #29]
  chSchWakeupS(tp, MSG_OK);
 8001bd8:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001bda:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8001bdc:	f7ff fd28 	bl	8001630 <chSchWakeupS>
 8001be0:	2300      	movs	r3, #0
 8001be2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 8001be6:	4620      	mov	r0, r4
}
 8001be8:	b003      	add	sp, #12
 8001bea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001bec:	0000      	movs	r0, r0
	...

08001bf0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 8001bf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001bf4:	b082      	sub	sp, #8
 8001bf6:	460e      	mov	r6, r1
 8001bf8:	4617      	mov	r7, r2
 8001bfa:	4698      	mov	r8, r3
 8001bfc:	4605      	mov	r5, r0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8001bfe:	f001 f8df 	bl	8002dc0 <chPoolAlloc>
  if (wsp == NULL) {
 8001c02:	b1a0      	cbz	r0, 8001c2e <chThdCreateFromMemoryPool+0x3e>
 8001c04:	2320      	movs	r3, #32
 8001c06:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 8001c0a:	6869      	ldr	r1, [r5, #4]
 8001c0c:	f8cd 8000 	str.w	r8, [sp]
 8001c10:	463b      	mov	r3, r7
 8001c12:	4632      	mov	r2, r6
 8001c14:	f7ff fdc4 	bl	80017a0 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 8001c18:	2302      	movs	r3, #2
 8001c1a:	7743      	strb	r3, [r0, #29]
  tp->p_mpool = mp;
 8001c1c:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 8001c1e:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 8001c20:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_MPOOL;
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8001c22:	f7ff fd05 	bl	8001630 <chSchWakeupS>
 8001c26:	2300      	movs	r3, #0
 8001c28:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 8001c2c:	4620      	mov	r0, r4
}
 8001c2e:	b002      	add	sp, #8
 8001c30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08001c40 <chRegFirstThread>:
 8001c40:	2320      	movs	r3, #32
 8001c42:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8001c46:	4b04      	ldr	r3, [pc, #16]	; (8001c58 <chRegFirstThread+0x18>)
 8001c48:	6918      	ldr	r0, [r3, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 8001c4a:	7f83      	ldrb	r3, [r0, #30]
 8001c4c:	3301      	adds	r3, #1
 8001c4e:	7783      	strb	r3, [r0, #30]
 8001c50:	2300      	movs	r3, #0
 8001c52:	f383 8811 	msr	BASEPRI, r3
#endif
  chSysUnlock();

  return tp;
}
 8001c56:	4770      	bx	lr
 8001c58:	20000e78 	.word	0x20000e78
 8001c5c:	00000000 	.word	0x00000000

08001c60 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001c60:	b510      	push	{r4, lr}
 8001c62:	2320      	movs	r3, #32
 8001c64:	f383 8811 	msr	BASEPRI, r3
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001c68:	4b07      	ldr	r3, [pc, #28]	; (8001c88 <chRegNextThread+0x28>)
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 8001c6a:	6904      	ldr	r4, [r0, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001c6c:	429c      	cmp	r4, r3
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 8001c6e:	bf1d      	ittte	ne
 8001c70:	7fa3      	ldrbne	r3, [r4, #30]
 8001c72:	3301      	addne	r3, #1
 8001c74:	77a3      	strbne	r3, [r4, #30]
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8001c76:	2400      	moveq	r4, #0
 8001c78:	2300      	movs	r3, #0
 8001c7a:	f383 8811 	msr	BASEPRI, r3
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8001c7e:	f7ff ff6f 	bl	8001b60 <chThdRelease>
#endif

  return ntp;
}
 8001c82:	4620      	mov	r0, r4
 8001c84:	bd10      	pop	{r4, pc}
 8001c86:	bf00      	nop
 8001c88:	20000e78 	.word	0x20000e78
 8001c8c:	00000000 	.word	0x00000000

08001c90 <chSemObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001c90:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001c92:	6040      	str	r0, [r0, #4]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8001c94:	6081      	str	r1, [r0, #8]
 8001c96:	4770      	bx	lr
	...

08001ca0 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001ca0:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001ca2:	6885      	ldr	r5, [r0, #8]
  sp->s_cnt = n;
 8001ca4:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8001ca6:	3501      	adds	r5, #1
 8001ca8:	2d00      	cmp	r5, #0
 8001caa:	dc0c      	bgt.n	8001cc6 <chSemResetI+0x26>
 8001cac:	4604      	mov	r4, r0
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001cae:	f06f 0601 	mvn.w	r6, #1

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8001cb2:	6860      	ldr	r0, [r4, #4]

  tqp->p_prev = tp->p_prev;
 8001cb4:	6843      	ldr	r3, [r0, #4]
 8001cb6:	6063      	str	r3, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8001cb8:	601c      	str	r4, [r3, #0]
 8001cba:	f7ff fc61 	bl	8001580 <chSchReadyI>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001cbe:	3501      	adds	r5, #1
 8001cc0:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001cc2:	6206      	str	r6, [r0, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001cc4:	d1f5      	bne.n	8001cb2 <chSemResetI+0x12>
 8001cc6:	bd70      	pop	{r4, r5, r6, pc}
	...

08001cd0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001cd0:	b508      	push	{r3, lr}
 8001cd2:	2320      	movs	r3, #32
 8001cd4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSemResetI(sp, n);
 8001cd8:	f7ff ffe2 	bl	8001ca0 <chSemResetI>
  chSchRescheduleS();
 8001cdc:	f7ff fd28 	bl	8001730 <chSchRescheduleS>
 8001ce0:	2300      	movs	r3, #0
 8001ce2:	f383 8811 	msr	BASEPRI, r3
 8001ce6:	bd08      	pop	{r3, pc}
	...

08001cf0 <chSemWait>:
 8001cf0:	2320      	movs	r3, #32
 8001cf2:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001cf6:	6883      	ldr	r3, [r0, #8]
 8001cf8:	3b01      	subs	r3, #1
 8001cfa:	2b00      	cmp	r3, #0
 8001cfc:	6083      	str	r3, [r0, #8]
 8001cfe:	db04      	blt.n	8001d0a <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 8001d00:	2000      	movs	r0, #0
 8001d02:	2300      	movs	r3, #0
 8001d04:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8001d08:	4770      	bx	lr
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001d0a:	b510      	push	{r4, lr}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 8001d0c:	4c08      	ldr	r4, [pc, #32]	; (8001d30 <chSemWait+0x40>)
 8001d0e:	69a2      	ldr	r2, [r4, #24]
 8001d10:	6210      	str	r0, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001d12:	6841      	ldr	r1, [r0, #4]
 8001d14:	6051      	str	r1, [r2, #4]
 8001d16:	4603      	mov	r3, r0
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8001d18:	6010      	str	r0, [r2, #0]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
 8001d1a:	600a      	str	r2, [r1, #0]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8001d1c:	2005      	movs	r0, #5
  tqp->p_prev = tp;
 8001d1e:	605a      	str	r2, [r3, #4]
 8001d20:	f7ff fc46 	bl	80015b0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001d24:	69a3      	ldr	r3, [r4, #24]
 8001d26:	6a18      	ldr	r0, [r3, #32]
 8001d28:	2300      	movs	r3, #0
 8001d2a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8001d2e:	bd10      	pop	{r4, pc}
 8001d30:	20000e78 	.word	0x20000e78
	...

08001d40 <chSemWaitTimeout>:
 8001d40:	2320      	movs	r3, #32
 8001d42:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001d46:	6882      	ldr	r2, [r0, #8]
 8001d48:	1e53      	subs	r3, r2, #1
 8001d4a:	2b00      	cmp	r3, #0
 8001d4c:	6083      	str	r3, [r0, #8]
 8001d4e:	db04      	blt.n	8001d5a <chSemWaitTimeout+0x1a>
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 8001d50:	2000      	movs	r0, #0
 8001d52:	2300      	movs	r3, #0
 8001d54:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
  chSysUnlock();

  return msg;
}
 8001d58:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001d5a:	b510      	push	{r4, lr}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8001d5c:	b179      	cbz	r1, 8001d7e <chSemWaitTimeout+0x3e>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8001d5e:	4a0a      	ldr	r2, [pc, #40]	; (8001d88 <chSemWaitTimeout+0x48>)
 8001d60:	6992      	ldr	r2, [r2, #24]
 8001d62:	6210      	str	r0, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001d64:	6844      	ldr	r4, [r0, #4]
 8001d66:	4603      	mov	r3, r0
 8001d68:	e882 0018 	stmia.w	r2, {r3, r4}
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001d6c:	2005      	movs	r0, #5
  tp->p_prev->p_next = tp;
 8001d6e:	6022      	str	r2, [r4, #0]
  tqp->p_prev = tp;
 8001d70:	605a      	str	r2, [r3, #4]
 8001d72:	f7ff fc35 	bl	80015e0 <chSchGoSleepTimeoutS>
 8001d76:	2300      	movs	r3, #0
 8001d78:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
  chSysUnlock();

  return msg;
}
 8001d7c:	bd10      	pop	{r4, pc}
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 8001d7e:	6082      	str	r2, [r0, #8]

      return MSG_TIMEOUT;
 8001d80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001d84:	e7f7      	b.n	8001d76 <chSemWaitTimeout+0x36>
 8001d86:	bf00      	nop
 8001d88:	20000e78 	.word	0x20000e78
 8001d8c:	00000000 	.word	0x00000000

08001d90 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001d90:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001d92:	6880      	ldr	r0, [r0, #8]
 8001d94:	1e42      	subs	r2, r0, #1
 8001d96:	2a00      	cmp	r2, #0
 8001d98:	609a      	str	r2, [r3, #8]
 8001d9a:	db01      	blt.n	8001da0 <chSemWaitTimeoutS+0x10>
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 8001d9c:	2000      	movs	r0, #0
 8001d9e:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001da0:	b410      	push	{r4}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8001da2:	b159      	cbz	r1, 8001dbc <chSemWaitTimeoutS+0x2c>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8001da4:	4a08      	ldr	r2, [pc, #32]	; (8001dc8 <chSemWaitTimeoutS+0x38>)
 8001da6:	6992      	ldr	r2, [r2, #24]
 8001da8:	6213      	str	r3, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001daa:	685c      	ldr	r4, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001dac:	2005      	movs	r0, #5
 8001dae:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->p_prev->p_next = tp;
 8001db2:	6022      	str	r2, [r4, #0]
  tqp->p_prev = tp;
 8001db4:	605a      	str	r2, [r3, #4]
  }

  return MSG_OK;
}
 8001db6:	bc10      	pop	{r4}
      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001db8:	f7ff bc12 	b.w	80015e0 <chSchGoSleepTimeoutS>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 8001dbc:	6098      	str	r0, [r3, #8]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001dbe:	bc10      	pop	{r4}

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
 8001dc0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001dc4:	4770      	bx	lr
 8001dc6:	bf00      	nop
 8001dc8:	20000e78 	.word	0x20000e78
 8001dcc:	00000000 	.word	0x00000000

08001dd0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001dd0:	b508      	push	{r3, lr}
 8001dd2:	2320      	movs	r3, #32
 8001dd4:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
 8001dd8:	6883      	ldr	r3, [r0, #8]
 8001dda:	3301      	adds	r3, #1
 8001ddc:	2b00      	cmp	r3, #0
 8001dde:	6083      	str	r3, [r0, #8]
 8001de0:	dd03      	ble.n	8001dea <chSemSignal+0x1a>
 8001de2:	2300      	movs	r3, #0
 8001de4:	f383 8811 	msr	BASEPRI, r3
 8001de8:	bd08      	pop	{r3, pc}
 8001dea:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001dec:	6800      	ldr	r0, [r0, #0]

  tqp->p_next = tp->p_next;
 8001dee:	6802      	ldr	r2, [r0, #0]
 8001df0:	601a      	str	r2, [r3, #0]
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8001df2:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001df4:	6053      	str	r3, [r2, #4]
 8001df6:	f7ff fc1b 	bl	8001630 <chSchWakeupS>
 8001dfa:	2300      	movs	r3, #0
 8001dfc:	f383 8811 	msr	BASEPRI, r3
 8001e00:	bd08      	pop	{r3, pc}
 8001e02:	bf00      	nop
	...

08001e10 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001e10:	6883      	ldr	r3, [r0, #8]
 8001e12:	3301      	adds	r3, #1
 8001e14:	2b00      	cmp	r3, #0
 8001e16:	6083      	str	r3, [r0, #8]
 8001e18:	dd00      	ble.n	8001e1c <chSemSignalI+0xc>
 8001e1a:	4770      	bx	lr
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001e1c:	6803      	ldr	r3, [r0, #0]

  tqp->p_next = tp->p_next;
 8001e1e:	681a      	ldr	r2, [r3, #0]
 8001e20:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001e22:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e24:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 8001e26:	4618      	mov	r0, r3

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001e28:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 8001e2a:	f7ff bba9 	b.w	8001580 <chSchReadyI>
 8001e2e:	bf00      	nop

08001e30 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001e30:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001e32:	1e0c      	subs	r4, r1, #0
 8001e34:	dd12      	ble.n	8001e5c <chSemAddCounterI+0x2c>
 8001e36:	4605      	mov	r5, r0
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001e38:	2600      	movs	r6, #0
 8001e3a:	e001      	b.n	8001e40 <chSemAddCounterI+0x10>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001e3c:	3c01      	subs	r4, #1
 8001e3e:	d00d      	beq.n	8001e5c <chSemAddCounterI+0x2c>
    if (++sp->s_cnt <= (cnt_t)0) {
 8001e40:	68ab      	ldr	r3, [r5, #8]
 8001e42:	3301      	adds	r3, #1
 8001e44:	2b00      	cmp	r3, #0
 8001e46:	60ab      	str	r3, [r5, #8]
 8001e48:	dcf8      	bgt.n	8001e3c <chSemAddCounterI+0xc>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001e4a:	6828      	ldr	r0, [r5, #0]

  tqp->p_next = tp->p_next;
 8001e4c:	6803      	ldr	r3, [r0, #0]
 8001e4e:	602b      	str	r3, [r5, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e50:	605d      	str	r5, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001e52:	f7ff fb95 	bl	8001580 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001e56:	3c01      	subs	r4, #1
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001e58:	6206      	str	r6, [r0, #32]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001e5a:	d1f1      	bne.n	8001e40 <chSemAddCounterI+0x10>
 8001e5c:	bd70      	pop	{r4, r5, r6, pc}
 8001e5e:	bf00      	nop

08001e60 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001e60:	b510      	push	{r4, lr}
 8001e62:	2320      	movs	r3, #32
 8001e64:	b082      	sub	sp, #8
 8001e66:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
 8001e6a:	6883      	ldr	r3, [r0, #8]
 8001e6c:	3301      	adds	r3, #1
 8001e6e:	2b00      	cmp	r3, #0
 8001e70:	6083      	str	r3, [r0, #8]
 8001e72:	dd1d      	ble.n	8001eb0 <chSemSignalWait+0x50>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8001e74:	688b      	ldr	r3, [r1, #8]
 8001e76:	3b01      	subs	r3, #1
 8001e78:	2b00      	cmp	r3, #0
 8001e7a:	608b      	str	r3, [r1, #8]
 8001e7c:	db07      	blt.n	8001e8e <chSemSignalWait+0x2e>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8001e7e:	f7ff fc57 	bl	8001730 <chSchRescheduleS>
    msg = MSG_OK;
 8001e82:	2000      	movs	r0, #0
 8001e84:	2300      	movs	r3, #0
 8001e86:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 8001e8a:	b002      	add	sp, #8
 8001e8c:	bd10      	pop	{r4, pc}
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8001e8e:	4a0e      	ldr	r2, [pc, #56]	; (8001ec8 <chSemSignalWait+0x68>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001e90:	684b      	ldr	r3, [r1, #4]
 8001e92:	6994      	ldr	r4, [r2, #24]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8001e94:	2005      	movs	r0, #5
 8001e96:	e884 000a 	stmia.w	r4, {r1, r3}
  tp->p_prev->p_next = tp;
 8001e9a:	601c      	str	r4, [r3, #0]
  tqp->p_prev = tp;
 8001e9c:	604c      	str	r4, [r1, #4]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
 8001e9e:	6221      	str	r1, [r4, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8001ea0:	f7ff fb86 	bl	80015b0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8001ea4:	6a20      	ldr	r0, [r4, #32]
 8001ea6:	2300      	movs	r3, #0
 8001ea8:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 8001eac:	b002      	add	sp, #8
 8001eae:	bd10      	pop	{r4, pc}
 8001eb0:	4602      	mov	r2, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001eb2:	6800      	ldr	r0, [r0, #0]
 8001eb4:	9101      	str	r1, [sp, #4]

  tqp->p_next = tp->p_next;
 8001eb6:	6803      	ldr	r3, [r0, #0]
 8001eb8:	6013      	str	r3, [r2, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001eba:	605a      	str	r2, [r3, #4]
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8001ebc:	f7ff fb60 	bl	8001580 <chSchReadyI>
 8001ec0:	2300      	movs	r3, #0
 8001ec2:	6203      	str	r3, [r0, #32]
 8001ec4:	9901      	ldr	r1, [sp, #4]
 8001ec6:	e7d5      	b.n	8001e74 <chSemSignalWait+0x14>
 8001ec8:	20000e78 	.word	0x20000e78
 8001ecc:	00000000 	.word	0x00000000

08001ed0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8001ed0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001ed2:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001ed4:	6040      	str	r0, [r0, #4]
 8001ed6:	6083      	str	r3, [r0, #8]
 8001ed8:	4770      	bx	lr
 8001eda:	bf00      	nop
 8001edc:	0000      	movs	r0, r0
	...

08001ee0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8001ee0:	4b30      	ldr	r3, [pc, #192]	; (8001fa4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001ee2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001ee4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001ee6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001ee8:	2a00      	cmp	r2, #0
 8001eea:	d055      	beq.n	8001f98 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001eec:	68a1      	ldr	r1, [r4, #8]
 8001eee:	6893      	ldr	r3, [r2, #8]
 8001ef0:	428b      	cmp	r3, r1
 8001ef2:	4605      	mov	r5, r0
 8001ef4:	d206      	bcs.n	8001f04 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001ef6:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001ef8:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001efa:	2b06      	cmp	r3, #6
 8001efc:	d033      	beq.n	8001f66 <chMtxLockS+0x86>
 8001efe:	2b07      	cmp	r3, #7
 8001f00:	d01d      	beq.n	8001f3e <chMtxLockS+0x5e>
 8001f02:	b19b      	cbz	r3, 8001f2c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001f04:	462b      	mov	r3, r5
 8001f06:	e003      	b.n	8001f10 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001f08:	6899      	ldr	r1, [r3, #8]
 8001f0a:	68a2      	ldr	r2, [r4, #8]
 8001f0c:	4291      	cmp	r1, r2
 8001f0e:	d302      	bcc.n	8001f16 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001f10:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001f12:	429d      	cmp	r5, r3
 8001f14:	d1f8      	bne.n	8001f08 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001f16:	685a      	ldr	r2, [r3, #4]
 8001f18:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001f1a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001f1c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8001f1e:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8001f20:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001f22:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8001f24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001f28:	f7ff bb42 	b.w	80015b0 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001f2c:	e892 000a 	ldmia.w	r2, {r1, r3}
 8001f30:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001f32:	6811      	ldr	r1, [r2, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001f34:	4610      	mov	r0, r2
 8001f36:	604b      	str	r3, [r1, #4]
 8001f38:	f7ff fb22 	bl	8001580 <chSchReadyI>
          break;
 8001f3c:	e7e2      	b.n	8001f04 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001f3e:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001f42:	6018      	str	r0, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001f44:	6810      	ldr	r0, [r2, #0]
 8001f46:	6043      	str	r3, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f48:	6a16      	ldr	r6, [r2, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001f4a:	4633      	mov	r3, r6
 8001f4c:	e002      	b.n	8001f54 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001f4e:	6898      	ldr	r0, [r3, #8]
 8001f50:	4288      	cmp	r0, r1
 8001f52:	d302      	bcc.n	8001f5a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001f54:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001f56:	429e      	cmp	r6, r3
 8001f58:	d1f9      	bne.n	8001f4e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001f5a:	6859      	ldr	r1, [r3, #4]
 8001f5c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001f5e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001f60:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8001f62:	605a      	str	r2, [r3, #4]
 8001f64:	e7ce      	b.n	8001f04 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001f66:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001f6a:	6018      	str	r0, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001f6c:	6810      	ldr	r0, [r2, #0]
 8001f6e:	6043      	str	r3, [r0, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f70:	6a16      	ldr	r6, [r2, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001f72:	4633      	mov	r3, r6
 8001f74:	e002      	b.n	8001f7c <chMtxLockS+0x9c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001f76:	6898      	ldr	r0, [r3, #8]
 8001f78:	4288      	cmp	r0, r1
 8001f7a:	d302      	bcc.n	8001f82 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001f7c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001f7e:	429e      	cmp	r6, r3
 8001f80:	d1f9      	bne.n	8001f76 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001f82:	6859      	ldr	r1, [r3, #4]
 8001f84:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001f86:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001f88:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8001f8a:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 8001f8c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001f8e:	68a1      	ldr	r1, [r4, #8]
 8001f90:	6893      	ldr	r3, [r2, #8]
 8001f92:	428b      	cmp	r3, r1
 8001f94:	d3af      	bcc.n	8001ef6 <chMtxLockS+0x16>
 8001f96:	e7b5      	b.n	8001f04 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8001f98:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f9a:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001f9c:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 8001f9e:	63a0      	str	r0, [r4, #56]	; 0x38
 8001fa0:	bd70      	pop	{r4, r5, r6, pc}
 8001fa2:	bf00      	nop
 8001fa4:	20000e78 	.word	0x20000e78
	...

08001fb0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001fb0:	b508      	push	{r3, lr}
 8001fb2:	2320      	movs	r3, #32
 8001fb4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 8001fb8:	f7ff ff92 	bl	8001ee0 <chMtxLockS>
 8001fbc:	2300      	movs	r3, #0
 8001fbe:	f383 8811 	msr	BASEPRI, r3
 8001fc2:	bd08      	pop	{r3, pc}
	...

08001fd0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8001fd0:	4603      	mov	r3, r0
 8001fd2:	2220      	movs	r2, #32
 8001fd4:	f382 8811 	msr	BASEPRI, r2
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8001fd8:	6882      	ldr	r2, [r0, #8]
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 8001fda:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8001fdc:	b11a      	cbz	r2, 8001fe6 <chMtxTryLock+0x16>
 8001fde:	2300      	movs	r3, #0
 8001fe0:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8001fe4:	4770      	bx	lr

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8001fe6:	4a05      	ldr	r2, [pc, #20]	; (8001ffc <chMtxTryLock+0x2c>)
 8001fe8:	6992      	ldr	r2, [r2, #24]
 8001fea:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8001fec:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8001fee:	60d9      	str	r1, [r3, #12]
  currp->p_mtxlist = mp;
 8001ff0:	2001      	movs	r0, #1
 8001ff2:	6393      	str	r3, [r2, #56]	; 0x38
 8001ff4:	2300      	movs	r3, #0
 8001ff6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8001ffa:	4770      	bx	lr
 8001ffc:	20000e78 	.word	0x20000e78

08002000 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8002000:	4b16      	ldr	r3, [pc, #88]	; (800205c <chMtxUnlock+0x5c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002002:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002004:	699d      	ldr	r5, [r3, #24]
 8002006:	2320      	movs	r3, #32
 8002008:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800200c:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800200e:	68c3      	ldr	r3, [r0, #12]
 8002010:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002012:	4284      	cmp	r4, r0
 8002014:	d01c      	beq.n	8002050 <chMtxUnlock+0x50>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002016:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002018:	b14b      	cbz	r3, 800202e <chMtxUnlock+0x2e>
 800201a:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800201c:	4293      	cmp	r3, r2
 800201e:	d003      	beq.n	8002028 <chMtxUnlock+0x28>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8002020:	6892      	ldr	r2, [r2, #8]
 8002022:	4291      	cmp	r1, r2
 8002024:	bf38      	it	cc
 8002026:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8002028:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800202a:	2b00      	cmp	r3, #0
 800202c:	d1f5      	bne.n	800201a <chMtxUnlock+0x1a>
 800202e:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002030:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8002032:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8002034:	60a9      	str	r1, [r5, #8]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchWakeupS(tp, MSG_OK);
 8002036:	4620      	mov	r0, r4
 8002038:	601a      	str	r2, [r3, #0]
 800203a:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 800203c:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 800203e:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8002040:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 8002042:	63a3      	str	r3, [r4, #56]	; 0x38
      chSchWakeupS(tp, MSG_OK);
 8002044:	f7ff faf4 	bl	8001630 <chSchWakeupS>
 8002048:	2300      	movs	r3, #0
 800204a:	f383 8811 	msr	BASEPRI, r3
 800204e:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 8002050:	2300      	movs	r3, #0
 8002052:	60a3      	str	r3, [r4, #8]
 8002054:	2300      	movs	r3, #0
 8002056:	f383 8811 	msr	BASEPRI, r3
 800205a:	bd70      	pop	{r4, r5, r6, pc}
 800205c:	20000e78 	.word	0x20000e78

08002060 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8002060:	4b12      	ldr	r3, [pc, #72]	; (80020ac <chMtxUnlockS+0x4c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002062:	b430      	push	{r4, r5}
 8002064:	4604      	mov	r4, r0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002066:	6805      	ldr	r5, [r0, #0]
  thread_t *ctp = currp;
 8002068:	6998      	ldr	r0, [r3, #24]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800206a:	68e3      	ldr	r3, [r4, #12]
 800206c:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800206e:	42a5      	cmp	r5, r4
 8002070:	d017      	beq.n	80020a2 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002072:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002074:	b14b      	cbz	r3, 800208a <chMtxUnlockS+0x2a>
 8002076:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002078:	4293      	cmp	r3, r2
 800207a:	d003      	beq.n	8002084 <chMtxUnlockS+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800207c:	6892      	ldr	r2, [r2, #8]
 800207e:	4291      	cmp	r1, r2
 8002080:	bf38      	it	cc
 8002082:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8002084:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002086:	2b00      	cmp	r3, #0
 8002088:	d1f5      	bne.n	8002076 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800208a:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 800208c:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800208e:	6081      	str	r1, [r0, #8]
 8002090:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 8002092:	4628      	mov	r0, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002094:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8002096:	60a5      	str	r5, [r4, #8]
      mp->m_next = tp->p_mtxlist;
 8002098:	60e2      	str	r2, [r4, #12]
      tp->p_mtxlist = mp;
 800209a:	63ac      	str	r4, [r5, #56]	; 0x38
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800209c:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 800209e:	f7ff ba6f 	b.w	8001580 <chSchReadyI>
    }
    else {
      mp->m_owner = NULL;
 80020a2:	2300      	movs	r3, #0
 80020a4:	60ab      	str	r3, [r5, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 80020a6:	bc30      	pop	{r4, r5}
 80020a8:	4770      	bx	lr
 80020aa:	bf00      	nop
 80020ac:	20000e78 	.word	0x20000e78

080020b0 <chMtxUnlockAll>:
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 80020b0:	4a13      	ldr	r2, [pc, #76]	; (8002100 <chMtxUnlockAll+0x50>)
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80020b2:	b570      	push	{r4, r5, r6, lr}
 80020b4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 80020b6:	6994      	ldr	r4, [r2, #24]
 80020b8:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 80020bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80020be:	b1d3      	cbz	r3, 80020f6 <chMtxUnlockAll+0x46>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 80020c0:	2600      	movs	r6, #0
 80020c2:	e00a      	b.n	80020da <chMtxUnlockAll+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80020c4:	6811      	ldr	r1, [r2, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 80020c6:	6b95      	ldr	r5, [r2, #56]	; 0x38
 80020c8:	6019      	str	r1, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80020ca:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 80020cc:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 80020ce:	60dd      	str	r5, [r3, #12]
        tp->p_mtxlist = mp;
 80020d0:	6393      	str	r3, [r2, #56]	; 0x38
        (void) chSchReadyI(tp);
 80020d2:	f7ff fa55 	bl	8001580 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 80020d6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80020d8:	b14b      	cbz	r3, 80020ee <chMtxUnlockAll+0x3e>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80020da:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 80020dc:	68d9      	ldr	r1, [r3, #12]
 80020de:	63a1      	str	r1, [r4, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80020e0:	4293      	cmp	r3, r2
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
        tp->p_mtxlist = mp;
        (void) chSchReadyI(tp);
 80020e2:	4610      	mov	r0, r2
  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
      if (chMtxQueueNotEmptyS(mp)) {
 80020e4:	d1ee      	bne.n	80020c4 <chMtxUnlockAll+0x14>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 80020e6:	609e      	str	r6, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 80020e8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80020ea:	2b00      	cmp	r3, #0
 80020ec:	d1f5      	bne.n	80020da <chMtxUnlockAll+0x2a>
    ctp->p_prio = ctp->p_realprio;
 80020ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80020f0:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 80020f2:	f7ff fb1d 	bl	8001730 <chSchRescheduleS>
 80020f6:	2300      	movs	r3, #0
 80020f8:	f383 8811 	msr	BASEPRI, r3
 80020fc:	bd70      	pop	{r4, r5, r6, pc}
 80020fe:	bf00      	nop
 8002100:	20000e78 	.word	0x20000e78
	...

08002110 <chCondObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002110:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002112:	6040      	str	r0, [r0, #4]
 8002114:	4770      	bx	lr
 8002116:	bf00      	nop
	...

08002120 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002120:	b508      	push	{r3, lr}
 8002122:	2320      	movs	r3, #32
 8002124:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002128:	6802      	ldr	r2, [r0, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 800212a:	4290      	cmp	r0, r2
 800212c:	d007      	beq.n	800213e <chCondSignal+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800212e:	6811      	ldr	r1, [r2, #0]
 8002130:	6001      	str	r1, [r0, #0]
 8002132:	4603      	mov	r3, r0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002134:	604b      	str	r3, [r1, #4]
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8002136:	4610      	mov	r0, r2
 8002138:	2100      	movs	r1, #0
 800213a:	f7ff fa79 	bl	8001630 <chSchWakeupS>
 800213e:	2300      	movs	r3, #0
 8002140:	f383 8811 	msr	BASEPRI, r3
 8002144:	bd08      	pop	{r3, pc}
 8002146:	bf00      	nop
	...

08002150 <chCondSignalI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002150:	6803      	ldr	r3, [r0, #0]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 8002152:	4298      	cmp	r0, r3
 8002154:	d007      	beq.n	8002166 <chCondSignalI+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002156:	681a      	ldr	r2, [r3, #0]
 8002158:	6002      	str	r2, [r0, #0]
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 800215a:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 800215c:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 800215e:	4618      	mov	r0, r3
  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 8002160:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 8002162:	f7ff ba0d 	b.w	8001580 <chSchReadyI>
 8002166:	4770      	bx	lr
	...

08002170 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 8002170:	b538      	push	{r3, r4, r5, lr}
 8002172:	4604      	mov	r4, r0
 8002174:	2320      	movs	r3, #32
 8002176:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800217a:	6800      	ldr	r0, [r0, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 800217c:	4284      	cmp	r4, r0
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 800217e:	bf18      	it	ne
 8002180:	f06f 0501 	mvnne.w	r5, #1
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002184:	d008      	beq.n	8002198 <chCondBroadcast+0x28>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002186:	6803      	ldr	r3, [r0, #0]
 8002188:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800218a:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 800218c:	f7ff f9f8 	bl	8001580 <chSchReadyI>
 8002190:	6205      	str	r5, [r0, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002192:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002194:	42a0      	cmp	r0, r4
 8002196:	d1f6      	bne.n	8002186 <chCondBroadcast+0x16>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8002198:	f7ff faca 	bl	8001730 <chSchRescheduleS>
 800219c:	2300      	movs	r3, #0
 800219e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 80021a2:	bd38      	pop	{r3, r4, r5, pc}
	...

080021b0 <chCondWaitS>:
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 80021b0:	4b0f      	ldr	r3, [pc, #60]	; (80021f0 <chCondWaitS+0x40>)
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 80021b2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80021b4:	699c      	ldr	r4, [r3, #24]
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
 80021b6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 80021b8:	4605      	mov	r5, r0
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 80021ba:	4630      	mov	r0, r6
 80021bc:	f7ff ff50 	bl	8002060 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 80021c0:	6225      	str	r5, [r4, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80021c2:	462b      	mov	r3, r5
 80021c4:	e003      	b.n	80021ce <chCondWaitS+0x1e>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80021c6:	6899      	ldr	r1, [r3, #8]
 80021c8:	68a2      	ldr	r2, [r4, #8]
 80021ca:	4291      	cmp	r1, r2
 80021cc:	d302      	bcc.n	80021d4 <chCondWaitS+0x24>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 80021ce:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80021d0:	429d      	cmp	r5, r3
 80021d2:	d1f8      	bne.n	80021c6 <chCondWaitS+0x16>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80021d4:	685a      	ldr	r2, [r3, #4]
 80021d6:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80021d8:	6023      	str	r3, [r4, #0]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 80021da:	2007      	movs	r0, #7
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80021dc:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80021de:	605c      	str	r4, [r3, #4]
 80021e0:	f7ff f9e6 	bl	80015b0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 80021e4:	6a24      	ldr	r4, [r4, #32]
  chMtxLockS(mp);
 80021e6:	4630      	mov	r0, r6
 80021e8:	f7ff fe7a 	bl	8001ee0 <chMtxLockS>

  return msg;
}
 80021ec:	4620      	mov	r0, r4
 80021ee:	bd70      	pop	{r4, r5, r6, pc}
 80021f0:	20000e78 	.word	0x20000e78
	...

08002200 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002200:	b508      	push	{r3, lr}
 8002202:	2320      	movs	r3, #32
 8002204:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
 8002208:	f7ff ffd2 	bl	80021b0 <chCondWaitS>
 800220c:	2300      	movs	r3, #0
 800220e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  return msg;
}
 8002212:	bd08      	pop	{r3, pc}
	...

08002220 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 8002220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002222:	4c12      	ldr	r4, [pc, #72]	; (800226c <chCondWaitTimeoutS+0x4c>)
 8002224:	69a3      	ldr	r3, [r4, #24]
 8002226:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 8002228:	4605      	mov	r5, r0
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 800222a:	4630      	mov	r0, r6
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 800222c:	460f      	mov	r7, r1
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 800222e:	f7ff ff17 	bl	8002060 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8002232:	69a4      	ldr	r4, [r4, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002234:	462b      	mov	r3, r5
 8002236:	6225      	str	r5, [r4, #32]
 8002238:	e003      	b.n	8002242 <chCondWaitTimeoutS+0x22>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800223a:	6898      	ldr	r0, [r3, #8]
 800223c:	68a2      	ldr	r2, [r4, #8]
 800223e:	4290      	cmp	r0, r2
 8002240:	d302      	bcc.n	8002248 <chCondWaitTimeoutS+0x28>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8002242:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002244:	429d      	cmp	r5, r3
 8002246:	d1f8      	bne.n	800223a <chCondWaitTimeoutS+0x1a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8002248:	685a      	ldr	r2, [r3, #4]
 800224a:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800224c:	6023      	str	r3, [r4, #0]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800224e:	4639      	mov	r1, r7
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8002250:	6014      	str	r4, [r2, #0]
 8002252:	2007      	movs	r0, #7
  cp->p_prev = tp;
 8002254:	605c      	str	r4, [r3, #4]
 8002256:	f7ff f9c3 	bl	80015e0 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 800225a:	1c43      	adds	r3, r0, #1

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800225c:	4604      	mov	r4, r0
  if (msg != MSG_TIMEOUT) {
 800225e:	d002      	beq.n	8002266 <chCondWaitTimeoutS+0x46>
    chMtxLockS(mp);
 8002260:	4630      	mov	r0, r6
 8002262:	f7ff fe3d 	bl	8001ee0 <chMtxLockS>
  }

  return msg;
}
 8002266:	4620      	mov	r0, r4
 8002268:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800226a:	bf00      	nop
 800226c:	20000e78 	.word	0x20000e78

08002270 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 8002270:	b508      	push	{r3, lr}
 8002272:	2320      	movs	r3, #32
 8002274:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chCondWaitTimeoutS(cp, time);
 8002278:	f7ff ffd2 	bl	8002220 <chCondWaitTimeoutS>
 800227c:	2300      	movs	r3, #0
 800227e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8002282:	bd08      	pop	{r3, pc}
	...

08002290 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8002290:	b430      	push	{r4, r5}
 8002292:	2420      	movs	r4, #32
 8002294:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8002298:	4d06      	ldr	r5, [pc, #24]	; (80022b4 <chEvtRegisterMaskWithFlags+0x24>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800229a:	6804      	ldr	r4, [r0, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 800229c:	69ad      	ldr	r5, [r5, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800229e:	600c      	str	r4, [r1, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80022a0:	2400      	movs	r4, #0

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 80022a2:	6001      	str	r1, [r0, #0]
  elp->el_listener = currp;
 80022a4:	604d      	str	r5, [r1, #4]
  elp->el_events   = events;
 80022a6:	608a      	str	r2, [r1, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80022a8:	610b      	str	r3, [r1, #16]
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80022aa:	60cc      	str	r4, [r1, #12]
 80022ac:	f384 8811 	msr	BASEPRI, r4
  elp->el_wflags   = wflags;
  chSysUnlock();
}
 80022b0:	bc30      	pop	{r4, r5}
 80022b2:	4770      	bx	lr
 80022b4:	20000e78 	.word	0x20000e78
	...

080022c0 <chEvtUnregister>:
 80022c0:	2320      	movs	r3, #32
 80022c2:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80022c6:	4602      	mov	r2, r0
 80022c8:	e002      	b.n	80022d0 <chEvtUnregister+0x10>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 80022ca:	428b      	cmp	r3, r1
 80022cc:	d007      	beq.n	80022de <chEvtUnregister+0x1e>
 80022ce:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80022d0:	6813      	ldr	r3, [r2, #0]
 80022d2:	4298      	cmp	r0, r3
 80022d4:	d1f9      	bne.n	80022ca <chEvtUnregister+0xa>
 80022d6:	2300      	movs	r3, #0
 80022d8:	f383 8811 	msr	BASEPRI, r3
 80022dc:	4770      	bx	lr
  /*lint -restore*/
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 80022de:	680b      	ldr	r3, [r1, #0]
 80022e0:	6013      	str	r3, [r2, #0]
 80022e2:	2300      	movs	r3, #0
 80022e4:	f383 8811 	msr	BASEPRI, r3
 80022e8:	4770      	bx	lr
 80022ea:	bf00      	nop
 80022ec:	0000      	movs	r0, r0
	...

080022f0 <chEvtGetAndClearEvents>:
 80022f0:	2320      	movs	r3, #32
 80022f2:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 80022f6:	4b05      	ldr	r3, [pc, #20]	; (800230c <chEvtGetAndClearEvents+0x1c>)
 80022f8:	699a      	ldr	r2, [r3, #24]
 80022fa:	6b53      	ldr	r3, [r2, #52]	; 0x34
  currp->p_epending &= ~events;
 80022fc:	ea23 0100 	bic.w	r1, r3, r0
 8002300:	6351      	str	r1, [r2, #52]	; 0x34
 8002302:	2200      	movs	r2, #0
 8002304:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  return m;
}
 8002308:	4018      	ands	r0, r3
 800230a:	4770      	bx	lr
 800230c:	20000e78 	.word	0x20000e78

08002310 <chEvtAddEvents>:
 8002310:	2320      	movs	r3, #32
 8002312:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->p_epending |= events;
 8002316:	4b04      	ldr	r3, [pc, #16]	; (8002328 <chEvtAddEvents+0x18>)
 8002318:	699a      	ldr	r2, [r3, #24]
 800231a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800231c:	4318      	orrs	r0, r3
 800231e:	6350      	str	r0, [r2, #52]	; 0x34
 8002320:	2300      	movs	r3, #0
 8002322:	f383 8811 	msr	BASEPRI, r3
  events = currp->p_epending;
  chSysUnlock();

  return events;
}
 8002326:	4770      	bx	lr
 8002328:	20000e78 	.word	0x20000e78
 800232c:	00000000 	.word	0x00000000

08002330 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002330:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002332:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002334:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002336:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002338:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800233a:	d009      	beq.n	8002350 <chEvtSignalI+0x20>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800233c:	2a0b      	cmp	r2, #11
 800233e:	d000      	beq.n	8002342 <chEvtSignalI+0x12>
 8002340:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002342:	6a03      	ldr	r3, [r0, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002344:	438b      	bics	r3, r1
 8002346:	d1fb      	bne.n	8002340 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002348:	2300      	movs	r3, #0
 800234a:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 800234c:	f7ff b918 	b.w	8001580 <chSchReadyI>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002350:	6a03      	ldr	r3, [r0, #32]
 8002352:	4219      	tst	r1, r3
 8002354:	d1f8      	bne.n	8002348 <chEvtSignalI+0x18>
 8002356:	4770      	bx	lr
	...

08002360 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002360:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8002362:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002364:	42a0      	cmp	r0, r4
 8002366:	d00f      	beq.n	8002388 <chEvtBroadcastFlagsI+0x28>
 8002368:	4606      	mov	r6, r0
 800236a:	460d      	mov	r5, r1
  /*lint -restore*/
    elp->el_flags |= flags;
 800236c:	68e3      	ldr	r3, [r4, #12]
 800236e:	432b      	orrs	r3, r5
 8002370:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8002372:	b115      	cbz	r5, 800237a <chEvtBroadcastFlagsI+0x1a>
 8002374:	6922      	ldr	r2, [r4, #16]
 8002376:	4213      	tst	r3, r2
 8002378:	d003      	beq.n	8002382 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 800237a:	68a1      	ldr	r1, [r4, #8]
 800237c:	6860      	ldr	r0, [r4, #4]
 800237e:	f7ff ffd7 	bl	8002330 <chEvtSignalI>
    }
    elp = elp->el_next;
 8002382:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002384:	42a6      	cmp	r6, r4
 8002386:	d1f1      	bne.n	800236c <chEvtBroadcastFlagsI+0xc>
 8002388:	bd70      	pop	{r4, r5, r6, pc}
 800238a:	bf00      	nop
 800238c:	0000      	movs	r0, r0
	...

08002390 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002390:	b508      	push	{r3, lr}
 8002392:	2320      	movs	r3, #32
 8002394:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8002398:	f7ff ffca 	bl	8002330 <chEvtSignalI>
  chSchRescheduleS();
 800239c:	f7ff f9c8 	bl	8001730 <chSchRescheduleS>
 80023a0:	2300      	movs	r3, #0
 80023a2:	f383 8811 	msr	BASEPRI, r3
 80023a6:	bd08      	pop	{r3, pc}
	...

080023b0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 80023b0:	b508      	push	{r3, lr}
 80023b2:	2320      	movs	r3, #32
 80023b4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80023b8:	f7ff ffd2 	bl	8002360 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80023bc:	f7ff f9b8 	bl	8001730 <chSchRescheduleS>
 80023c0:	2300      	movs	r3, #0
 80023c2:	f383 8811 	msr	BASEPRI, r3
 80023c6:	bd08      	pop	{r3, pc}
	...

080023d0 <chEvtDispatch>:
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 80023d0:	b1c9      	cbz	r1, 8002406 <chEvtDispatch+0x36>
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80023d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80023d4:	4606      	mov	r6, r0
 80023d6:	460d      	mov	r5, r1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 80023d8:	2400      	movs	r4, #0
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 80023da:	2701      	movs	r7, #1

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80023dc:	fa25 f304 	lsr.w	r3, r5, r4
 80023e0:	07db      	lsls	r3, r3, #31
 80023e2:	d404      	bmi.n	80023ee <chEvtDispatch+0x1e>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 80023e4:	3401      	adds	r4, #1

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80023e6:	fa25 f304 	lsr.w	r3, r5, r4
 80023ea:	07db      	lsls	r3, r3, #31
 80023ec:	d5fa      	bpl.n	80023e4 <chEvtDispatch+0x14>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 80023ee:	fa07 f304 	lsl.w	r3, r7, r4
      handlers[eid](eid);
 80023f2:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 80023f4:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
 80023f8:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 80023fc:	4798      	blx	r3
    }
    eid++;
 80023fe:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002400:	2d00      	cmp	r5, #0
 8002402:	d1eb      	bne.n	80023dc <chEvtDispatch+0xc>
 8002404:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002406:	4770      	bx	lr
	...

08002410 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002410:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002412:	4b0d      	ldr	r3, [pc, #52]	; (8002448 <chEvtWaitOne+0x38>)
 8002414:	699d      	ldr	r5, [r3, #24]
 8002416:	2320      	movs	r3, #32
 8002418:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800241c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800241e:	ea13 0400 	ands.w	r4, r3, r0
 8002422:	d106      	bne.n	8002432 <chEvtWaitOne+0x22>
 8002424:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 8002426:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002428:	200a      	movs	r0, #10
 800242a:	f7ff f8c1 	bl	80015b0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800242e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002430:	401c      	ands	r4, r3
  }
  m ^= m & (m - (eventmask_t)1);
 8002432:	4262      	negs	r2, r4
 8002434:	ea04 0002 	and.w	r0, r4, r2
  ctp->p_epending &= ~m;
 8002438:	ea23 0300 	bic.w	r3, r3, r0
 800243c:	636b      	str	r3, [r5, #52]	; 0x34
 800243e:	2300      	movs	r3, #0
 8002440:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002444:	bd38      	pop	{r3, r4, r5, pc}
 8002446:	bf00      	nop
 8002448:	20000e78 	.word	0x20000e78
 800244c:	00000000 	.word	0x00000000

08002450 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8002450:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002452:	4b0c      	ldr	r3, [pc, #48]	; (8002484 <chEvtWaitAny+0x34>)
 8002454:	699d      	ldr	r5, [r3, #24]
 8002456:	2320      	movs	r3, #32
 8002458:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800245c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800245e:	ea13 0400 	ands.w	r4, r3, r0
 8002462:	d106      	bne.n	8002472 <chEvtWaitAny+0x22>
 8002464:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 8002466:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002468:	200a      	movs	r0, #10
 800246a:	f7ff f8a1 	bl	80015b0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800246e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002470:	401c      	ands	r4, r3
  }
  ctp->p_epending &= ~m;
 8002472:	ea23 0304 	bic.w	r3, r3, r4
 8002476:	636b      	str	r3, [r5, #52]	; 0x34
 8002478:	2300      	movs	r3, #0
 800247a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 800247e:	4620      	mov	r0, r4
 8002480:	bd38      	pop	{r3, r4, r5, pc}
 8002482:	bf00      	nop
 8002484:	20000e78 	.word	0x20000e78
	...

08002490 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002490:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002492:	4b0b      	ldr	r3, [pc, #44]	; (80024c0 <chEvtWaitAll+0x30>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002494:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8002496:	699d      	ldr	r5, [r3, #24]
 8002498:	2320      	movs	r3, #32
 800249a:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 800249e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80024a0:	ea30 0203 	bics.w	r2, r0, r3
 80024a4:	d004      	beq.n	80024b0 <chEvtWaitAll+0x20>
    ctp->p_u.ewmask = events;
 80024a6:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80024a8:	200b      	movs	r0, #11
 80024aa:	f7ff f881 	bl	80015b0 <chSchGoSleepS>
 80024ae:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->p_epending &= ~events;
 80024b0:	ea23 0304 	bic.w	r3, r3, r4
 80024b4:	636b      	str	r3, [r5, #52]	; 0x34
 80024b6:	2300      	movs	r3, #0
 80024b8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 80024bc:	4620      	mov	r0, r4
 80024be:	bd38      	pop	{r3, r4, r5, pc}
 80024c0:	20000e78 	.word	0x20000e78
	...

080024d0 <chEvtWaitOneTimeout>:
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80024d0:	4b12      	ldr	r3, [pc, #72]	; (800251c <chEvtWaitOneTimeout+0x4c>)
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 80024d2:	b570      	push	{r4, r5, r6, lr}
 80024d4:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 80024d6:	699d      	ldr	r5, [r3, #24]
 80024d8:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80024dc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80024de:	ea12 0600 	ands.w	r6, r2, r0
 80024e2:	d10e      	bne.n	8002502 <chEvtWaitOneTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 80024e4:	b919      	cbnz	r1, 80024ee <chEvtWaitOneTimeout+0x1e>
 80024e6:	f381 8811 	msr	BASEPRI, r1
      chSysUnlock();
      return (eventmask_t)0;
 80024ea:	4608      	mov	r0, r1
 80024ec:	bd70      	pop	{r4, r5, r6, pc}
    }
    ctp->p_u.ewmask = events;
 80024ee:	6228      	str	r0, [r5, #32]
 80024f0:	4604      	mov	r4, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80024f2:	200a      	movs	r0, #10
 80024f4:	f7ff f874 	bl	80015e0 <chSchGoSleepTimeoutS>
 80024f8:	2800      	cmp	r0, #0
 80024fa:	db0b      	blt.n	8002514 <chEvtWaitOneTimeout+0x44>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 80024fc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80024fe:	ea04 0602 	and.w	r6, r4, r2
  }
  m ^= m & (m - (eventmask_t)1);
 8002502:	4270      	negs	r0, r6
 8002504:	4030      	ands	r0, r6
  ctp->p_epending &= ~m;
 8002506:	ea22 0200 	bic.w	r2, r2, r0
 800250a:	636a      	str	r2, [r5, #52]	; 0x34
 800250c:	2300      	movs	r3, #0
 800250e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002512:	bd70      	pop	{r4, r5, r6, pc}
 8002514:	f386 8811 	msr	BASEPRI, r6
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8002518:	4630      	mov	r0, r6
 800251a:	bd70      	pop	{r4, r5, r6, pc}
 800251c:	20000e78 	.word	0x20000e78

08002520 <chEvtWaitAnyTimeout>:
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002520:	4b12      	ldr	r3, [pc, #72]	; (800256c <chEvtWaitAnyTimeout+0x4c>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8002522:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002524:	699e      	ldr	r6, [r3, #24]
 8002526:	2320      	movs	r3, #32
 8002528:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800252c:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800252e:	ea13 0400 	ands.w	r4, r3, r0
 8002532:	d10e      	bne.n	8002552 <chEvtWaitAnyTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 8002534:	b919      	cbnz	r1, 800253e <chEvtWaitAnyTimeout+0x1e>
 8002536:	f381 8811 	msr	BASEPRI, r1
      chSysUnlock();
      return (eventmask_t)0;
 800253a:	4608      	mov	r0, r1
 800253c:	bd70      	pop	{r4, r5, r6, pc}
    }
    ctp->p_u.ewmask = events;
 800253e:	6230      	str	r0, [r6, #32]
 8002540:	4605      	mov	r5, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002542:	200a      	movs	r0, #10
 8002544:	f7ff f84c 	bl	80015e0 <chSchGoSleepTimeoutS>
 8002548:	2800      	cmp	r0, #0
 800254a:	db0a      	blt.n	8002562 <chEvtWaitAnyTimeout+0x42>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800254c:	6b73      	ldr	r3, [r6, #52]	; 0x34
 800254e:	ea05 0403 	and.w	r4, r5, r3
  }
  ctp->p_epending &= ~m;
 8002552:	ea23 0304 	bic.w	r3, r3, r4
 8002556:	6373      	str	r3, [r6, #52]	; 0x34
 8002558:	2300      	movs	r3, #0
 800255a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
 800255e:	4620      	mov	r0, r4
}
 8002560:	bd70      	pop	{r4, r5, r6, pc}
 8002562:	f384 8811 	msr	BASEPRI, r4
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8002566:	4620      	mov	r0, r4
 8002568:	bd70      	pop	{r4, r5, r6, pc}
 800256a:	bf00      	nop
 800256c:	20000e78 	.word	0x20000e78

08002570 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002570:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002572:	4b10      	ldr	r3, [pc, #64]	; (80025b4 <chEvtWaitAllTimeout+0x44>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002574:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8002576:	699d      	ldr	r5, [r3, #24]
 8002578:	2320      	movs	r3, #32
 800257a:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 800257e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002580:	ea30 0203 	bics.w	r2, r0, r3
 8002584:	d00b      	beq.n	800259e <chEvtWaitAllTimeout+0x2e>
 8002586:	4608      	mov	r0, r1
    if (TIME_IMMEDIATE == time) {
 8002588:	b911      	cbnz	r1, 8002590 <chEvtWaitAllTimeout+0x20>
 800258a:	f380 8811 	msr	BASEPRI, r0
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 800258e:	bd38      	pop	{r3, r4, r5, pc}
  if ((ctp->p_epending & events) != events) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8002590:	622c      	str	r4, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002592:	200b      	movs	r0, #11
 8002594:	f7ff f824 	bl	80015e0 <chSchGoSleepTimeoutS>
 8002598:	2800      	cmp	r0, #0
 800259a:	db08      	blt.n	80025ae <chEvtWaitAllTimeout+0x3e>
 800259c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 800259e:	ea23 0304 	bic.w	r3, r3, r4
 80025a2:	636b      	str	r3, [r5, #52]	; 0x34
 80025a4:	2300      	movs	r3, #0
 80025a6:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
 80025aa:	4620      	mov	r0, r4
}
 80025ac:	bd38      	pop	{r3, r4, r5, pc}
 80025ae:	2000      	movs	r0, #0
 80025b0:	e7eb      	b.n	800258a <chEvtWaitAllTimeout+0x1a>
 80025b2:	bf00      	nop
 80025b4:	20000e78 	.word	0x20000e78
	...

080025c0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80025c0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80025c2:	4b0e      	ldr	r3, [pc, #56]	; (80025fc <chMsgSend+0x3c>)
 80025c4:	2220      	movs	r2, #32
 80025c6:	699c      	ldr	r4, [r3, #24]
 80025c8:	f382 8811 	msr	BASEPRI, r2

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 80025cc:	f100 0528 	add.w	r5, r0, #40	; 0x28
 80025d0:	6225      	str	r5, [r4, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80025d2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80025d4:	6062      	str	r2, [r4, #4]
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 80025d6:	6321      	str	r1, [r4, #48]	; 0x30
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80025d8:	6025      	str	r5, [r4, #0]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
 80025da:	6014      	str	r4, [r2, #0]
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 80025dc:	7f02      	ldrb	r2, [r0, #28]
  tqp->p_prev = tp;
 80025de:	62c4      	str	r4, [r0, #44]	; 0x2c
 80025e0:	2a0e      	cmp	r2, #14
 80025e2:	d007      	beq.n	80025f4 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 80025e4:	200c      	movs	r0, #12
 80025e6:	f7fe ffe3 	bl	80015b0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 80025ea:	6a20      	ldr	r0, [r4, #32]
 80025ec:	2300      	movs	r3, #0
 80025ee:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 80025f2:	bd38      	pop	{r3, r4, r5, pc}
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 80025f4:	f7fe ffc4 	bl	8001580 <chSchReadyI>
 80025f8:	e7f4      	b.n	80025e4 <chMsgSend+0x24>
 80025fa:	bf00      	nop
 80025fc:	20000e78 	.word	0x20000e78

08002600 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002600:	b510      	push	{r4, lr}
 8002602:	2320      	movs	r3, #32
 8002604:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8002608:	4c0b      	ldr	r4, [pc, #44]	; (8002638 <chMsgWait+0x38>)
 800260a:	69a2      	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 800260c:	4613      	mov	r3, r2
 800260e:	f853 0f28 	ldr.w	r0, [r3, #40]!
 8002612:	4298      	cmp	r0, r3
 8002614:	d008      	beq.n	8002628 <chMsgWait+0x28>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002616:	6801      	ldr	r1, [r0, #0]
 8002618:	6291      	str	r1, [r2, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 800261a:	220d      	movs	r2, #13
  tqp->p_next->p_prev = (thread_t *)tqp;
 800261c:	604b      	str	r3, [r1, #4]
 800261e:	2300      	movs	r3, #0
 8002620:	7702      	strb	r2, [r0, #28]
 8002622:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8002626:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8002628:	200e      	movs	r0, #14
 800262a:	f7fe ffc1 	bl	80015b0 <chSchGoSleepS>
 800262e:	69a2      	ldr	r2, [r4, #24]
 8002630:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002632:	f102 0328 	add.w	r3, r2, #40	; 0x28
 8002636:	e7ee      	b.n	8002616 <chMsgWait+0x16>
 8002638:	20000e78 	.word	0x20000e78
 800263c:	00000000 	.word	0x00000000

08002640 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002640:	b508      	push	{r3, lr}
 8002642:	2320      	movs	r3, #32
 8002644:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002648:	f7fe fff2 	bl	8001630 <chSchWakeupS>
 800264c:	2300      	movs	r3, #0
 800264e:	f383 8811 	msr	BASEPRI, r3
 8002652:	bd08      	pop	{r3, pc}
	...

08002660 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8002660:	b510      	push	{r4, lr}
 8002662:	460b      	mov	r3, r1
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
 8002664:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8002668:	6041      	str	r1, [r0, #4]
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 800266a:	4604      	mov	r4, r0

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 800266c:	6003      	str	r3, [r0, #0]
  mbp->mb_rdptr = buf;
 800266e:	60c3      	str	r3, [r0, #12]
  mbp->mb_wrptr = buf;
 8002670:	6083      	str	r3, [r0, #8]
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
 8002672:	4611      	mov	r1, r2
 8002674:	301c      	adds	r0, #28
 8002676:	f7ff fb0b 	bl	8001c90 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 800267a:	f104 0010 	add.w	r0, r4, #16
 800267e:	2100      	movs	r1, #0
}
 8002680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  mbp->mb_buffer = buf;
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 8002684:	f7ff bb04 	b.w	8001c90 <chSemObjectInit>
	...

08002690 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8002690:	b510      	push	{r4, lr}
 8002692:	4604      	mov	r4, r0
  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8002694:	301c      	adds	r0, #28
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8002696:	6823      	ldr	r3, [r4, #0]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8002698:	6861      	ldr	r1, [r4, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 800269a:	60a3      	str	r3, [r4, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 800269c:	1ac9      	subs	r1, r1, r3

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
 800269e:	60e3      	str	r3, [r4, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 80026a0:	1089      	asrs	r1, r1, #2
 80026a2:	f7ff fafd 	bl	8001ca0 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 80026a6:	f104 0010 	add.w	r0, r4, #16
 80026aa:	2100      	movs	r1, #0
}
 80026ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 80026b0:	f7ff baf6 	b.w	8001ca0 <chSemResetI>
	...

080026c0 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 80026c0:	b508      	push	{r3, lr}
 80026c2:	2320      	movs	r3, #32
 80026c4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMBResetI(mbp);
 80026c8:	f7ff ffe2 	bl	8002690 <chMBResetI>
  chSchRescheduleS();
 80026cc:	f7ff f830 	bl	8001730 <chSchRescheduleS>
 80026d0:	2300      	movs	r3, #0
 80026d2:	f383 8811 	msr	BASEPRI, r3
 80026d6:	bd08      	pop	{r3, pc}
	...

080026e0 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80026e0:	b570      	push	{r4, r5, r6, lr}
 80026e2:	2320      	movs	r3, #32
 80026e4:	4604      	mov	r4, r0
 80026e6:	460e      	mov	r6, r1
 80026e8:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80026ec:	4611      	mov	r1, r2
 80026ee:	301c      	adds	r0, #28
 80026f0:	f7ff fb4e 	bl	8001d90 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 80026f4:	4605      	mov	r5, r0
 80026f6:	b978      	cbnz	r0, 8002718 <chMBPost+0x38>
    *mbp->mb_wrptr++ = msg;
 80026f8:	68a2      	ldr	r2, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 80026fa:	6861      	ldr	r1, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 80026fc:	1d13      	adds	r3, r2, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
 80026fe:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8002700:	60a3      	str	r3, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 8002702:	bf28      	it	cs
 8002704:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8002706:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002708:	f104 0010 	add.w	r0, r4, #16

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 800270c:	bf28      	it	cs
 800270e:	60a3      	strcs	r3, [r4, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002710:	f7ff fb7e 	bl	8001e10 <chSemSignalI>
    chSchRescheduleS();
 8002714:	f7ff f80c 	bl	8001730 <chSchRescheduleS>
 8002718:	2300      	movs	r3, #0
 800271a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 800271e:	4628      	mov	r0, r5
 8002720:	bd70      	pop	{r4, r5, r6, pc}
 8002722:	bf00      	nop
	...

08002730 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002730:	b538      	push	{r3, r4, r5, lr}
 8002732:	6a43      	ldr	r3, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002734:	2b00      	cmp	r3, #0
 8002736:	dd12      	ble.n	800275e <chMBPostI+0x2e>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8002738:	6884      	ldr	r4, [r0, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 800273a:	6845      	ldr	r5, [r0, #4]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800273c:	1d22      	adds	r2, r4, #4
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 800273e:	3b01      	subs	r3, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002740:	42aa      	cmp	r2, r5
 8002742:	6243      	str	r3, [r0, #36]	; 0x24
     mbp->mb_wrptr = mbp->mb_buffer;
 8002744:	bf28      	it	cs
 8002746:	6803      	ldrcs	r3, [r0, #0]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8002748:	6082      	str	r2, [r0, #8]
 800274a:	6021      	str	r1, [r4, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 800274c:	f100 0010 	add.w	r0, r0, #16
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 8002750:	bf28      	it	cs
 8002752:	f840 3c08 	strcs.w	r3, [r0, #-8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8002756:	f7ff fb5b 	bl	8001e10 <chSemSignalI>

  return MSG_OK;
 800275a:	2000      	movs	r0, #0
 800275c:	bd38      	pop	{r3, r4, r5, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 800275e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);

  return MSG_OK;
}
 8002762:	bd38      	pop	{r3, r4, r5, pc}
	...

08002770 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002770:	b570      	push	{r4, r5, r6, lr}
 8002772:	2320      	movs	r3, #32
 8002774:	4604      	mov	r4, r0
 8002776:	460e      	mov	r6, r1
 8002778:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800277c:	4611      	mov	r1, r2
 800277e:	301c      	adds	r0, #28
 8002780:	f7ff fb06 	bl	8001d90 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8002784:	4605      	mov	r5, r0
 8002786:	b120      	cbz	r0, 8002792 <chMBPostAhead+0x22>
 8002788:	2300      	movs	r3, #0
 800278a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 800278e:	4628      	mov	r0, r5
 8002790:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002792:	68e3      	ldr	r3, [r4, #12]
 8002794:	6822      	ldr	r2, [r4, #0]
 8002796:	3b04      	subs	r3, #4
 8002798:	4293      	cmp	r3, r2
 800279a:	60e3      	str	r3, [r4, #12]
 800279c:	d202      	bcs.n	80027a4 <chMBPostAhead+0x34>
      mbp->mb_rdptr = mbp->mb_top - 1;
 800279e:	6863      	ldr	r3, [r4, #4]
 80027a0:	3b04      	subs	r3, #4
 80027a2:	60e3      	str	r3, [r4, #12]
    }
    *mbp->mb_rdptr = msg;
 80027a4:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 80027a6:	f104 0010 	add.w	r0, r4, #16
 80027aa:	f7ff fb31 	bl	8001e10 <chSemSignalI>
    chSchRescheduleS();
 80027ae:	f7fe ffbf 	bl	8001730 <chSchRescheduleS>
 80027b2:	2300      	movs	r3, #0
 80027b4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 80027b8:	4628      	mov	r0, r5
 80027ba:	bd70      	pop	{r4, r5, r6, pc}
 80027bc:	0000      	movs	r0, r0
	...

080027c0 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80027c0:	6a42      	ldr	r2, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 80027c2:	2a00      	cmp	r2, #0
 80027c4:	dd11      	ble.n	80027ea <chMBPostAheadI+0x2a>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80027c6:	68c3      	ldr	r3, [r0, #12]
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80027c8:	b510      	push	{r4, lr}

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80027ca:	6804      	ldr	r4, [r0, #0]
 80027cc:	3b04      	subs	r3, #4
 80027ce:	3a01      	subs	r2, #1
 80027d0:	42a3      	cmp	r3, r4
 80027d2:	6242      	str	r2, [r0, #36]	; 0x24
 80027d4:	60c3      	str	r3, [r0, #12]
 80027d6:	d202      	bcs.n	80027de <chMBPostAheadI+0x1e>
    mbp->mb_rdptr = mbp->mb_top - 1;
 80027d8:	6843      	ldr	r3, [r0, #4]
 80027da:	3b04      	subs	r3, #4
 80027dc:	60c3      	str	r3, [r0, #12]
  }
  *mbp->mb_rdptr = msg;
 80027de:	6019      	str	r1, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 80027e0:	3010      	adds	r0, #16
 80027e2:	f7ff fb15 	bl	8001e10 <chSemSignalI>

  return MSG_OK;
 80027e6:	2000      	movs	r0, #0
 80027e8:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80027ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80027ee:	4770      	bx	lr

080027f0 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 80027f0:	b570      	push	{r4, r5, r6, lr}
 80027f2:	2320      	movs	r3, #32
 80027f4:	4604      	mov	r4, r0
 80027f6:	460e      	mov	r6, r1
 80027f8:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 80027fc:	4611      	mov	r1, r2
 80027fe:	3010      	adds	r0, #16
 8002800:	f7ff fac6 	bl	8001d90 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8002804:	4605      	mov	r5, r0
 8002806:	b980      	cbnz	r0, 800282a <chMBFetch+0x3a>
    *msgp = *mbp->mb_rdptr++;
 8002808:	68e3      	ldr	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 800280a:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 800280c:	6819      	ldr	r1, [r3, #0]
 800280e:	3304      	adds	r3, #4
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002810:	4293      	cmp	r3, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002812:	60e3      	str	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8002814:	bf28      	it	cs
 8002816:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002818:	6031      	str	r1, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_emptysem);
 800281a:	f104 001c 	add.w	r0, r4, #28

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 800281e:	bf28      	it	cs
 8002820:	60e3      	strcs	r3, [r4, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8002822:	f7ff faf5 	bl	8001e10 <chSemSignalI>
    chSchRescheduleS();
 8002826:	f7fe ff83 	bl	8001730 <chSchRescheduleS>
 800282a:	2300      	movs	r3, #0
 800282c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 8002830:	4628      	mov	r0, r5
 8002832:	bd70      	pop	{r4, r5, r6, pc}
	...

08002840 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002840:	6983      	ldr	r3, [r0, #24]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8002842:	2b00      	cmp	r3, #0
 8002844:	dd14      	ble.n	8002870 <chMBFetchI+0x30>
 8002846:	1e5a      	subs	r2, r3, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002848:	68c3      	ldr	r3, [r0, #12]
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 800284a:	b510      	push	{r4, lr}
 800284c:	6182      	str	r2, [r0, #24]
  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
 800284e:	6842      	ldr	r2, [r0, #4]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002850:	681c      	ldr	r4, [r3, #0]
 8002852:	3304      	adds	r3, #4
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8002854:	4293      	cmp	r3, r2

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002856:	60c3      	str	r3, [r0, #12]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 8002858:	bf28      	it	cs
 800285a:	6803      	ldrcs	r3, [r0, #0]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 800285c:	600c      	str	r4, [r1, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);
 800285e:	f100 001c 	add.w	r0, r0, #28
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 8002862:	bf28      	it	cs
 8002864:	f840 3c10 	strcs.w	r3, [r0, #-16]
  }
  chSemSignalI(&mbp->mb_emptysem);
 8002868:	f7ff fad2 	bl	8001e10 <chSemSignalI>

  return MSG_OK;
 800286c:	2000      	movs	r0, #0
 800286e:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 8002870:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002874:	4770      	bx	lr
 8002876:	bf00      	nop
	...

08002880 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8002880:	b430      	push	{r4, r5}
 8002882:	9c02      	ldr	r4, [sp, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8002884:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8002886:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002888:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800288a:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800288c:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800288e:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002890:	6040      	str	r0, [r0, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8002892:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 8002894:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 8002896:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8002898:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
 800289a:	bc30      	pop	{r4, r5}
 800289c:	4770      	bx	lr
 800289e:	bf00      	nop

080028a0 <chIQResetI>:

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 80028a0:	2100      	movs	r1, #0
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80028a2:	68c2      	ldr	r2, [r0, #12]
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 80028a4:	6081      	str	r1, [r0, #8]
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80028a6:	6182      	str	r2, [r0, #24]
  iqp->q_wrptr = iqp->q_buffer;
 80028a8:	6142      	str	r2, [r0, #20]
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 80028aa:	f06f 0101 	mvn.w	r1, #1
 80028ae:	f7ff b8df 	b.w	8001a70 <chThdDequeueAllI>
 80028b2:	bf00      	nop
	...

080028c0 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80028c0:	6983      	ldr	r3, [r0, #24]
 80028c2:	6942      	ldr	r2, [r0, #20]
 80028c4:	429a      	cmp	r2, r3
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 80028c6:	b510      	push	{r4, lr}
 80028c8:	6883      	ldr	r3, [r0, #8]
 80028ca:	d00f      	beq.n	80028ec <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80028cc:	3301      	adds	r3, #1
  *iqp->q_wrptr++ = b;
 80028ce:	1c54      	adds	r4, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80028d0:	6083      	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
 80028d2:	6144      	str	r4, [r0, #20]
 80028d4:	7011      	strb	r1, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80028d6:	6942      	ldr	r2, [r0, #20]
 80028d8:	6903      	ldr	r3, [r0, #16]
 80028da:	429a      	cmp	r2, r3
 80028dc:	d301      	bcc.n	80028e2 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 80028de:	68c3      	ldr	r3, [r0, #12]
 80028e0:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 80028e2:	2100      	movs	r1, #0
 80028e4:	f7ff f8b4 	bl	8001a50 <chThdDequeueNextI>

  return Q_OK;
 80028e8:	2000      	movs	r0, #0
 80028ea:	bd10      	pop	{r4, pc}
 80028ec:	2b00      	cmp	r3, #0
 80028ee:	d0ed      	beq.n	80028cc <chIQPutI+0xc>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 80028f0:	f06f 0003 	mvn.w	r0, #3
 80028f4:	bd10      	pop	{r4, pc}
 80028f6:	bf00      	nop
	...

08002900 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8002900:	b570      	push	{r4, r5, r6, lr}
 8002902:	2320      	movs	r3, #32
 8002904:	460e      	mov	r6, r1
 8002906:	4604      	mov	r4, r0
 8002908:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800290c:	69c3      	ldr	r3, [r0, #28]
 800290e:	b12b      	cbz	r3, 800291c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8002910:	4798      	blx	r3
 8002912:	e003      	b.n	800291c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8002914:	f7ff f884 	bl	8001a20 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8002918:	2800      	cmp	r0, #0
 800291a:	db15      	blt.n	8002948 <chIQGetTimeout+0x48>
 800291c:	68a5      	ldr	r5, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800291e:	4631      	mov	r1, r6
 8002920:	4620      	mov	r0, r4
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8002922:	2d00      	cmp	r5, #0
 8002924:	d0f6      	beq.n	8002914 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8002926:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8002928:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800292a:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800292c:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800292e:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
  b = *iqp->q_rdptr++;
 8002932:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8002934:	60a5      	str	r5, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8002936:	bf28      	it	cs
 8002938:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800293a:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800293c:	bf28      	it	cs
 800293e:	61a3      	strcs	r3, [r4, #24]
 8002940:	2300      	movs	r3, #0
 8002942:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8002946:	bd70      	pop	{r4, r5, r6, pc}
 8002948:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 800294c:	bd70      	pop	{r4, r5, r6, pc}
 800294e:	bf00      	nop

08002950 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8002950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002954:	4604      	mov	r4, r0
 8002956:	b083      	sub	sp, #12
 8002958:	4689      	mov	r9, r1
 800295a:	4693      	mov	fp, r2
 800295c:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 800295e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002962:	2720      	movs	r7, #32
 8002964:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8002968:	2600      	movs	r6, #0
 800296a:	9701      	str	r7, [sp, #4]
 800296c:	46b2      	mov	sl, r6

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 800296e:	f1b8 0f00 	cmp.w	r8, #0
 8002972:	d005      	beq.n	8002980 <chIQReadTimeout+0x30>
      nfy(iqp);
 8002974:	4620      	mov	r0, r4
 8002976:	47c0      	blx	r8
 8002978:	e002      	b.n	8002980 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800297a:	f7ff f851 	bl	8001a20 <chThdEnqueueTimeoutS>
 800297e:	b9d8      	cbnz	r0, 80029b8 <chIQReadTimeout+0x68>
 8002980:	68a7      	ldr	r7, [r4, #8]
 8002982:	4629      	mov	r1, r5
 8002984:	4620      	mov	r0, r4
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8002986:	2f00      	cmp	r7, #0
 8002988:	d0f7      	beq.n	800297a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800298a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800298c:	1e7b      	subs	r3, r7, #1
    *bp++ = *iqp->q_rdptr++;
 800298e:	1c51      	adds	r1, r2, #1
 8002990:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8002992:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8002994:	7813      	ldrb	r3, [r2, #0]
 8002996:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800299a:	6923      	ldr	r3, [r4, #16]
 800299c:	69a2      	ldr	r2, [r4, #24]
 800299e:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 80029a0:	bf24      	itt	cs
 80029a2:	68e3      	ldrcs	r3, [r4, #12]
 80029a4:	61a3      	strcs	r3, [r4, #24]
 80029a6:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 80029aa:	3601      	adds	r6, #1
    if (--n == 0U) {
 80029ac:	45b3      	cmp	fp, r6
 80029ae:	d005      	beq.n	80029bc <chIQReadTimeout+0x6c>
 80029b0:	9b01      	ldr	r3, [sp, #4]
 80029b2:	f383 8811 	msr	BASEPRI, r3
 80029b6:	e7da      	b.n	800296e <chIQReadTimeout+0x1e>
 80029b8:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 80029bc:	4630      	mov	r0, r6
 80029be:	b003      	add	sp, #12
 80029c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080029d0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 80029d0:	b430      	push	{r4, r5}
 80029d2:	9c02      	ldr	r4, [sp, #8]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80029d4:	6204      	str	r4, [r0, #32]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80029d6:	188d      	adds	r5, r1, r2
 80029d8:	6105      	str	r5, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80029da:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 80029dc:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80029de:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 80029e0:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 80029e2:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 80029e4:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80029e6:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
 80029e8:	bc30      	pop	{r4, r5}
 80029ea:	4770      	bx	lr
 80029ec:	0000      	movs	r0, r0
	...

080029f0 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 80029f0:	b410      	push	{r4}

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 80029f2:	6902      	ldr	r2, [r0, #16]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 80029f4:	68c4      	ldr	r4, [r0, #12]
 80029f6:	6184      	str	r4, [r0, #24]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 80029f8:	1b12      	subs	r2, r2, r4
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 80029fa:	6144      	str	r4, [r0, #20]
  oqp->q_counter = chQSizeX(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 80029fc:	f06f 0101 	mvn.w	r1, #1

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 8002a00:	6082      	str	r2, [r0, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
}
 8002a02:	bc10      	pop	{r4}
  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8002a04:	f7ff b834 	b.w	8001a70 <chThdDequeueAllI>
	...

08002a10 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8002a10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a12:	4604      	mov	r4, r0
 8002a14:	460f      	mov	r7, r1
 8002a16:	4616      	mov	r6, r2
 8002a18:	2320      	movs	r3, #32
 8002a1a:	f383 8811 	msr	BASEPRI, r3
 8002a1e:	e003      	b.n	8002a28 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8002a20:	f7fe fffe 	bl	8001a20 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8002a24:	2800      	cmp	r0, #0
 8002a26:	db18      	blt.n	8002a5a <chOQPutTimeout+0x4a>
 8002a28:	68a5      	ldr	r5, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8002a2a:	4631      	mov	r1, r6
 8002a2c:	4620      	mov	r0, r4
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8002a2e:	2d00      	cmp	r5, #0
 8002a30:	d0f6      	beq.n	8002a20 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8002a32:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8002a34:	3d01      	subs	r5, #1
  *oqp->q_wrptr++ = b;
 8002a36:	1c5a      	adds	r2, r3, #1
 8002a38:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8002a3a:	60a5      	str	r5, [r4, #8]
  *oqp->q_wrptr++ = b;
 8002a3c:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8002a3e:	6923      	ldr	r3, [r4, #16]
 8002a40:	6962      	ldr	r2, [r4, #20]
 8002a42:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8002a44:	bf24      	itt	cs
 8002a46:	68e3      	ldrcs	r3, [r4, #12]
 8002a48:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8002a4a:	69e3      	ldr	r3, [r4, #28]
 8002a4c:	b10b      	cbz	r3, 8002a52 <chOQPutTimeout+0x42>
    oqp->q_notify(oqp);
 8002a4e:	4620      	mov	r0, r4
 8002a50:	4798      	blx	r3
 8002a52:	2000      	movs	r0, #0
 8002a54:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8002a58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a5a:	f385 8811 	msr	BASEPRI, r5
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 8002a5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002a60 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8002a60:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002a62:	6982      	ldr	r2, [r0, #24]
 8002a64:	6943      	ldr	r3, [r0, #20]
 8002a66:	4293      	cmp	r3, r2
 8002a68:	6883      	ldr	r3, [r0, #8]
 8002a6a:	d00e      	beq.n	8002a8a <chOQGetI+0x2a>
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8002a6c:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8002a6e:	1c51      	adds	r1, r2, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8002a70:	3301      	adds	r3, #1
 8002a72:	6083      	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
 8002a74:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8002a76:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8002a78:	7814      	ldrb	r4, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8002a7a:	d301      	bcc.n	8002a80 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 8002a7c:	68c3      	ldr	r3, [r0, #12]
 8002a7e:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8002a80:	2100      	movs	r1, #0
 8002a82:	f7fe ffe5 	bl	8001a50 <chThdDequeueNextI>

  return (msg_t)b;
 8002a86:	4620      	mov	r0, r4
 8002a88:	bd38      	pop	{r3, r4, r5, pc}
 8002a8a:	2b00      	cmp	r3, #0
 8002a8c:	d0ee      	beq.n	8002a6c <chOQGetI+0xc>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8002a8e:	f06f 0002 	mvn.w	r0, #2
 8002a92:	bd38      	pop	{r3, r4, r5, pc}
	...

08002aa0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8002aa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002aa4:	b083      	sub	sp, #12
 8002aa6:	4604      	mov	r4, r0
 8002aa8:	460d      	mov	r5, r1
 8002aaa:	4616      	mov	r6, r2
 8002aac:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8002aae:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002ab2:	f04f 0920 	mov.w	r9, #32
 8002ab6:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 8002aba:	2700      	movs	r7, #0
 8002abc:	46ba      	mov	sl, r7
 8002abe:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002ac0:	f105 0b01 	add.w	fp, r5, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8002ac4:	1e59      	subs	r1, r3, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8002ac6:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8002ac8:	b1fb      	cbz	r3, 8002b0a <chOQWriteTimeout+0x6a>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002aca:	6963      	ldr	r3, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8002acc:	60a1      	str	r1, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8002ace:	1c59      	adds	r1, r3, #1
 8002ad0:	6161      	str	r1, [r4, #20]
 8002ad2:	7829      	ldrb	r1, [r5, #0]
 8002ad4:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8002ad6:	6923      	ldr	r3, [r4, #16]
 8002ad8:	6961      	ldr	r1, [r4, #20]
 8002ada:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
 8002adc:	bf24      	itt	cs
 8002ade:	68e3      	ldrcs	r3, [r4, #12]
 8002ae0:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8002ae2:	f1b8 0f00 	cmp.w	r8, #0
 8002ae6:	d000      	beq.n	8002aea <chOQWriteTimeout+0x4a>
      nfy(oqp);
 8002ae8:	47c0      	blx	r8
 8002aea:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8002aee:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8002af0:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 8002af4:	d013      	beq.n	8002b1e <chOQWriteTimeout+0x7e>
 8002af6:	f389 8811 	msr	BASEPRI, r9
 8002afa:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002afc:	465d      	mov	r5, fp
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8002afe:	1e59      	subs	r1, r3, #1
    *oqp->q_wrptr++ = *bp++;
 8002b00:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8002b04:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8002b06:	2b00      	cmp	r3, #0
 8002b08:	d1df      	bne.n	8002aca <chOQWriteTimeout+0x2a>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8002b0a:	9901      	ldr	r1, [sp, #4]
 8002b0c:	9300      	str	r3, [sp, #0]
 8002b0e:	4620      	mov	r0, r4
 8002b10:	f7fe ff86 	bl	8001a20 <chThdEnqueueTimeoutS>
 8002b14:	9b00      	ldr	r3, [sp, #0]
 8002b16:	2800      	cmp	r0, #0
 8002b18:	d0d1      	beq.n	8002abe <chOQWriteTimeout+0x1e>
 8002b1a:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8002b1e:	4638      	mov	r0, r7
 8002b20:	b003      	add	sp, #12
 8002b22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002b26:	bf00      	nop
	...

08002b30 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b30:	4a05      	ldr	r2, [pc, #20]	; (8002b48 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b32:	4b06      	ldr	r3, [pc, #24]	; (8002b4c <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b34:	4806      	ldr	r0, [pc, #24]	; (8002b50 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b36:	4907      	ldr	r1, [pc, #28]	; (8002b54 <_core_init+0x24>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b38:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b3c:	f023 0307 	bic.w	r3, r3, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002b40:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002b42:	600b      	str	r3, [r1, #0]
 8002b44:	4770      	bx	lr
 8002b46:	bf00      	nop
 8002b48:	200020b3 	.word	0x200020b3
 8002b4c:	20020000 	.word	0x20020000
 8002b50:	20000fcc 	.word	0x20000fcc
 8002b54:	20000fc8 	.word	0x20000fc8
	...

08002b60 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8002b60:	b410      	push	{r4}
 8002b62:	2320      	movs	r3, #32
 8002b64:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8002b68:	4c09      	ldr	r4, [pc, #36]	; (8002b90 <chCoreAlloc+0x30>)
 8002b6a:	4b0a      	ldr	r3, [pc, #40]	; (8002b94 <chCoreAlloc+0x34>)
 8002b6c:	6822      	ldr	r2, [r4, #0]
 8002b6e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8002b70:	1dc3      	adds	r3, r0, #7
 8002b72:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8002b76:	1a89      	subs	r1, r1, r2
 8002b78:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8002b7a:	bf9d      	ittte	ls
 8002b7c:	189b      	addls	r3, r3, r2
 8002b7e:	6023      	strls	r3, [r4, #0]

  return p;
 8002b80:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8002b82:	2000      	movhi	r0, #0
 8002b84:	2300      	movs	r3, #0
 8002b86:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8002b8a:	bc10      	pop	{r4}
 8002b8c:	4770      	bx	lr
 8002b8e:	bf00      	nop
 8002b90:	20000fcc 	.word	0x20000fcc
 8002b94:	20000fc8 	.word	0x20000fc8
	...

08002ba0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 8002ba0:	4a02      	ldr	r2, [pc, #8]	; (8002bac <chCoreGetStatusX+0xc>)
 8002ba2:	4b03      	ldr	r3, [pc, #12]	; (8002bb0 <chCoreGetStatusX+0x10>)
 8002ba4:	6810      	ldr	r0, [r2, #0]
 8002ba6:	681b      	ldr	r3, [r3, #0]
  /*lint -restore*/
}
 8002ba8:	1ac0      	subs	r0, r0, r3
 8002baa:	4770      	bx	lr
 8002bac:	20000fc8 	.word	0x20000fc8
 8002bb0:	20000fcc 	.word	0x20000fcc
	...

08002bc0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8002bc0:	4b04      	ldr	r3, [pc, #16]	; (8002bd4 <_heap_init+0x14>)
 8002bc2:	4a05      	ldr	r2, [pc, #20]	; (8002bd8 <_heap_init+0x18>)
 8002bc4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8002bc6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = NULL;
 8002bca:	2200      	movs	r2, #0
 8002bcc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8002bce:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8002bd0:	f7ff b97e 	b.w	8001ed0 <chMtxObjectInit>
 8002bd4:	20000fd0 	.word	0x20000fd0
 8002bd8:	08002b61 	.word	0x08002b61
 8002bdc:	00000000 	.word	0x00000000

08002be0 <chHeapObjectInit>:
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002be0:	2300      	movs	r3, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8002be2:	3a08      	subs	r2, #8
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8002be4:	6081      	str	r1, [r0, #8]
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002be6:	6003      	str	r3, [r0, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8002be8:	60c3      	str	r3, [r0, #12]
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8002bea:	3010      	adds	r0, #16

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8002bec:	604a      	str	r2, [r1, #4]
  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 8002bee:	600b      	str	r3, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8002bf0:	f7ff b96e 	b.w	8001ed0 <chMtxObjectInit>
	...

08002c00 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8002c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002c02:	4e21      	ldr	r6, [pc, #132]	; (8002c88 <chHeapAlloc+0x88>)
 8002c04:	2800      	cmp	r0, #0
 8002c06:	bf18      	it	ne
 8002c08:	4606      	movne	r6, r0
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8002c0a:	f106 0710 	add.w	r7, r6, #16

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 8002c0e:	3107      	adds	r1, #7
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8002c10:	4638      	mov	r0, r7

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 8002c12:	f021 0507 	bic.w	r5, r1, #7
  qp = &heapp->h_free;
 8002c16:	f106 0408 	add.w	r4, r6, #8

  H_LOCK(heapp);
 8002c1a:	f7ff f9c9 	bl	8001fb0 <chMtxLock>
  while (qp->h.u.next != NULL) {
 8002c1e:	e003      	b.n	8002c28 <chHeapAlloc+0x28>
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8002c20:	6843      	ldr	r3, [r0, #4]
 8002c22:	429d      	cmp	r5, r3
 8002c24:	d912      	bls.n	8002c4c <chHeapAlloc+0x4c>
 8002c26:	4604      	mov	r4, r0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 8002c28:	6820      	ldr	r0, [r4, #0]
 8002c2a:	2800      	cmp	r0, #0
 8002c2c:	d1f8      	bne.n	8002c20 <chHeapAlloc+0x20>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8002c2e:	4638      	mov	r0, r7
 8002c30:	f7ff f9e6 	bl	8002000 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 8002c34:	6833      	ldr	r3, [r6, #0]
 8002c36:	b32b      	cbz	r3, 8002c84 <chHeapAlloc+0x84>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8002c38:	f105 0008 	add.w	r0, r5, #8
 8002c3c:	4798      	blx	r3
    if (hp != NULL) {
 8002c3e:	b308      	cbz	r0, 8002c84 <chHeapAlloc+0x84>
      hp->h.u.heap = heapp;
 8002c40:	6006      	str	r6, [r0, #0]
      hp->h.size = size;
 8002c42:	6045      	str	r5, [r0, #4]
      hp++;
 8002c44:	f100 0408 	add.w	r4, r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8002c48:	4620      	mov	r0, r4
 8002c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 8002c4c:	f105 0208 	add.w	r2, r5, #8
 8002c50:	4293      	cmp	r3, r2
 8002c52:	d209      	bcs.n	8002c68 <chHeapAlloc+0x68>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 8002c54:	6803      	ldr	r3, [r0, #0]
 8002c56:	6023      	str	r3, [r4, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8002c58:	4604      	mov	r4, r0
      H_UNLOCK(heapp);
 8002c5a:	4638      	mov	r0, r7
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8002c5c:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8002c60:	f7ff f9ce 	bl	8002000 <chMtxUnlock>
      /*lint -restore*/
    }
  }

  return NULL;
}
 8002c64:	4620      	mov	r0, r4
 8002c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002c68:	f06f 0107 	mvn.w	r1, #7
 8002c6c:	1b49      	subs	r1, r1, r5
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 8002c6e:	eb00 0e02 	add.w	lr, r0, r2
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002c72:	440b      	add	r3, r1
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8002c74:	6801      	ldr	r1, [r0, #0]
 8002c76:	5081      	str	r1, [r0, r2]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002c78:	f8ce 3004 	str.w	r3, [lr, #4]
        qp->h.u.next = fp;
 8002c7c:	f8c4 e000 	str.w	lr, [r4]
        hp->h.size = size;
 8002c80:	6045      	str	r5, [r0, #4]
 8002c82:	e7e9      	b.n	8002c58 <chHeapAlloc+0x58>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 8002c84:	2400      	movs	r4, #0
 8002c86:	e7df      	b.n	8002c48 <chHeapAlloc+0x48>
 8002c88:	20000fd0 	.word	0x20000fd0
 8002c8c:	00000000 	.word	0x00000000

08002c90 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002c90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8002c92:	f850 5c08 	ldr.w	r5, [r0, #-8]
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8002c96:	f105 0710 	add.w	r7, r5, #16
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002c9a:	4606      	mov	r6, r0
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8002c9c:	f1a0 0408 	sub.w	r4, r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8002ca0:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8002ca2:	4638      	mov	r0, r7
 8002ca4:	f7ff f984 	bl	8001fb0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8002ca8:	462b      	mov	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8002caa:	42ab      	cmp	r3, r5
 8002cac:	d004      	beq.n	8002cb8 <chHeapFree+0x28>
 8002cae:	42a3      	cmp	r3, r4
 8002cb0:	d302      	bcc.n	8002cb8 <chHeapFree+0x28>
 8002cb2:	681b      	ldr	r3, [r3, #0]
 8002cb4:	42ab      	cmp	r3, r5
 8002cb6:	d1fa      	bne.n	8002cae <chHeapFree+0x1e>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8002cb8:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8002cba:	b11a      	cbz	r2, 8002cc4 <chHeapFree+0x34>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8002cbc:	4294      	cmp	r4, r2
 8002cbe:	d301      	bcc.n	8002cc4 <chHeapFree+0x34>
 8002cc0:	4613      	mov	r3, r2
        qp->h.u.next = hp->h.u.next;
      }
      break;
    }
    qp = qp->h.u.next;
  }
 8002cc2:	e7f2      	b.n	8002caa <chHeapFree+0x1a>
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8002cc4:	f846 2c08 	str.w	r2, [r6, #-8]
      qp->h.u.next = hp;
 8002cc8:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8002cca:	f856 1c04 	ldr.w	r1, [r6, #-4]
 8002cce:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8002cd2:	f101 0208 	add.w	r2, r1, #8
 8002cd6:	18a0      	adds	r0, r4, r2
 8002cd8:	42a8      	cmp	r0, r5
 8002cda:	d00a      	beq.n	8002cf2 <chHeapFree+0x62>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8002cdc:	6859      	ldr	r1, [r3, #4]
 8002cde:	f101 0208 	add.w	r2, r1, #8
 8002ce2:	441a      	add	r2, r3
 8002ce4:	4294      	cmp	r4, r2
 8002ce6:	d012      	beq.n	8002d0e <chHeapFree+0x7e>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002ce8:	4638      	mov	r0, r7

  return;
}
 8002cea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002cee:	f7ff b987 	b.w	8002000 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8002cf2:	6840      	ldr	r0, [r0, #4]
 8002cf4:	4401      	add	r1, r0
 8002cf6:	3108      	adds	r1, #8
 8002cf8:	f846 1c04 	str.w	r1, [r6, #-4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8002cfc:	58a2      	ldr	r2, [r4, r2]
 8002cfe:	f846 2c08 	str.w	r2, [r6, #-8]
      }
      if ((LIMIT(qp) == hp)) {
 8002d02:	6859      	ldr	r1, [r3, #4]
 8002d04:	f101 0208 	add.w	r2, r1, #8
 8002d08:	441a      	add	r2, r3
 8002d0a:	4294      	cmp	r4, r2
 8002d0c:	d1ec      	bne.n	8002ce8 <chHeapFree+0x58>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8002d0e:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8002d12:	440a      	add	r2, r1
 8002d14:	3208      	adds	r2, #8
 8002d16:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8002d18:	f856 2c08 	ldr.w	r2, [r6, #-8]
 8002d1c:	601a      	str	r2, [r3, #0]
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002d1e:	4638      	mov	r0, r7

  return;
}
 8002d20:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002d24:	f7ff b96c 	b.w	8002000 <chMtxUnlock>
	...

08002d30 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002d30:	b570      	push	{r4, r5, r6, lr}
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002d32:	4c0f      	ldr	r4, [pc, #60]	; (8002d70 <chHeapStatus+0x40>)
 8002d34:	2800      	cmp	r0, #0
 8002d36:	bf18      	it	ne
 8002d38:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 8002d3a:	f104 0510 	add.w	r5, r4, #16
 8002d3e:	4628      	mov	r0, r5
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002d40:	460e      	mov	r6, r1

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8002d42:	f7ff f935 	bl	8001fb0 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002d46:	68a3      	ldr	r3, [r4, #8]
 8002d48:	b173      	cbz	r3, 8002d68 <chHeapStatus+0x38>
 8002d4a:	2200      	movs	r2, #0
 8002d4c:	4614      	mov	r4, r2
    sz += qp->h.u.next->h.size;
 8002d4e:	6858      	ldr	r0, [r3, #4]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002d50:	681b      	ldr	r3, [r3, #0]
    sz += qp->h.u.next->h.size;
    n++;
 8002d52:	3401      	adds	r4, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8002d54:	4402      	add	r2, r0

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002d56:	2b00      	cmp	r3, #0
 8002d58:	d1f9      	bne.n	8002d4e <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8002d5a:	b106      	cbz	r6, 8002d5e <chHeapStatus+0x2e>
    *sizep = sz;
 8002d5c:	6032      	str	r2, [r6, #0]
  }
  H_UNLOCK(heapp);
 8002d5e:	4628      	mov	r0, r5
 8002d60:	f7ff f94e 	bl	8002000 <chMtxUnlock>

  return n;
}
 8002d64:	4620      	mov	r0, r4
 8002d66:	bd70      	pop	{r4, r5, r6, pc}
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 8002d68:	461a      	mov	r2, r3
  n = 0;
 8002d6a:	461c      	mov	r4, r3
 8002d6c:	e7f5      	b.n	8002d5a <chHeapStatus+0x2a>
 8002d6e:	bf00      	nop
 8002d70:	20000fd0 	.word	0x20000fd0
	...

08002d80 <chPoolObjectInit>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8002d80:	2300      	movs	r3, #0
  mp->mp_object_size = size;
 8002d82:	6041      	str	r1, [r0, #4]
  mp->mp_provider = provider;
 8002d84:	6082      	str	r2, [r0, #8]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8002d86:	6003      	str	r3, [r0, #0]
 8002d88:	4770      	bx	lr
 8002d8a:	bf00      	nop
 8002d8c:	0000      	movs	r0, r0
	...

08002d90 <chPoolLoadArray>:
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8002d90:	b172      	cbz	r2, 8002db0 <chPoolLoadArray+0x20>
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8002d92:	b430      	push	{r4, r5}
 8002d94:	2520      	movs	r5, #32
 8002d96:	2400      	movs	r4, #0
 8002d98:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8002d9c:	6803      	ldr	r3, [r0, #0]
 8002d9e:	600b      	str	r3, [r1, #0]
  mp->mp_next = php;
 8002da0:	6001      	str	r1, [r0, #0]
 8002da2:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8002da6:	6843      	ldr	r3, [r0, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8002da8:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8002daa:	4419      	add	r1, r3
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8002dac:	d1f4      	bne.n	8002d98 <chPoolLoadArray+0x8>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 8002dae:	bc30      	pop	{r4, r5}
 8002db0:	4770      	bx	lr
 8002db2:	bf00      	nop
	...

08002dc0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8002dc0:	b508      	push	{r3, lr}
 8002dc2:	2220      	movs	r2, #32
 8002dc4:	4603      	mov	r3, r0
 8002dc6:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 8002dca:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8002dcc:	b128      	cbz	r0, 8002dda <chPoolAlloc+0x1a>
    mp->mp_next = mp->mp_next->ph_next;
 8002dce:	6802      	ldr	r2, [r0, #0]
 8002dd0:	601a      	str	r2, [r3, #0]
 8002dd2:	2300      	movs	r3, #0
 8002dd4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8002dd8:	bd08      	pop	{r3, pc}
  objp = mp->mp_next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 8002dda:	689a      	ldr	r2, [r3, #8]
 8002ddc:	2a00      	cmp	r2, #0
 8002dde:	d0f8      	beq.n	8002dd2 <chPoolAlloc+0x12>
    objp = mp->mp_provider(mp->mp_object_size);
 8002de0:	6858      	ldr	r0, [r3, #4]
 8002de2:	4790      	blx	r2
 8002de4:	2300      	movs	r3, #0
 8002de6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8002dea:	bd08      	pop	{r3, pc}
 8002dec:	0000      	movs	r0, r0
	...

08002df0 <chPoolFree>:
 8002df0:	2320      	movs	r3, #32
 8002df2:	f383 8811 	msr	BASEPRI, r3
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8002df6:	6803      	ldr	r3, [r0, #0]
 8002df8:	600b      	str	r3, [r1, #0]
 8002dfa:	2300      	movs	r3, #0
  mp->mp_next = php;
 8002dfc:	6001      	str	r1, [r0, #0]
 8002dfe:	f383 8811 	msr	BASEPRI, r3
 8002e02:	4770      	bx	lr
	...

08002e10 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8002e10:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8002e14:	3320      	adds	r3, #32
 8002e16:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002e1a:	2300      	movs	r3, #0
 8002e1c:	f383 8811 	msr	BASEPRI, r3
 8002e20:	4770      	bx	lr
 8002e22:	bf00      	nop
	...

08002e30 <_port_irq_epilogue>:
 8002e30:	2320      	movs	r3, #32
 8002e32:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8002e36:	4b0f      	ldr	r3, [pc, #60]	; (8002e74 <_port_irq_epilogue+0x44>)
 8002e38:	685b      	ldr	r3, [r3, #4]
 8002e3a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8002e3e:	d102      	bne.n	8002e46 <_port_irq_epilogue+0x16>
 8002e40:	f383 8811 	msr	BASEPRI, r3
 8002e44:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8002e46:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8002e48:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8002e4c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8002e50:	f844 3c04 	str.w	r3, [r4, #-4]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8002e54:	f1a4 0320 	sub.w	r3, r4, #32
 8002e58:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8002e5c:	f7fe fc18 	bl	8001690 <chSchIsPreemptionRequired>
 8002e60:	b118      	cbz	r0, 8002e6a <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8002e62:	4b05      	ldr	r3, [pc, #20]	; (8002e78 <_port_irq_epilogue+0x48>)
 8002e64:	f844 3c08 	str.w	r3, [r4, #-8]
 8002e68:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8002e6a:	4b04      	ldr	r3, [pc, #16]	; (8002e7c <_port_irq_epilogue+0x4c>)
 8002e6c:	f844 3c08 	str.w	r3, [r4, #-8]
 8002e70:	bd10      	pop	{r4, pc}
 8002e72:	bf00      	nop
 8002e74:	e000ed00 	.word	0xe000ed00
 8002e78:	080002a1 	.word	0x080002a1
 8002e7c:	080002a4 	.word	0x080002a4

08002e80 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8002e80:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8002e82:	f001 f8a5 	bl	8003fd0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8002e86:	480a      	ldr	r0, [pc, #40]	; (8002eb0 <halInit+0x30>)
 8002e88:	f001 fb0a 	bl	80044a0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 8002e8c:	f000 f838 	bl	8002f00 <adcInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8002e90:	f000 f876 	bl	8002f80 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8002e94:	f000 f8ec 	bl	8003070 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8002e98:	f000 fafa 	bl	8003490 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8002e9c:	f000 fb68 	bl	8003570 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8002ea0:	f000 f9e6 	bl	8003270 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8002ea4:	f002 fd0c 	bl	80058c0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8002ea8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8002eac:	f000 b808 	b.w	8002ec0 <stInit>
 8002eb0:	0800a600 	.word	0x0800a600
	...

08002ec0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8002ec0:	f001 b93e 	b.w	8004140 <st_lld_init>
	...

08002ed0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002ed0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8002ed4:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002ed6:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002ed8:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8002eda:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002edc:	60da      	str	r2, [r3, #12]
 8002ede:	4770      	bx	lr

08002ee0 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8002ee0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ee4:	2200      	movs	r2, #0
 8002ee6:	60da      	str	r2, [r3, #12]
 8002ee8:	4770      	bx	lr
 8002eea:	bf00      	nop
 8002eec:	0000      	movs	r0, r0
	...

08002ef0 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002ef0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ef4:	6358      	str	r0, [r3, #52]	; 0x34
 8002ef6:	4770      	bx	lr
	...

08002f00 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8002f00:	f001 ba1e 	b.w	8004340 <adc_lld_init>
	...

08002f10 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8002f10:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8002f12:	2201      	movs	r2, #1
 8002f14:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 8002f16:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 8002f18:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 8002f1a:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 8002f1c:	6103      	str	r3, [r0, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8002f1e:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8002f20:	3018      	adds	r0, #24
 8002f22:	f7fe bfd5 	b.w	8001ed0 <chMtxObjectInit>
 8002f26:	bf00      	nop
	...

08002f30 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8002f30:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002f32:	2320      	movs	r3, #32
 8002f34:	4604      	mov	r4, r0
 8002f36:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8002f3a:	6041      	str	r1, [r0, #4]
  adc_lld_start(adcp);
 8002f3c:	f001 fa20 	bl	8004380 <adc_lld_start>
  adcp->state = ADC_READY;
 8002f40:	2302      	movs	r3, #2
 8002f42:	7023      	strb	r3, [r4, #0]
 8002f44:	2300      	movs	r3, #0
 8002f46:	f383 8811 	msr	BASEPRI, r3
 8002f4a:	bd10      	pop	{r4, pc}
 8002f4c:	0000      	movs	r0, r0
	...

08002f50 <adcConvert>:
 * @api
 */
msg_t adcConvert(ADCDriver *adcp,
                 const ADCConversionGroup *grpp,
                 adcsample_t *samples,
                 size_t depth) {
 8002f50:	b570      	push	{r4, r5, r6, lr}
 8002f52:	2520      	movs	r5, #32
 8002f54:	f385 8811 	msr	BASEPRI, r5
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 8002f58:	4605      	mov	r5, r0
 8002f5a:	2603      	movs	r6, #3
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 8002f5c:	6082      	str	r2, [r0, #8]
  adcp->depth    = depth;
 8002f5e:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = grpp;
 8002f60:	6101      	str	r1, [r0, #16]
  adcp->state    = ADC_ACTIVE;
 8002f62:	f805 6b14 	strb.w	r6, [r5], #20
  adc_lld_start_conversion(adcp);
 8002f66:	f001 fa43 	bl	80043f0 <adc_lld_start_conversion>
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 8002f6a:	4628      	mov	r0, r5
 8002f6c:	f7fe fd38 	bl	80019e0 <chThdSuspendS>
 8002f70:	2300      	movs	r3, #0
 8002f72:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(adcp->thread == NULL, "already waiting");
  adcStartConversionI(adcp, grpp, samples, depth);
  msg = osalThreadSuspendS(&adcp->thread);
  osalSysUnlock();
  return msg;
}
 8002f76:	bd70      	pop	{r4, r5, r6, pc}
	...

08002f80 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 8002f80:	f002 bb0e 	b.w	80055a0 <pwm_lld_init>
	...

08002f90 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 8002f90:	2300      	movs	r3, #0
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8002f92:	2201      	movs	r2, #1
 8002f94:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 8002f96:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8002f98:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 8002f9a:	7403      	strb	r3, [r0, #16]
 8002f9c:	4770      	bx	lr
 8002f9e:	bf00      	nop

08002fa0 <pwmStart>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] config    pointer to a @p PWMConfig object
 *
 * @api
 */
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8002fa0:	b510      	push	{r4, lr}
 8002fa2:	2320      	movs	r3, #32
 8002fa4:	4604      	mov	r4, r0
 8002fa6:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
 8002faa:	684b      	ldr	r3, [r1, #4]
 8002fac:	6083      	str	r3, [r0, #8]
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 8002fae:	6041      	str	r1, [r0, #4]
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
 8002fb0:	f002 fb06 	bl	80055c0 <pwm_lld_start>
  pwmp->enabled = 0;
  pwmp->state = PWM_READY;
 8002fb4:	2202      	movs	r2, #2
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
 8002fb6:	2300      	movs	r3, #0
  pwmp->state = PWM_READY;
 8002fb8:	7022      	strb	r2, [r4, #0]
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
 8002fba:	60e3      	str	r3, [r4, #12]
 8002fbc:	f383 8811 	msr	BASEPRI, r3
 8002fc0:	bd10      	pop	{r4, pc}
 8002fc2:	bf00      	nop
	...

08002fd0 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8002fd0:	b570      	push	{r4, r5, r6, lr}
 8002fd2:	2420      	movs	r4, #32
 8002fd4:	f384 8811 	msr	BASEPRI, r4

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 8002fd8:	2401      	movs	r4, #1
 8002fda:	68c6      	ldr	r6, [r0, #12]
 8002fdc:	fa04 f301 	lsl.w	r3, r4, r1
 8002fe0:	4333      	orrs	r3, r6
 8002fe2:	60c3      	str	r3, [r0, #12]
 8002fe4:	f002 fb64 	bl	80056b0 <pwm_lld_enable_channel>
 8002fe8:	2300      	movs	r3, #0
 8002fea:	f383 8811 	msr	BASEPRI, r3
 8002fee:	bd70      	pop	{r4, r5, r6, pc}

08002ff0 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8002ff0:	300c      	adds	r0, #12
 8002ff2:	f7ff bcad 	b.w	8002950 <chIQReadTimeout>
 8002ff6:	bf00      	nop
	...

08003000 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8003000:	300c      	adds	r0, #12
 8003002:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003006:	f7ff bca3 	b.w	8002950 <chIQReadTimeout>
 800300a:	bf00      	nop
 800300c:	0000      	movs	r0, r0
	...

08003010 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003010:	3030      	adds	r0, #48	; 0x30
 8003012:	f7ff bd45 	b.w	8002aa0 <chOQWriteTimeout>
 8003016:	bf00      	nop
	...

08003020 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8003020:	3030      	adds	r0, #48	; 0x30
 8003022:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003026:	f7ff bd3b 	b.w	8002aa0 <chOQWriteTimeout>
 800302a:	bf00      	nop
 800302c:	0000      	movs	r0, r0
	...

08003030 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003030:	300c      	adds	r0, #12
 8003032:	f7ff bc65 	b.w	8002900 <chIQGetTimeout>
 8003036:	bf00      	nop
	...

08003040 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003040:	300c      	adds	r0, #12
 8003042:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003046:	f7ff bc5b 	b.w	8002900 <chIQGetTimeout>
 800304a:	bf00      	nop
 800304c:	0000      	movs	r0, r0
	...

08003050 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003050:	3030      	adds	r0, #48	; 0x30
 8003052:	f7ff bcdd 	b.w	8002a10 <chOQPutTimeout>
 8003056:	bf00      	nop
	...

08003060 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003060:	3030      	adds	r0, #48	; 0x30
 8003062:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003066:	f7ff bcd3 	b.w	8002a10 <chOQPutTimeout>
 800306a:	bf00      	nop
 800306c:	0000      	movs	r0, r0
	...

08003070 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8003070:	f002 bbbe 	b.w	80057f0 <sd_lld_init>
	...

08003080 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8003080:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 8003082:	4b0e      	ldr	r3, [pc, #56]	; (80030bc <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8003084:	4604      	mov	r4, r0
 8003086:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
 8003088:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800308c:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 800308e:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8003090:	4615      	mov	r5, r2

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8003092:	460b      	mov	r3, r1
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8003094:	6060      	str	r0, [r4, #4]
 8003096:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800309a:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800309e:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80030a0:	2210      	movs	r2, #16
 80030a2:	f7ff fbed 	bl	8002880 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80030a6:	9400      	str	r4, [sp, #0]
 80030a8:	462b      	mov	r3, r5
 80030aa:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80030ae:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80030b2:	2210      	movs	r2, #16
 80030b4:	f7ff fc8c 	bl	80029d0 <chOQObjectInit>
}
 80030b8:	b002      	add	sp, #8
 80030ba:	bd70      	pop	{r4, r5, r6, pc}
 80030bc:	0800a460 	.word	0x0800a460

080030c0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80030c0:	b510      	push	{r4, lr}
 80030c2:	2320      	movs	r3, #32
 80030c4:	4604      	mov	r4, r0
 80030c6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80030ca:	f002 fba1 	bl	8005810 <sd_lld_start>
  sdp->state = SD_READY;
 80030ce:	2302      	movs	r3, #2
 80030d0:	7223      	strb	r3, [r4, #8]
 80030d2:	2300      	movs	r3, #0
 80030d4:	f383 8811 	msr	BASEPRI, r3
 80030d8:	bd10      	pop	{r4, pc}
 80030da:	bf00      	nop
 80030dc:	0000      	movs	r0, r0
	...

080030e0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 80030e0:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80030e2:	6943      	ldr	r3, [r0, #20]
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 80030e4:	4604      	mov	r4, r0
 80030e6:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80030e8:	b13b      	cbz	r3, 80030fa <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80030ea:	4629      	mov	r1, r5
 80030ec:	f104 000c 	add.w	r0, r4, #12
 80030f0:	f7ff fbe6 	bl	80028c0 <chIQPutI>
 80030f4:	2800      	cmp	r0, #0
 80030f6:	db0b      	blt.n	8003110 <sdIncomingDataI+0x30>
 80030f8:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80030fa:	2104      	movs	r1, #4
 80030fc:	4408      	add	r0, r1
 80030fe:	f7ff f92f 	bl	8002360 <chEvtBroadcastFlagsI>
 8003102:	4629      	mov	r1, r5
 8003104:	f104 000c 	add.w	r0, r4, #12
 8003108:	f7ff fbda 	bl	80028c0 <chIQPutI>
 800310c:	2800      	cmp	r0, #0
 800310e:	daf3      	bge.n	80030f8 <sdIncomingDataI+0x18>
 8003110:	1d20      	adds	r0, r4, #4
 8003112:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8003114:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003118:	f7ff b922 	b.w	8002360 <chEvtBroadcastFlagsI>
 800311c:	0000      	movs	r0, r0
	...

08003120 <onotify>:
/**
 * @brief   Notification of data inserted into the output queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void onotify(io_queue_t *qp) {
 8003120:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = qGetLink(qp);
 8003122:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003124:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 8003128:	6813      	ldr	r3, [r2, #0]
 800312a:	7819      	ldrb	r1, [r3, #0]
 800312c:	2904      	cmp	r1, #4
 800312e:	d000      	beq.n	8003132 <onotify+0x12>
 8003130:	bd10      	pop	{r4, pc}
 8003132:	7a21      	ldrb	r1, [r4, #8]
 8003134:	2902      	cmp	r1, #2
 8003136:	d1fb      	bne.n	8003130 <onotify+0x10>
    return;
  }

  /* If there is not an ongoing transaction and the output queue contains
     data then a new transaction is started.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8003138:	7910      	ldrb	r0, [r2, #4]
 800313a:	8919      	ldrh	r1, [r3, #8]
 800313c:	2201      	movs	r2, #1
 800313e:	fa02 f300 	lsl.w	r3, r2, r0
 8003142:	ea13 0201 	ands.w	r2, r3, r1
 8003146:	d1f3      	bne.n	8003130 <onotify+0x10>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 8003148:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800314a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800314c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800314e:	1acb      	subs	r3, r1, r3
    if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 8003150:	1a1b      	subs	r3, r3, r0
 8003152:	d0ed      	beq.n	8003130 <onotify+0x10>
 8003154:	f382 8811 	msr	BASEPRI, r2
      osalSysUnlock();

      usbPrepareQueuedTransmit(sdup->config->usbp,
 8003158:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800315c:	7911      	ldrb	r1, [r2, #4]
 800315e:	6810      	ldr	r0, [r2, #0]
 8003160:	f104 0230 	add.w	r2, r4, #48	; 0x30
 8003164:	f000 fa5c 	bl	8003620 <usbPrepareQueuedTransmit>
 8003168:	2320      	movs	r3, #32
 800316a:	f383 8811 	msr	BASEPRI, r3
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800316e:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
    }
  }
}
 8003172:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      usbPrepareQueuedTransmit(sdup->config->usbp,
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 8003176:	7919      	ldrb	r1, [r3, #4]
 8003178:	6818      	ldr	r0, [r3, #0]
 800317a:	f000 ba79 	b.w	8003670 <usbStartTransmitI>
 800317e:	bf00      	nop

08003180 <inotify>:
/**
 * @brief   Notification of data removed from the input queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void inotify(io_queue_t *qp) {
 8003180:	b538      	push	{r3, r4, r5, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = qGetLink(qp);
 8003182:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003184:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 8003188:	6813      	ldr	r3, [r2, #0]
 800318a:	7819      	ldrb	r1, [r3, #0]
 800318c:	2904      	cmp	r1, #4
 800318e:	d000      	beq.n	8003192 <inotify+0x12>
 8003190:	bd38      	pop	{r3, r4, r5, pc}
 8003192:	7a21      	ldrb	r1, [r4, #8]
 8003194:	2902      	cmp	r1, #2
 8003196:	d1fb      	bne.n	8003190 <inotify+0x10>
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 8003198:	7950      	ldrb	r0, [r2, #5]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800319a:	8959      	ldrh	r1, [r3, #10]
 800319c:	2201      	movs	r2, #1
 800319e:	4082      	lsls	r2, r0
 80031a0:	400a      	ands	r2, r1
 80031a2:	d1f5      	bne.n	8003190 <inotify+0x10>
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 80031a4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 80031a8:	69a1      	ldr	r1, [r4, #24]
 80031aa:	69e0      	ldr	r0, [r4, #28]
 80031ac:	68db      	ldr	r3, [r3, #12]
 80031ae:	6965      	ldr	r5, [r4, #20]
 80031b0:	8a5b      	ldrh	r3, [r3, #18]
 80031b2:	1a40      	subs	r0, r0, r1
 80031b4:	1b41      	subs	r1, r0, r5
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
    if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 80031b6:	428b      	cmp	r3, r1
 80031b8:	d8ea      	bhi.n	8003190 <inotify+0x10>
 80031ba:	f382 8811 	msr	BASEPRI, r2
      osalSysUnlock();

      n = (n / maxsize) * maxsize;
      usbPrepareQueuedReceive(sdup->config->usbp,
 80031be:	fbb1 f1f3 	udiv	r1, r1, r3
 80031c2:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 80031c6:	fb03 f301 	mul.w	r3, r3, r1
 80031ca:	6810      	ldr	r0, [r2, #0]
 80031cc:	7951      	ldrb	r1, [r2, #5]
 80031ce:	f104 020c 	add.w	r2, r4, #12
 80031d2:	f000 fa15 	bl	8003600 <usbPrepareQueuedReceive>
 80031d6:	2320      	movs	r3, #32
 80031d8:	f383 8811 	msr	BASEPRI, r3
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 80031dc:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 80031e0:	7959      	ldrb	r1, [r3, #5]
 80031e2:	6818      	ldr	r0, [r3, #0]
    }
  }
}
 80031e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      usbPrepareQueuedReceive(sdup->config->usbp,
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 80031e8:	f000 ba2a 	b.w	8003640 <usbStartReceiveI>
 80031ec:	0000      	movs	r0, r0
	...

080031f0 <readt>:
  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp, n, timeout);
 80031f0:	300c      	adds	r0, #12
 80031f2:	f7ff bbad 	b.w	8002950 <chIQReadTimeout>
 80031f6:	bf00      	nop
	...

08003200 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp,
 8003200:	300c      	adds	r0, #12
 8003202:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003206:	f7ff bba3 	b.w	8002950 <chIQReadTimeout>
 800320a:	bf00      	nop
 800320c:	0000      	movs	r0, r0
	...

08003210 <writet>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
 8003210:	3030      	adds	r0, #48	; 0x30
 8003212:	f7ff bc45 	b.w	8002aa0 <chOQWriteTimeout>
 8003216:	bf00      	nop
	...

08003220 <write>:
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp,
 8003220:	3030      	adds	r0, #48	; 0x30
 8003222:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003226:	f7ff bc3b 	b.w	8002aa0 <chOQWriteTimeout>
 800322a:	bf00      	nop
 800322c:	0000      	movs	r0, r0
	...

08003230 <gett>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
 8003230:	300c      	adds	r0, #12
 8003232:	f7ff bb65 	b.w	8002900 <chIQGetTimeout>
 8003236:	bf00      	nop
	...

08003240 <get>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
 8003240:	300c      	adds	r0, #12
 8003242:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003246:	f7ff bb5b 	b.w	8002900 <chIQGetTimeout>
 800324a:	bf00      	nop
 800324c:	0000      	movs	r0, r0
	...

08003250 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
 8003250:	3030      	adds	r0, #48	; 0x30
 8003252:	f7ff bbdd 	b.w	8002a10 <chOQPutTimeout>
 8003256:	bf00      	nop
	...

08003260 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003260:	3030      	adds	r0, #48	; 0x30
 8003262:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003266:	f7ff bbd3 	b.w	8002a10 <chOQPutTimeout>
 800326a:	bf00      	nop
 800326c:	0000      	movs	r0, r0
	...

08003270 <sduInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
 8003270:	4770      	bx	lr
 8003272:	bf00      	nop
	...

08003280 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 8003280:	b510      	push	{r4, lr}

  sdup->vmt = &vmt;
 8003282:	4603      	mov	r3, r0
 8003284:	4a0e      	ldr	r2, [pc, #56]	; (80032c0 <sduObjectInit+0x40>)
 8003286:	f843 2b04 	str.w	r2, [r3], #4
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800328a:	b082      	sub	sp, #8

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800328c:	2201      	movs	r2, #1
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800328e:	4604      	mov	r4, r0

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 8003290:	9000      	str	r0, [sp, #0]
 8003292:	f100 0154 	add.w	r1, r0, #84	; 0x54
 8003296:	6043      	str	r3, [r0, #4]
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 8003298:	7202      	strb	r2, [r0, #8]
  iqObjectInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
 800329a:	4b0a      	ldr	r3, [pc, #40]	; (80032c4 <sduObjectInit+0x44>)
 800329c:	300c      	adds	r0, #12
 800329e:	f44f 7280 	mov.w	r2, #256	; 0x100
 80032a2:	f7ff faed 	bl	8002880 <chIQObjectInit>
  oqObjectInit(&sdup->oqueue, sdup->ob, SERIAL_USB_BUFFERS_SIZE, onotify, sdup);
 80032a6:	9400      	str	r4, [sp, #0]
 80032a8:	f504 71aa 	add.w	r1, r4, #340	; 0x154
 80032ac:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80032b0:	4b05      	ldr	r3, [pc, #20]	; (80032c8 <sduObjectInit+0x48>)
 80032b2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80032b6:	f7ff fb8b 	bl	80029d0 <chOQObjectInit>
}
 80032ba:	b002      	add	sp, #8
 80032bc:	bd10      	pop	{r4, pc}
 80032be:	bf00      	nop
 80032c0:	0800a480 	.word	0x0800a480
 80032c4:	08003181 	.word	0x08003181
 80032c8:	08003121 	.word	0x08003121
 80032cc:	00000000 	.word	0x00000000

080032d0 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 80032d0:	680b      	ldr	r3, [r1, #0]
 80032d2:	2220      	movs	r2, #32
 80032d4:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80032d8:	790a      	ldrb	r2, [r1, #4]
 80032da:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80032de:	6190      	str	r0, [r2, #24]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80032e0:	794a      	ldrb	r2, [r1, #5]
 80032e2:	3209      	adds	r2, #9
 80032e4:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 80032e8:	798a      	ldrb	r2, [r1, #6]
 80032ea:	b112      	cbz	r2, 80032f2 <sduStart+0x22>
    usbp->in_params[config->int_in - 1U]  = sdup;
 80032ec:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80032f0:	6198      	str	r0, [r3, #24]
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 80032f2:	2302      	movs	r3, #2
 80032f4:	7203      	strb	r3, [r0, #8]
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 80032f6:	f8c0 1254 	str.w	r1, [r0, #596]	; 0x254
 80032fa:	2300      	movs	r3, #0
 80032fc:	f383 8811 	msr	BASEPRI, r3
 8003300:	4770      	bx	lr
 8003302:	bf00      	nop
	...

08003310 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8003310:	b570      	push	{r4, r5, r6, lr}
  USBDriver *usbp = sdup->config->usbp;
 8003312:	f8d0 3254 	ldr.w	r3, [r0, #596]	; 0x254

  iqResetI(&sdup->iqueue);
 8003316:	f100 060c 	add.w	r6, r0, #12
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800331a:	4604      	mov	r4, r0
  USBDriver *usbp = sdup->config->usbp;

  iqResetI(&sdup->iqueue);
 800331c:	4630      	mov	r0, r6
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
  USBDriver *usbp = sdup->config->usbp;
 800331e:	681d      	ldr	r5, [r3, #0]

  iqResetI(&sdup->iqueue);
 8003320:	f7ff fabe 	bl	80028a0 <chIQResetI>
  oqResetI(&sdup->oqueue);
 8003324:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8003328:	f7ff fb62 	bl	80029f0 <chOQResetI>
 800332c:	1d20      	adds	r0, r4, #4
 800332e:	2101      	movs	r1, #1
 8003330:	f7ff f816 	bl	8002360 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 8003334:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 8003338:	7959      	ldrb	r1, [r3, #5]
 800333a:	eb05 0381 	add.w	r3, r5, r1, lsl #2
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 800333e:	4628      	mov	r0, r5
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 8003340:	68db      	ldr	r3, [r3, #12]
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 8003342:	4632      	mov	r2, r6
 8003344:	8a5b      	ldrh	r3, [r3, #18]
 8003346:	f000 f95b 	bl	8003600 <usbPrepareQueuedReceive>
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 800334a:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800334e:	4628      	mov	r0, r5
 8003350:	7959      	ldrb	r1, [r3, #5]
}
 8003352:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 8003356:	f000 b973 	b.w	8003640 <usbStartReceiveI>
 800335a:	bf00      	nop
 800335c:	0000      	movs	r0, r0
	...

08003360 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8003360:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8003364:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8003368:	2b20      	cmp	r3, #32
 800336a:	d001      	beq.n	8003370 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800336c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800336e:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 8003370:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8003374:	2b21      	cmp	r3, #33	; 0x21
 8003376:	d003      	beq.n	8003380 <sduRequestsHook+0x20>
 8003378:	2b22      	cmp	r3, #34	; 0x22
 800337a:	d009      	beq.n	8003390 <sduRequestsHook+0x30>
 800337c:	2b20      	cmp	r3, #32
 800337e:	d1f5      	bne.n	800336c <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8003380:	4b06      	ldr	r3, [pc, #24]	; (800339c <sduRequestsHook+0x3c>)
 8003382:	6383      	str	r3, [r0, #56]	; 0x38
 8003384:	2207      	movs	r2, #7
 8003386:	2300      	movs	r3, #0
 8003388:	63c2      	str	r2, [r0, #60]	; 0x3c
 800338a:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800338c:	2001      	movs	r0, #1
 800338e:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003390:	2300      	movs	r3, #0
 8003392:	6383      	str	r3, [r0, #56]	; 0x38
 8003394:	63c3      	str	r3, [r0, #60]	; 0x3c
 8003396:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 8003398:	2001      	movs	r0, #1
 800339a:	4770      	bx	lr
 800339c:	20000800 	.word	0x20000800

080033a0 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80033a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80033a2:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 80033a6:	699c      	ldr	r4, [r3, #24]

  if (sdup == NULL) {
 80033a8:	b1bc      	cbz	r4, 80033da <sduDataTransmitted+0x3a>
 80033aa:	460e      	mov	r6, r1
 80033ac:	4605      	mov	r5, r0
 80033ae:	2720      	movs	r7, #32
 80033b0:	f387 8811 	msr	BASEPRI, r7
 80033b4:	2108      	movs	r1, #8
 80033b6:	1d20      	adds	r0, r4, #4
 80033b8:	f7fe ffd2 	bl	8002360 <chEvtBroadcastFlagsI>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 80033bc:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80033be:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80033c0:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80033c2:	1ad3      	subs	r3, r2, r3

  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 80033c4:	1a5b      	subs	r3, r3, r1
 80033c6:	d110      	bne.n	80033ea <sduDataTransmitted+0x4a>
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80033c8:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 80033cc:	68db      	ldr	r3, [r3, #12]
 80033ce:	695a      	ldr	r2, [r3, #20]
 80033d0:	6852      	ldr	r2, [r2, #4]
 80033d2:	b91a      	cbnz	r2, 80033dc <sduDataTransmitted+0x3c>
 80033d4:	2300      	movs	r3, #0
 80033d6:	f383 8811 	msr	BASEPRI, r3
 80033da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80033dc:	8a1b      	ldrh	r3, [r3, #16]
 80033de:	3b01      	subs	r3, #1
 80033e0:	4013      	ands	r3, r2
 80033e2:	d1f7      	bne.n	80033d4 <sduDataTransmitted+0x34>
 80033e4:	f383 8811 	msr	BASEPRI, r3
 80033e8:	e002      	b.n	80033f0 <sduDataTransmitted+0x50>
 80033ea:	2200      	movs	r2, #0
 80033ec:	f382 8811 	msr	BASEPRI, r2
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);
 80033f0:	f104 0230 	add.w	r2, r4, #48	; 0x30
 80033f4:	4631      	mov	r1, r6
 80033f6:	4628      	mov	r0, r5
 80033f8:	f000 f912 	bl	8003620 <usbPrepareQueuedTransmit>
 80033fc:	f387 8811 	msr	BASEPRI, r7

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
 8003400:	4631      	mov	r1, r6
 8003402:	4628      	mov	r0, r5
 8003404:	f000 f934 	bl	8003670 <usbStartTransmitI>
 8003408:	e7e4      	b.n	80033d4 <sduDataTransmitted+0x34>
 800340a:	bf00      	nop
 800340c:	0000      	movs	r0, r0
	...

08003410 <sduDataReceived>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8003410:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8003414:	f101 0309 	add.w	r3, r1, #9
 8003418:	f850 6023 	ldr.w	r6, [r0, r3, lsl #2]

  if (sdup == NULL) {
 800341c:	b1be      	cbz	r6, 800344e <sduDataReceived+0x3e>
 800341e:	4680      	mov	r8, r0
 8003420:	460f      	mov	r7, r1
 8003422:	f04f 0920 	mov.w	r9, #32
 8003426:	f389 8811 	msr	BASEPRI, r9
 800342a:	2104      	movs	r1, #4
 800342c:	1870      	adds	r0, r6, r1
 800342e:	f7fe ff97 	bl	8002360 <chEvtBroadcastFlagsI>
  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Writes to the input queue can only happen when there is enough space
     to hold at least one packet.*/
  maxsize = usbp->epc[ep]->out_maxsize;
 8003432:	eb08 0387 	add.w	r3, r8, r7, lsl #2
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 8003436:	69b4      	ldr	r4, [r6, #24]
 8003438:	68da      	ldr	r2, [r3, #12]
 800343a:	69f5      	ldr	r5, [r6, #28]
 800343c:	6973      	ldr	r3, [r6, #20]
 800343e:	8a51      	ldrh	r1, [r2, #18]
 8003440:	1b2d      	subs	r5, r5, r4
 8003442:	1aec      	subs	r4, r5, r3
  if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 8003444:	42a1      	cmp	r1, r4
 8003446:	d904      	bls.n	8003452 <sduDataReceived+0x42>
 8003448:	2300      	movs	r3, #0
 800344a:	f383 8811 	msr	BASEPRI, r3
 800344e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003452:	2300      	movs	r3, #0
 8003454:	f383 8811 	msr	BASEPRI, r3
    /* The endpoint cannot be busy, we are in the context of the callback,
       so a packet is in the buffer for sure.*/
    osalSysUnlockFromISR();

    n = (n / maxsize) * maxsize;
    usbPrepareQueuedReceive(usbp, ep, &sdup->iqueue, n);
 8003458:	fbb4 f3f1 	udiv	r3, r4, r1
 800345c:	f106 020c 	add.w	r2, r6, #12
 8003460:	fb01 f303 	mul.w	r3, r1, r3
 8003464:	4640      	mov	r0, r8
 8003466:	4639      	mov	r1, r7
 8003468:	f000 f8ca 	bl	8003600 <usbPrepareQueuedReceive>
 800346c:	f389 8811 	msr	BASEPRI, r9

    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, ep);
 8003470:	4639      	mov	r1, r7
 8003472:	4640      	mov	r0, r8
 8003474:	f000 f8e4 	bl	8003640 <usbStartReceiveI>
 8003478:	e7e6      	b.n	8003448 <sduDataReceived+0x38>
 800347a:	bf00      	nop
 800347c:	0000      	movs	r0, r0
	...

08003480 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8003480:	4770      	bx	lr
 8003482:	bf00      	nop
	...

08003490 <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
 8003490:	f001 bf5e 	b.w	8005350 <spi_lld_init>
	...

080034a0 <spiObjectInit>:
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
  spip->config = NULL;
 80034a0:	2300      	movs	r3, #0
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 80034a2:	2201      	movs	r2, #1
 80034a4:	7002      	strb	r2, [r0, #0]
  spip->config = NULL;
 80034a6:	6043      	str	r3, [r0, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80034a8:	6083      	str	r3, [r0, #8]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80034aa:	300c      	adds	r0, #12
 80034ac:	f7fe bd10 	b.w	8001ed0 <chMtxObjectInit>

080034b0 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 80034b0:	b510      	push	{r4, lr}
 80034b2:	2320      	movs	r3, #32
 80034b4:	4604      	mov	r4, r0
 80034b6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 80034ba:	6041      	str	r1, [r0, #4]
  spi_lld_start(spip);
 80034bc:	f001 ff80 	bl	80053c0 <spi_lld_start>
  spip->state = SPI_READY;
 80034c0:	2302      	movs	r3, #2
 80034c2:	7023      	strb	r3, [r4, #0]
 80034c4:	2300      	movs	r3, #0
 80034c6:	f383 8811 	msr	BASEPRI, r3
 80034ca:	bd10      	pop	{r4, pc}
 80034cc:	0000      	movs	r0, r0
	...

080034d0 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 80034d0:	b508      	push	{r3, lr}
 80034d2:	2320      	movs	r3, #32
 80034d4:	f383 8811 	msr	BASEPRI, r3

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 80034d8:	f001 ffda 	bl	8005490 <spi_lld_select>
 80034dc:	2300      	movs	r3, #0
 80034de:	f383 8811 	msr	BASEPRI, r3
 80034e2:	bd08      	pop	{r3, pc}
	...

080034f0 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 80034f0:	b508      	push	{r3, lr}
 80034f2:	2320      	movs	r3, #32
 80034f4:	f383 8811 	msr	BASEPRI, r3

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 80034f8:	f001 ffd2 	bl	80054a0 <spi_lld_unselect>
 80034fc:	2300      	movs	r3, #0
 80034fe:	f383 8811 	msr	BASEPRI, r3
 8003502:	bd08      	pop	{r3, pc}
	...

08003510 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8003510:	b538      	push	{r3, r4, r5, lr}
 8003512:	4604      	mov	r4, r0
 8003514:	2520      	movs	r5, #32
 8003516:	f385 8811 	msr	BASEPRI, r5
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 800351a:	2503      	movs	r5, #3
 800351c:	f804 5b08 	strb.w	r5, [r4], #8
 8003520:	f001 ffc6 	bl	80054b0 <spi_lld_exchange>
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 8003524:	4620      	mov	r0, r4
 8003526:	f7fe fa5b 	bl	80019e0 <chThdSuspendS>
 800352a:	2300      	movs	r3, #0
 800352c:	f383 8811 	msr	BASEPRI, r3
 8003530:	bd38      	pop	{r3, r4, r5, pc}
 8003532:	bf00      	nop
	...

08003540 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8003540:	b510      	push	{r4, lr}
 8003542:	2320      	movs	r3, #32
 8003544:	4604      	mov	r4, r0
 8003546:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 800354a:	2303      	movs	r3, #3
 800354c:	f804 3b08 	strb.w	r3, [r4], #8
 8003550:	f001 ffce 	bl	80054f0 <spi_lld_send>
 8003554:	4620      	mov	r0, r4
 8003556:	f7fe fa43 	bl	80019e0 <chThdSuspendS>
 800355a:	2300      	movs	r3, #0
 800355c:	f383 8811 	msr	BASEPRI, r3
 8003560:	bd10      	pop	{r4, pc}
 8003562:	bf00      	nop
	...

08003570 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 8003570:	f001 baae 	b.w	8004ad0 <usb_lld_init>
	...

08003580 <usbObjectInit>:
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8003580:	2300      	movs	r3, #0
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8003582:	2201      	movs	r2, #1
 8003584:	7002      	strb	r2, [r0, #0]
  usbp->config       = NULL;
 8003586:	6043      	str	r3, [r0, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8003588:	61c3      	str	r3, [r0, #28]
    usbp->out_params[i] = NULL;
 800358a:	6283      	str	r3, [r0, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800358c:	6203      	str	r3, [r0, #32]
    usbp->out_params[i] = NULL;
 800358e:	62c3      	str	r3, [r0, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8003590:	6243      	str	r3, [r0, #36]	; 0x24
    usbp->out_params[i] = NULL;
 8003592:	6303      	str	r3, [r0, #48]	; 0x30
  }
  usbp->transmitting = 0;
 8003594:	8103      	strh	r3, [r0, #8]
  usbp->receiving    = 0;
 8003596:	8143      	strh	r3, [r0, #10]
 8003598:	4770      	bx	lr
 800359a:	bf00      	nop
 800359c:	0000      	movs	r0, r0
	...

080035a0 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 80035a0:	b538      	push	{r3, r4, r5, lr}
 80035a2:	4604      	mov	r4, r0
 80035a4:	2320      	movs	r3, #32
 80035a6:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80035aa:	2500      	movs	r5, #0
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 80035ac:	6041      	str	r1, [r0, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80035ae:	60c5      	str	r5, [r0, #12]
 80035b0:	6105      	str	r5, [r0, #16]
 80035b2:	6145      	str	r5, [r0, #20]
 80035b4:	6185      	str	r5, [r0, #24]
  }
  usb_lld_start(usbp);
 80035b6:	f001 faa3 	bl	8004b00 <usb_lld_start>
  usbp->state = USB_READY;
 80035ba:	2302      	movs	r3, #2
 80035bc:	7023      	strb	r3, [r4, #0]
 80035be:	f385 8811 	msr	BASEPRI, r5
 80035c2:	bd38      	pop	{r3, r4, r5, pc}
	...

080035d0 <usbInitEndpointI>:
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 80035d0:	6953      	ldr	r3, [r2, #20]
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 80035d2:	b410      	push	{r4}
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 80035d4:	b12b      	cbz	r3, 80035e2 <usbInitEndpointI+0x12>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80035d6:	2400      	movs	r4, #0
 80035d8:	601c      	str	r4, [r3, #0]
 80035da:	605c      	str	r4, [r3, #4]
 80035dc:	609c      	str	r4, [r3, #8]
 80035de:	60dc      	str	r4, [r3, #12]
 80035e0:	611c      	str	r4, [r3, #16]
  }
  if (epcp->out_state != NULL) {
 80035e2:	6993      	ldr	r3, [r2, #24]
 80035e4:	b12b      	cbz	r3, 80035f2 <usbInitEndpointI+0x22>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80035e6:	2400      	movs	r4, #0
 80035e8:	601c      	str	r4, [r3, #0]
 80035ea:	605c      	str	r4, [r3, #4]
 80035ec:	609c      	str	r4, [r3, #8]
 80035ee:	60dc      	str	r4, [r3, #12]
 80035f0:	611c      	str	r4, [r3, #16]
  }

  usbp->epc[ep] = epcp;
 80035f2:	eb00 0381 	add.w	r3, r0, r1, lsl #2

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
}
 80035f6:	bc10      	pop	{r4}
  }
  if (epcp->out_state != NULL) {
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  }

  usbp->epc[ep] = epcp;
 80035f8:	60da      	str	r2, [r3, #12]

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 80035fa:	f001 bb71 	b.w	8004ce0 <usb_lld_init_endpoint>
 80035fe:	bf00      	nop

08003600 <usbPrepareQueuedReceive>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
 8003600:	b470      	push	{r4, r5, r6}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003602:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  osp->rxqueued           = true;
 8003606:	2601      	movs	r6, #1
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003608:	68e4      	ldr	r4, [r4, #12]
 800360a:	69a4      	ldr	r4, [r4, #24]

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800360c:	2500      	movs	r5, #0
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
 800360e:	60e2      	str	r2, [r4, #12]
  osp->rxsize             = n;
 8003610:	6063      	str	r3, [r4, #4]
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 8003612:	7026      	strb	r6, [r4, #0]
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 8003614:	60a5      	str	r5, [r4, #8]

  usb_lld_prepare_receive(usbp, ep);
}
 8003616:	bc70      	pop	{r4, r5, r6}
  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8003618:	f001 bc4a 	b.w	8004eb0 <usb_lld_prepare_receive>
 800361c:	0000      	movs	r0, r0
	...

08003620 <usbPrepareQueuedTransmit>:
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
 8003620:	b470      	push	{r4, r5, r6}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003622:	eb00 0481 	add.w	r4, r0, r1, lsl #2

  isp->txqueued           = true;
 8003626:	2601      	movs	r6, #1
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003628:	68e4      	ldr	r4, [r4, #12]
 800362a:	6964      	ldr	r4, [r4, #20]

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800362c:	2500      	movs	r5, #0
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
 800362e:	60e2      	str	r2, [r4, #12]
  isp->txsize             = n;
 8003630:	6063      	str	r3, [r4, #4]
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
 8003632:	7026      	strb	r6, [r4, #0]
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 8003634:	60a5      	str	r5, [r4, #8]

  usb_lld_prepare_transmit(usbp, ep);
}
 8003636:	bc70      	pop	{r4, r5, r6}
  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8003638:	f001 bcba 	b.w	8004fb0 <usb_lld_prepare_transmit>
 800363c:	0000      	movs	r0, r0
	...

08003640 <usbStartReceiveI>:
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8003640:	2201      	movs	r2, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 8003642:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8003644:	fa02 f301 	lsl.w	r3, r2, r1
 8003648:	8944      	ldrh	r4, [r0, #10]
 800364a:	b29b      	uxth	r3, r3
 800364c:	ea14 0603 	ands.w	r6, r4, r3
 8003650:	d001      	beq.n	8003656 <usbStartReceiveI+0x16>
    return true;
 8003652:	4610      	mov	r0, r2
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 8003654:	bd70      	pop	{r4, r5, r6, pc}

  if (usbGetReceiveStatusI(usbp, ep)) {
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003656:	4323      	orrs	r3, r4
 8003658:	8143      	strh	r3, [r0, #10]
  usb_lld_start_out(usbp, ep);
 800365a:	f001 fdc1 	bl	80051e0 <usb_lld_start_out>
  return false;
 800365e:	4630      	mov	r0, r6
 8003660:	bd70      	pop	{r4, r5, r6, pc}
 8003662:	bf00      	nop
	...

08003670 <usbStartTransmitI>:
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8003670:	2201      	movs	r2, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 8003672:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8003674:	fa02 f301 	lsl.w	r3, r2, r1
 8003678:	8904      	ldrh	r4, [r0, #8]
 800367a:	b29b      	uxth	r3, r3
 800367c:	ea14 0603 	ands.w	r6, r4, r3
 8003680:	d001      	beq.n	8003686 <usbStartTransmitI+0x16>
    return true;
 8003682:	4610      	mov	r0, r2
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 8003684:	bd70      	pop	{r4, r5, r6, pc}

  if (usbGetTransmitStatusI(usbp, ep)) {
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003686:	4323      	orrs	r3, r4
 8003688:	8103      	strh	r3, [r0, #8]
  usb_lld_start_in(usbp, ep);
 800368a:	f001 fdb9 	bl	8005200 <usb_lld_start_in>
  return false;
 800368e:	4630      	mov	r0, r6
 8003690:	bd70      	pop	{r4, r5, r6, pc}
 8003692:	bf00      	nop
	...

080036a0 <_usb_reset>:
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
  usbp->status        = 0;
 80036a0:	2200      	movs	r2, #0
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
 80036a2:	2102      	movs	r1, #2
 80036a4:	7001      	strb	r1, [r0, #0]
  usbp->status        = 0;
 80036a6:	f8a0 204c 	strh.w	r2, [r0, #76]	; 0x4c
  usbp->address       = 0;
 80036aa:	f880 204e 	strb.w	r2, [r0, #78]	; 0x4e
  usbp->configuration = 0;
 80036ae:	f880 204f 	strb.w	r2, [r0, #79]	; 0x4f
  usbp->transmitting  = 0;
 80036b2:	8102      	strh	r2, [r0, #8]
  usbp->receiving     = 0;
 80036b4:	8142      	strh	r2, [r0, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80036b6:	60c2      	str	r2, [r0, #12]
 80036b8:	6102      	str	r2, [r0, #16]
 80036ba:	6142      	str	r2, [r0, #20]
 80036bc:	6182      	str	r2, [r0, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80036be:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

  /* Low level reset.*/
  usb_lld_reset(usbp);
 80036c2:	f001 ba95 	b.w	8004bf0 <usb_lld_reset>
 80036c6:	bf00      	nop
	...

080036d0 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80036d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80036d2:	2300      	movs	r3, #0
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80036d4:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80036d6:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  usbReadSetup(usbp, ep, usbp->setup);
 80036da:	f100 0244 	add.w	r2, r0, #68	; 0x44
 80036de:	f001 fbd7 	bl	8004e90 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80036e2:	6863      	ldr	r3, [r4, #4]
 80036e4:	689b      	ldr	r3, [r3, #8]
 80036e6:	2b00      	cmp	r3, #0
 80036e8:	d036      	beq.n	8003758 <_usb_ep0setup+0x88>
      !(usbp->config->requests_hook_cb(usbp))) {
 80036ea:	4620      	mov	r0, r4
 80036ec:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80036ee:	2800      	cmp	r0, #0
 80036f0:	d032      	beq.n	8003758 <_usb_ep0setup+0x88>
 80036f2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80036f4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80036f8:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 80036fc:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
 8003700:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8003704:	4282      	cmp	r2, r0
    usbp->ep0n = max;
 8003706:	bf3c      	itt	cc
 8003708:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 800370a:	4610      	movcc	r0, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800370c:	061a      	lsls	r2, r3, #24
 800370e:	f100 80ab 	bmi.w	8003868 <_usb_ep0setup+0x198>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8003712:	2800      	cmp	r0, #0
 8003714:	f000 808b 	beq.w	800382e <_usb_ep0setup+0x15e>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003718:	68e3      	ldr	r3, [r4, #12]
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 800371a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800371c:	699b      	ldr	r3, [r3, #24]

  osp->rxqueued           = false;
 800371e:	2200      	movs	r2, #0
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8003720:	2104      	movs	r1, #4
 8003722:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8003726:	4611      	mov	r1, r2
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
 8003728:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 800372a:	6058      	str	r0, [r3, #4]
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800372c:	701a      	strb	r2, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800372e:	609a      	str	r2, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8003730:	4620      	mov	r0, r4
 8003732:	f001 fbbd 	bl	8004eb0 <usb_lld_prepare_receive>
 8003736:	2320      	movs	r3, #32
 8003738:	f383 8811 	msr	BASEPRI, r3
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 800373c:	8963      	ldrh	r3, [r4, #10]
 800373e:	f013 0101 	ands.w	r1, r3, #1
 8003742:	d105      	bne.n	8003750 <_usb_ep0setup+0x80>
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003744:	f043 0301 	orr.w	r3, r3, #1
 8003748:	8163      	strh	r3, [r4, #10]
  usb_lld_start_out(usbp, ep);
 800374a:	4620      	mov	r0, r4
 800374c:	f001 fd48 	bl	80051e0 <usb_lld_start_out>
 8003750:	2300      	movs	r3, #0
 8003752:	f383 8811 	msr	BASEPRI, r3
 8003756:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8003758:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800375c:	f013 0760 	ands.w	r7, r3, #96	; 0x60
 8003760:	461e      	mov	r6, r3
 8003762:	d011      	beq.n	8003788 <_usb_ep0setup+0xb8>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8003764:	2100      	movs	r1, #0
 8003766:	4620      	mov	r0, r4
 8003768:	f001 fd72 	bl	8005250 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800376c:	2100      	movs	r1, #0
 800376e:	4620      	mov	r0, r4
 8003770:	f001 fd5e 	bl	8005230 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8003774:	6863      	ldr	r3, [r4, #4]
 8003776:	681b      	ldr	r3, [r3, #0]
 8003778:	b113      	cbz	r3, 8003780 <_usb_ep0setup+0xb0>
 800377a:	2105      	movs	r1, #5
 800377c:	4620      	mov	r0, r4
 800377e:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8003780:	2306      	movs	r3, #6
 8003782:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return;
 8003786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003788:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
 800378c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8003790:	ea42 2500 	orr.w	r5, r2, r0, lsl #8
 8003794:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 8003798:	f000 80eb 	beq.w	8003972 <_usb_ep0setup+0x2a2>
 800379c:	d916      	bls.n	80037cc <_usb_ep0setup+0xfc>
 800379e:	f5b5 6fc0 	cmp.w	r5, #1536	; 0x600
 80037a2:	f000 80ce 	beq.w	8003942 <_usb_ep0setup+0x272>
 80037a6:	d92f      	bls.n	8003808 <_usb_ep0setup+0x138>
 80037a8:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 80037ac:	d076      	beq.n	800389c <_usb_ep0setup+0x1cc>
 80037ae:	f640 4202 	movw	r2, #3074	; 0xc02
 80037b2:	4295      	cmp	r5, r2
 80037b4:	f000 80ef 	beq.w	8003996 <_usb_ep0setup+0x2c6>
 80037b8:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80037bc:	d1d2      	bne.n	8003764 <_usb_ep0setup+0x94>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80037be:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 80037c2:	2001      	movs	r0, #1
 80037c4:	6427      	str	r7, [r4, #64]	; 0x40
 80037c6:	63a2      	str	r2, [r4, #56]	; 0x38
 80037c8:	63e0      	str	r0, [r4, #60]	; 0x3c
 80037ca:	e795      	b.n	80036f8 <_usb_ep0setup+0x28>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80037cc:	2d02      	cmp	r5, #2
 80037ce:	f000 80a2 	beq.w	8003916 <_usb_ep0setup+0x246>
 80037d2:	f240 8097 	bls.w	8003904 <_usb_ep0setup+0x234>
 80037d6:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 80037da:	f000 8084 	beq.w	80038e6 <_usb_ep0setup+0x216>
 80037de:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 80037e2:	d1bf      	bne.n	8003764 <_usb_ep0setup+0x94>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80037e4:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80037e8:	2b00      	cmp	r3, #0
 80037ea:	d1bb      	bne.n	8003764 <_usb_ep0setup+0x94>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80037ec:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 80037f0:	f013 010f 	ands.w	r1, r3, #15
 80037f4:	d015      	beq.n	8003822 <_usb_ep0setup+0x152>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80037f6:	061e      	lsls	r6, r3, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80037f8:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80037fa:	f100 80f4 	bmi.w	80039e6 <_usb_ep0setup+0x316>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 80037fe:	f001 fd37 	bl	8005270 <usb_lld_clear_out>
 8003802:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 8003806:	e00c      	b.n	8003822 <_usb_ep0setup+0x152>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003808:	f240 3302 	movw	r3, #770	; 0x302
 800380c:	429d      	cmp	r5, r3
 800380e:	d057      	beq.n	80038c0 <_usb_ep0setup+0x1f0>
 8003810:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 8003814:	d1a6      	bne.n	8003764 <_usb_ep0setup+0x94>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8003816:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
 800381a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800381e:	f000 80d0 	beq.w	80039c2 <_usb_ep0setup+0x2f2>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003822:	2300      	movs	r3, #0
 8003824:	63a3      	str	r3, [r4, #56]	; 0x38
 8003826:	63e3      	str	r3, [r4, #60]	; 0x3c
 8003828:	6423      	str	r3, [r4, #64]	; 0x40
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800382a:	0633      	lsls	r3, r6, #24
 800382c:	d42a      	bmi.n	8003884 <_usb_ep0setup+0x1b4>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800382e:	68e3      	ldr	r3, [r4, #12]
 8003830:	695a      	ldr	r2, [r3, #20]
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8003832:	2105      	movs	r1, #5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8003834:	2300      	movs	r3, #0
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8003836:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800383a:	4619      	mov	r1, r3
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800383c:	7013      	strb	r3, [r2, #0]
  isp->mode.linear.txbuf  = buf;
 800383e:	60d3      	str	r3, [r2, #12]
  isp->txsize             = n;
 8003840:	6053      	str	r3, [r2, #4]
  isp->txcnt              = 0;
 8003842:	6093      	str	r3, [r2, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8003844:	4620      	mov	r0, r4
 8003846:	f001 fbb3 	bl	8004fb0 <usb_lld_prepare_transmit>
 800384a:	2320      	movs	r3, #32
 800384c:	f383 8811 	msr	BASEPRI, r3
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8003850:	8923      	ldrh	r3, [r4, #8]
 8003852:	f013 0101 	ands.w	r1, r3, #1
 8003856:	f47f af7b 	bne.w	8003750 <_usb_ep0setup+0x80>
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800385a:	f043 0301 	orr.w	r3, r3, #1
 800385e:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 8003860:	4620      	mov	r0, r4
 8003862:	f001 fccd 	bl	8005200 <usb_lld_start_in>
 8003866:	e773      	b.n	8003750 <_usb_ep0setup+0x80>
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8003868:	b160      	cbz	r0, 8003884 <_usb_ep0setup+0x1b4>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800386a:	68e3      	ldr	r3, [r4, #12]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 800386c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800386e:	695b      	ldr	r3, [r3, #20]

  isp->txqueued           = false;
 8003870:	2200      	movs	r2, #0
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8003872:	2101      	movs	r1, #1
 8003874:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8003878:	4611      	mov	r1, r2
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
 800387a:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800387c:	6058      	str	r0, [r3, #4]
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800387e:	701a      	strb	r2, [r3, #0]
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;
 8003880:	609a      	str	r2, [r3, #8]
 8003882:	e7df      	b.n	8003844 <_usb_ep0setup+0x174>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003884:	68e3      	ldr	r3, [r4, #12]
 8003886:	699a      	ldr	r2, [r3, #24]
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8003888:	2103      	movs	r1, #3
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800388a:	2300      	movs	r3, #0
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 800388c:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8003890:	4619      	mov	r1, r3
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8003892:	7013      	strb	r3, [r2, #0]
  osp->mode.linear.rxbuf  = buf;
 8003894:	60d3      	str	r3, [r2, #12]
  osp->rxsize             = n;
 8003896:	6053      	str	r3, [r2, #4]
  osp->rxcnt              = 0;
 8003898:	6093      	str	r3, [r2, #8]
 800389a:	e749      	b.n	8003730 <_usb_ep0setup+0x60>
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 800389c:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80038a0:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 80038a4:	2b00      	cmp	r3, #0
 80038a6:	d17d      	bne.n	80039a4 <_usb_ep0setup+0x2d4>
      usbp->state = USB_SELECTED;
 80038a8:	2303      	movs	r3, #3
 80038aa:	7023      	strb	r3, [r4, #0]
    }
    else {
      usbp->state = USB_ACTIVE;
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80038ac:	6863      	ldr	r3, [r4, #4]
 80038ae:	681b      	ldr	r3, [r3, #0]
 80038b0:	2b00      	cmp	r3, #0
 80038b2:	d0b6      	beq.n	8003822 <_usb_ep0setup+0x152>
 80038b4:	2102      	movs	r1, #2
 80038b6:	4620      	mov	r0, r4
 80038b8:	4798      	blx	r3
 80038ba:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 80038be:	e7b0      	b.n	8003822 <_usb_ep0setup+0x152>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80038c0:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80038c4:	2b00      	cmp	r3, #0
 80038c6:	f47f af4d 	bne.w	8003764 <_usb_ep0setup+0x94>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80038ca:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 80038ce:	f013 010f 	ands.w	r1, r3, #15
 80038d2:	d0a6      	beq.n	8003822 <_usb_ep0setup+0x152>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80038d4:	061d      	lsls	r5, r3, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 80038d6:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80038d8:	f100 808a 	bmi.w	80039f0 <_usb_ep0setup+0x320>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 80038dc:	f001 fca8 	bl	8005230 <usb_lld_stall_out>
 80038e0:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 80038e4:	e79d      	b.n	8003822 <_usb_ep0setup+0x152>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80038e6:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80038ea:	2b01      	cmp	r3, #1
 80038ec:	f47f af3a 	bne.w	8003764 <_usb_ep0setup+0x94>
      usbp->status &= ~2U;
 80038f0:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80038f4:	63a7      	str	r7, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 80038f6:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80038fa:	63e7      	str	r7, [r4, #60]	; 0x3c
 80038fc:	6427      	str	r7, [r4, #64]	; 0x40
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 80038fe:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 8003902:	e792      	b.n	800382a <_usb_ep0setup+0x15a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003904:	2d00      	cmp	r5, #0
 8003906:	d143      	bne.n	8003990 <_usb_ep0setup+0x2c0>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8003908:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 800390c:	2002      	movs	r0, #2
 800390e:	6425      	str	r5, [r4, #64]	; 0x40
 8003910:	63a2      	str	r2, [r4, #56]	; 0x38
 8003912:	63e0      	str	r0, [r4, #60]	; 0x3c
 8003914:	e6f0      	b.n	80036f8 <_usb_ep0setup+0x28>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8003916:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
 800391a:	f011 0f80 	tst.w	r1, #128	; 0x80
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800391e:	4620      	mov	r0, r4
 8003920:	f001 010f 	and.w	r1, r1, #15
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8003924:	d141      	bne.n	80039aa <_usb_ep0setup+0x2da>
      default:
        return false;
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8003926:	f001 fa93 	bl	8004e50 <usb_lld_get_status_out>
 800392a:	2801      	cmp	r0, #1
 800392c:	d041      	beq.n	80039b2 <_usb_ep0setup+0x2e2>
 800392e:	2802      	cmp	r0, #2
 8003930:	f47f af18 	bne.w	8003764 <_usb_ep0setup+0x94>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003934:	4b31      	ldr	r3, [pc, #196]	; (80039fc <_usb_ep0setup+0x32c>)
 8003936:	63a3      	str	r3, [r4, #56]	; 0x38
 8003938:	63e0      	str	r0, [r4, #60]	; 0x3c
 800393a:	6427      	str	r7, [r4, #64]	; 0x40
 800393c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8003940:	e6da      	b.n	80036f8 <_usb_ep0setup+0x28>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8003942:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 8003946:	6861      	ldr	r1, [r4, #4]
 8003948:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 800394c:	684d      	ldr	r5, [r1, #4]
 800394e:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8003952:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 8003956:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800395a:	4620      	mov	r0, r4
 800395c:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 800395e:	2800      	cmp	r0, #0
 8003960:	f43f af00 	beq.w	8003764 <_usb_ep0setup+0x94>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8003964:	c809      	ldmia	r0, {r0, r3}
 8003966:	6427      	str	r7, [r4, #64]	; 0x40
 8003968:	63a3      	str	r3, [r4, #56]	; 0x38
 800396a:	63e0      	str	r0, [r4, #60]	; 0x3c
 800396c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8003970:	e6c2      	b.n	80036f8 <_usb_ep0setup+0x28>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8003972:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8003976:	2b01      	cmp	r3, #1
 8003978:	f47f aef4 	bne.w	8003764 <_usb_ep0setup+0x94>
      usbp->status |= 2U;
 800397c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003980:	63a7      	str	r7, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8003982:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003986:	63e7      	str	r7, [r4, #60]	; 0x3c
 8003988:	6427      	str	r7, [r4, #64]	; 0x40
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800398a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800398e:	e74c      	b.n	800382a <_usb_ep0setup+0x15a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003990:	2d01      	cmp	r5, #1
 8003992:	f47f aee7 	bne.w	8003764 <_usb_ep0setup+0x94>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8003996:	4a1a      	ldr	r2, [pc, #104]	; (8003a00 <_usb_ep0setup+0x330>)
 8003998:	63a2      	str	r2, [r4, #56]	; 0x38
 800399a:	2002      	movs	r0, #2
 800399c:	2200      	movs	r2, #0
 800399e:	63e0      	str	r0, [r4, #60]	; 0x3c
 80039a0:	6422      	str	r2, [r4, #64]	; 0x40
 80039a2:	e6a9      	b.n	80036f8 <_usb_ep0setup+0x28>
    usbp->configuration = usbp->setup[2];
    if (usbp->configuration == 0U) {
      usbp->state = USB_SELECTED;
    }
    else {
      usbp->state = USB_ACTIVE;
 80039a4:	2304      	movs	r3, #4
 80039a6:	7023      	strb	r3, [r4, #0]
 80039a8:	e780      	b.n	80038ac <_usb_ep0setup+0x1dc>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 80039aa:	f001 fa61 	bl	8004e70 <usb_lld_get_status_in>
 80039ae:	2801      	cmp	r0, #1
 80039b0:	d1bd      	bne.n	800392e <_usb_ep0setup+0x25e>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80039b2:	4b14      	ldr	r3, [pc, #80]	; (8003a04 <_usb_ep0setup+0x334>)
 80039b4:	63a3      	str	r3, [r4, #56]	; 0x38
 80039b6:	63e5      	str	r5, [r4, #60]	; 0x3c
 80039b8:	6427      	str	r7, [r4, #64]	; 0x40
 80039ba:	4628      	mov	r0, r5
 80039bc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80039c0:	e69a      	b.n	80036f8 <_usb_ep0setup+0x28>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 80039c2:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 80039c6:	f884 304e 	strb.w	r3, [r4, #78]	; 0x4e
  usb_lld_set_address(usbp);
 80039ca:	4620      	mov	r0, r4
 80039cc:	f001 f978 	bl	8004cc0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80039d0:	6863      	ldr	r3, [r4, #4]
 80039d2:	681b      	ldr	r3, [r3, #0]
 80039d4:	b113      	cbz	r3, 80039dc <_usb_ep0setup+0x30c>
 80039d6:	2101      	movs	r1, #1
 80039d8:	4620      	mov	r0, r4
 80039da:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 80039dc:	2303      	movs	r3, #3
 80039de:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 80039e2:	7023      	strb	r3, [r4, #0]
 80039e4:	e71d      	b.n	8003822 <_usb_ep0setup+0x152>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80039e6:	f001 fc53 	bl	8005290 <usb_lld_clear_in>
 80039ea:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 80039ee:	e718      	b.n	8003822 <_usb_ep0setup+0x152>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 80039f0:	f001 fc2e 	bl	8005250 <usb_lld_stall_in>
 80039f4:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 80039f8:	e713      	b.n	8003822 <_usb_ep0setup+0x152>
 80039fa:	bf00      	nop
 80039fc:	0800a4b0 	.word	0x0800a4b0
 8003a00:	0800a4a0 	.word	0x0800a4a0
 8003a04:	0800a4c0 	.word	0x0800a4c0
	...

08003a10 <_usb_ep0in>:
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8003a10:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8003a14:	b510      	push	{r4, lr}
 8003a16:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8003a18:	2b06      	cmp	r3, #6
 8003a1a:	d815      	bhi.n	8003a48 <_usb_ep0in+0x38>
 8003a1c:	e8df f003 	tbb	[pc, r3]
 8003a20:	041c3b04 	.word	0x041c3b04
 8003a24:	1504      	.short	0x1504
 8003a26:	04          	.byte	0x04
 8003a27:	00          	.byte	0x00
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8003a28:	2100      	movs	r1, #0
 8003a2a:	f001 fc11 	bl	8005250 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8003a2e:	2100      	movs	r1, #0
 8003a30:	4620      	mov	r0, r4
 8003a32:	f001 fbfd 	bl	8005230 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8003a36:	6863      	ldr	r3, [r4, #4]
 8003a38:	681b      	ldr	r3, [r3, #0]
 8003a3a:	b113      	cbz	r3, 8003a42 <_usb_ep0in+0x32>
 8003a3c:	2105      	movs	r1, #5
 8003a3e:	4620      	mov	r0, r4
 8003a40:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8003a42:	2306      	movs	r3, #6
 8003a44:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8003a48:	bd10      	pop	{r4, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8003a4a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003a4c:	b103      	cbz	r3, 8003a50 <_usb_ep0in+0x40>
      usbp->ep0endcb(usbp);
 8003a4e:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003a50:	2300      	movs	r3, #0
 8003a52:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return;
 8003a56:	bd10      	pop	{r4, pc}
 8003a58:	68c3      	ldr	r3, [r0, #12]
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003a5a:	699a      	ldr	r2, [r3, #24]
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 8003a5c:	2103      	movs	r1, #3
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8003a5e:	2300      	movs	r3, #0
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 8003a60:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8003a64:	4620      	mov	r0, r4
 8003a66:	4619      	mov	r1, r3
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8003a68:	7013      	strb	r3, [r2, #0]
  osp->mode.linear.rxbuf  = buf;
 8003a6a:	60d3      	str	r3, [r2, #12]
  osp->rxsize             = n;
 8003a6c:	6053      	str	r3, [r2, #4]
  osp->rxcnt              = 0;
 8003a6e:	6093      	str	r3, [r2, #8]

  usb_lld_prepare_receive(usbp, ep);
 8003a70:	f001 fa1e 	bl	8004eb0 <usb_lld_prepare_receive>
 8003a74:	2320      	movs	r3, #32
 8003a76:	f383 8811 	msr	BASEPRI, r3
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8003a7a:	8963      	ldrh	r3, [r4, #10]
 8003a7c:	f013 0101 	ands.w	r1, r3, #1
 8003a80:	d105      	bne.n	8003a8e <_usb_ep0in+0x7e>
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003a82:	f043 0301 	orr.w	r3, r3, #1
 8003a86:	8163      	strh	r3, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8003a88:	4620      	mov	r0, r4
 8003a8a:	f001 fba9 	bl	80051e0 <usb_lld_start_out>
 8003a8e:	2300      	movs	r3, #0
 8003a90:	f383 8811 	msr	BASEPRI, r3
 8003a94:	bd10      	pop	{r4, pc}
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8003a96:	f890 104b 	ldrb.w	r1, [r0, #75]	; 0x4b
 8003a9a:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
 8003a9e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8003aa0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8003aa4:	4293      	cmp	r3, r2
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8003aa6:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8003aa8:	d9d7      	bls.n	8003a5a <_usb_ep0in+0x4a>
 8003aaa:	8a18      	ldrh	r0, [r3, #16]
 8003aac:	fbb2 f1f0 	udiv	r1, r2, r0
 8003ab0:	fb00 2211 	mls	r2, r0, r1, r2
 8003ab4:	2a00      	cmp	r2, #0
 8003ab6:	d1d0      	bne.n	8003a5a <_usb_ep0in+0x4a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003ab8:	695b      	ldr	r3, [r3, #20]
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8003aba:	4611      	mov	r1, r2
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8003abc:	701a      	strb	r2, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8003abe:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 8003ac0:	605a      	str	r2, [r3, #4]
  isp->txcnt              = 0;
 8003ac2:	609a      	str	r2, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8003ac4:	4620      	mov	r0, r4
 8003ac6:	f001 fa73 	bl	8004fb0 <usb_lld_prepare_transmit>
 8003aca:	2320      	movs	r3, #32
 8003acc:	f383 8811 	msr	BASEPRI, r3
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8003ad0:	8923      	ldrh	r3, [r4, #8]
 8003ad2:	f013 0101 	ands.w	r1, r3, #1
 8003ad6:	d105      	bne.n	8003ae4 <_usb_ep0in+0xd4>
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003ad8:	f043 0301 	orr.w	r3, r3, #1
 8003adc:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 8003ade:	4620      	mov	r0, r4
 8003ae0:	f001 fb8e 	bl	8005200 <usb_lld_start_in>
 8003ae4:	2300      	movs	r3, #0
 8003ae6:	f383 8811 	msr	BASEPRI, r3
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8003aea:	2302      	movs	r3, #2
 8003aec:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return;
 8003af0:	bd10      	pop	{r4, pc}
 8003af2:	bf00      	nop
	...

08003b00 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 8003b00:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 8003b04:	2a06      	cmp	r2, #6
 8003b06:	d80c      	bhi.n	8003b22 <_usb_ep0out+0x22>
 8003b08:	2301      	movs	r3, #1
 8003b0a:	4093      	lsls	r3, r2
 8003b0c:	f013 0f67 	tst.w	r3, #103	; 0x67
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8003b10:	b510      	push	{r4, lr}
 8003b12:	4604      	mov	r4, r0
 8003b14:	d112      	bne.n	8003b3c <_usb_ep0out+0x3c>
 8003b16:	f013 0208 	ands.w	r2, r3, #8
 8003b1a:	d103      	bne.n	8003b24 <_usb_ep0out+0x24>
 8003b1c:	06db      	lsls	r3, r3, #27
 8003b1e:	d41e      	bmi.n	8003b5e <_usb_ep0out+0x5e>
 8003b20:	bd10      	pop	{r4, pc}
 8003b22:	4770      	bx	lr
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0U) {
 8003b24:	68c3      	ldr	r3, [r0, #12]
 8003b26:	699b      	ldr	r3, [r3, #24]
 8003b28:	689b      	ldr	r3, [r3, #8]
 8003b2a:	2b00      	cmp	r3, #0
 8003b2c:	d1f8      	bne.n	8003b20 <_usb_ep0out+0x20>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8003b2e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003b30:	b103      	cbz	r3, 8003b34 <_usb_ep0out+0x34>
      usbp->ep0endcb(usbp);
 8003b32:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003b34:	2300      	movs	r3, #0
 8003b36:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return;
 8003b3a:	bd10      	pop	{r4, pc}
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8003b3c:	2100      	movs	r1, #0
 8003b3e:	f001 fb87 	bl	8005250 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8003b42:	2100      	movs	r1, #0
 8003b44:	4620      	mov	r0, r4
 8003b46:	f001 fb73 	bl	8005230 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8003b4a:	6863      	ldr	r3, [r4, #4]
 8003b4c:	681b      	ldr	r3, [r3, #0]
 8003b4e:	b113      	cbz	r3, 8003b56 <_usb_ep0out+0x56>
 8003b50:	2105      	movs	r1, #5
 8003b52:	4620      	mov	r0, r4
 8003b54:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8003b56:	2306      	movs	r3, #6
 8003b58:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8003b5c:	bd10      	pop	{r4, pc}
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003b5e:	68c3      	ldr	r3, [r0, #12]
 8003b60:	695b      	ldr	r3, [r3, #20]

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8003b62:	2105      	movs	r1, #5
 8003b64:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8003b68:	701a      	strb	r2, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8003b6a:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 8003b6c:	605a      	str	r2, [r3, #4]
  isp->txcnt              = 0;
 8003b6e:	609a      	str	r2, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8003b70:	4611      	mov	r1, r2
 8003b72:	f001 fa1d 	bl	8004fb0 <usb_lld_prepare_transmit>
 8003b76:	2320      	movs	r3, #32
 8003b78:	f383 8811 	msr	BASEPRI, r3
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8003b7c:	8923      	ldrh	r3, [r4, #8]
 8003b7e:	f013 0101 	ands.w	r1, r3, #1
 8003b82:	d003      	beq.n	8003b8c <_usb_ep0out+0x8c>
 8003b84:	2300      	movs	r3, #0
 8003b86:	f383 8811 	msr	BASEPRI, r3
 8003b8a:	bd10      	pop	{r4, pc}
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003b8c:	f043 0301 	orr.w	r3, r3, #1
 8003b90:	8123      	strh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 8003b92:	4620      	mov	r0, r4
 8003b94:	f001 fb34 	bl	8005200 <usb_lld_start_in>
 8003b98:	e7f4      	b.n	8003b84 <_usb_ep0out+0x84>
 8003b9a:	bf00      	nop
 8003b9c:	0000      	movs	r0, r0
	...

08003ba0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8003ba0:	0943      	lsrs	r3, r0, #5
 8003ba2:	009b      	lsls	r3, r3, #2
 8003ba4:	b410      	push	{r4}
 8003ba6:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8003baa:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 8003bae:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8003bb2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8003bb6:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003bb8:	f000 001f 	and.w	r0, r0, #31
 8003bbc:	2201      	movs	r2, #1
 8003bbe:	fa02 f000 	lsl.w	r0, r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8003bc2:	b2c9      	uxtb	r1, r1
 8003bc4:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8003bc8:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8003bcc:	6018      	str	r0, [r3, #0]
}
 8003bce:	bc10      	pop	{r4}
 8003bd0:	4770      	bx	lr
 8003bd2:	bf00      	nop
	...

08003be0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8003be0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8003be2:	4b07      	ldr	r3, [pc, #28]	; (8003c00 <Vector6C+0x20>)
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 8003be4:	4a07      	ldr	r2, [pc, #28]	; (8003c04 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 8003be6:	6819      	ldr	r1, [r3, #0]
 8003be8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0;
 8003bec:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 8003bee:	6813      	ldr	r3, [r2, #0]
 8003bf0:	b10b      	cbz	r3, 8003bf6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8003bf2:	6850      	ldr	r0, [r2, #4]
 8003bf4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8003bf6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003bfa:	f7ff b919 	b.w	8002e30 <_port_irq_epilogue>
 8003bfe:	bf00      	nop
 8003c00:	40026000 	.word	0x40026000
 8003c04:	20000ff0 	.word	0x20000ff0
	...

08003c10 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8003c10:	4b08      	ldr	r3, [pc, #32]	; (8003c34 <Vector70+0x24>)
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 8003c12:	4809      	ldr	r0, [pc, #36]	; (8003c38 <Vector70+0x28>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8003c14:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
 8003c16:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 8003c18:	0989      	lsrs	r1, r1, #6
 8003c1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 8003c1e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
 8003c20:	018c      	lsls	r4, r1, #6
 8003c22:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 8003c24:	b10a      	cbz	r2, 8003c2a <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8003c26:	68c0      	ldr	r0, [r0, #12]
 8003c28:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003c2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003c2e:	f7ff b8ff 	b.w	8002e30 <_port_irq_epilogue>
 8003c32:	bf00      	nop
 8003c34:	40026000 	.word	0x40026000
 8003c38:	20000ff0 	.word	0x20000ff0
 8003c3c:	00000000 	.word	0x00000000

08003c40 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8003c40:	4b08      	ldr	r3, [pc, #32]	; (8003c64 <Vector74+0x24>)
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 8003c42:	4809      	ldr	r0, [pc, #36]	; (8003c68 <Vector74+0x28>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8003c44:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
 8003c46:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 8003c48:	0c09      	lsrs	r1, r1, #16
 8003c4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 8003c4e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
 8003c50:	040c      	lsls	r4, r1, #16
 8003c52:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 8003c54:	b10a      	cbz	r2, 8003c5a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8003c56:	6940      	ldr	r0, [r0, #20]
 8003c58:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003c5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003c5e:	f7ff b8e7 	b.w	8002e30 <_port_irq_epilogue>
 8003c62:	bf00      	nop
 8003c64:	40026000 	.word	0x40026000
 8003c68:	20000ff0 	.word	0x20000ff0
 8003c6c:	00000000 	.word	0x00000000

08003c70 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8003c70:	4b08      	ldr	r3, [pc, #32]	; (8003c94 <Vector78+0x24>)
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 8003c72:	4809      	ldr	r0, [pc, #36]	; (8003c98 <Vector78+0x28>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8003c74:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
 8003c76:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 8003c78:	0d89      	lsrs	r1, r1, #22
 8003c7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 8003c7e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
 8003c80:	058c      	lsls	r4, r1, #22
 8003c82:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 8003c84:	b10a      	cbz	r2, 8003c8a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8003c86:	69c0      	ldr	r0, [r0, #28]
 8003c88:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003c8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003c8e:	f7ff b8cf 	b.w	8002e30 <_port_irq_epilogue>
 8003c92:	bf00      	nop
 8003c94:	40026000 	.word	0x40026000
 8003c98:	20000ff0 	.word	0x20000ff0
 8003c9c:	00000000 	.word	0x00000000

08003ca0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 8003ca0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8003ca2:	4b07      	ldr	r3, [pc, #28]	; (8003cc0 <Vector7C+0x20>)
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8003ca4:	4807      	ldr	r0, [pc, #28]	; (8003cc4 <Vector7C+0x24>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8003ca6:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
 8003ca8:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 8003caa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0;
 8003cae:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8003cb0:	b10a      	cbz	r2, 8003cb6 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8003cb2:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8003cb4:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003cb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003cba:	f7ff b8b9 	b.w	8002e30 <_port_irq_epilogue>
 8003cbe:	bf00      	nop
 8003cc0:	40026000 	.word	0x40026000
 8003cc4:	20000ff0 	.word	0x20000ff0
	...

08003cd0 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8003cd0:	4b08      	ldr	r3, [pc, #32]	; (8003cf4 <Vector80+0x24>)
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 8003cd2:	4809      	ldr	r0, [pc, #36]	; (8003cf8 <Vector80+0x28>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8003cd4:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
 8003cd6:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 8003cd8:	0989      	lsrs	r1, r1, #6
 8003cda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 8003cde:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
 8003ce0:	018c      	lsls	r4, r1, #6
 8003ce2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 8003ce4:	b10a      	cbz	r2, 8003cea <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8003ce6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8003ce8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003cea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003cee:	f7ff b89f 	b.w	8002e30 <_port_irq_epilogue>
 8003cf2:	bf00      	nop
 8003cf4:	40026000 	.word	0x40026000
 8003cf8:	20000ff0 	.word	0x20000ff0
 8003cfc:	00000000 	.word	0x00000000

08003d00 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8003d00:	4b08      	ldr	r3, [pc, #32]	; (8003d24 <Vector84+0x24>)
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8003d02:	4809      	ldr	r0, [pc, #36]	; (8003d28 <Vector84+0x28>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8003d04:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
 8003d06:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 8003d08:	0c09      	lsrs	r1, r1, #16
 8003d0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 8003d0e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
 8003d10:	040c      	lsls	r4, r1, #16
 8003d12:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 8003d14:	b10a      	cbz	r2, 8003d1a <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8003d16:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8003d18:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003d1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003d1e:	f7ff b887 	b.w	8002e30 <_port_irq_epilogue>
 8003d22:	bf00      	nop
 8003d24:	40026000 	.word	0x40026000
 8003d28:	20000ff0 	.word	0x20000ff0
 8003d2c:	00000000 	.word	0x00000000

08003d30 <VectorFC>:
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8003d30:	4b08      	ldr	r3, [pc, #32]	; (8003d54 <VectorFC+0x24>)
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 8003d32:	4809      	ldr	r0, [pc, #36]	; (8003d58 <VectorFC+0x28>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8003d34:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
 8003d36:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 8003d38:	0d89      	lsrs	r1, r1, #22
 8003d3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 8003d3e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
 8003d40:	058c      	lsls	r4, r1, #22
 8003d42:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 8003d44:	b10a      	cbz	r2, 8003d4a <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8003d46:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8003d48:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003d4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003d4e:	f7ff b86f 	b.w	8002e30 <_port_irq_epilogue>
 8003d52:	bf00      	nop
 8003d54:	40026000 	.word	0x40026000
 8003d58:	20000ff0 	.word	0x20000ff0
 8003d5c:	00000000 	.word	0x00000000

08003d60 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8003d60:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8003d62:	4b07      	ldr	r3, [pc, #28]	; (8003d80 <Vector120+0x20>)
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 8003d64:	4807      	ldr	r0, [pc, #28]	; (8003d84 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8003d66:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
 8003d68:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 8003d6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0;
 8003d6e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 8003d70:	b10a      	cbz	r2, 8003d76 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8003d72:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8003d74:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003d76:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003d7a:	f7ff b859 	b.w	8002e30 <_port_irq_epilogue>
 8003d7e:	bf00      	nop
 8003d80:	40026400 	.word	0x40026400
 8003d84:	20000ff0 	.word	0x20000ff0
	...

08003d90 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8003d90:	4b08      	ldr	r3, [pc, #32]	; (8003db4 <Vector124+0x24>)
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 8003d92:	4809      	ldr	r0, [pc, #36]	; (8003db8 <Vector124+0x28>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8003d94:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
 8003d96:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 8003d98:	0989      	lsrs	r1, r1, #6
 8003d9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 8003d9e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
 8003da0:	018c      	lsls	r4, r1, #6
 8003da2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8003da4:	b10a      	cbz	r2, 8003daa <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8003da6:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8003da8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003daa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003dae:	f7ff b83f 	b.w	8002e30 <_port_irq_epilogue>
 8003db2:	bf00      	nop
 8003db4:	40026400 	.word	0x40026400
 8003db8:	20000ff0 	.word	0x20000ff0
 8003dbc:	00000000 	.word	0x00000000

08003dc0 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8003dc0:	4b08      	ldr	r3, [pc, #32]	; (8003de4 <Vector128+0x24>)
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8003dc2:	4809      	ldr	r0, [pc, #36]	; (8003de8 <Vector128+0x28>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8003dc4:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
 8003dc6:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8003dc8:	0c09      	lsrs	r1, r1, #16
 8003dca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 8003dce:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
 8003dd0:	040c      	lsls	r4, r1, #16
 8003dd2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8003dd4:	b10a      	cbz	r2, 8003dda <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8003dd6:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8003dd8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003dda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003dde:	f7ff b827 	b.w	8002e30 <_port_irq_epilogue>
 8003de2:	bf00      	nop
 8003de4:	40026400 	.word	0x40026400
 8003de8:	20000ff0 	.word	0x20000ff0
 8003dec:	00000000 	.word	0x00000000

08003df0 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8003df0:	4b08      	ldr	r3, [pc, #32]	; (8003e14 <Vector12C+0x24>)
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8003df2:	4809      	ldr	r0, [pc, #36]	; (8003e18 <Vector12C+0x28>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8003df4:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
 8003df6:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8003df8:	0d89      	lsrs	r1, r1, #22
 8003dfa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 8003dfe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
 8003e00:	058c      	lsls	r4, r1, #22
 8003e02:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8003e04:	b10a      	cbz	r2, 8003e0a <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8003e06:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8003e08:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003e0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003e0e:	f7ff b80f 	b.w	8002e30 <_port_irq_epilogue>
 8003e12:	bf00      	nop
 8003e14:	40026400 	.word	0x40026400
 8003e18:	20000ff0 	.word	0x20000ff0
 8003e1c:	00000000 	.word	0x00000000

08003e20 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8003e20:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8003e22:	4b07      	ldr	r3, [pc, #28]	; (8003e40 <Vector130+0x20>)
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8003e24:	4807      	ldr	r0, [pc, #28]	; (8003e44 <Vector130+0x24>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8003e26:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
 8003e28:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8003e2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0;
 8003e2e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 8003e30:	b10a      	cbz	r2, 8003e36 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8003e32:	6e40      	ldr	r0, [r0, #100]	; 0x64
 8003e34:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003e36:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003e3a:	f7fe bff9 	b.w	8002e30 <_port_irq_epilogue>
 8003e3e:	bf00      	nop
 8003e40:	40026400 	.word	0x40026400
 8003e44:	20000ff0 	.word	0x20000ff0
	...

08003e50 <Vector150>:
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8003e50:	4b08      	ldr	r3, [pc, #32]	; (8003e74 <Vector150+0x24>)
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 8003e52:	4809      	ldr	r0, [pc, #36]	; (8003e78 <Vector150+0x28>)
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8003e54:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
 8003e56:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(Vector150) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8003e58:	0989      	lsrs	r1, r1, #6
 8003e5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 8003e5e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
 8003e60:	018c      	lsls	r4, r1, #6
 8003e62:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8003e64:	b10a      	cbz	r2, 8003e6a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8003e66:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8003e68:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003e6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003e6e:	f7fe bfdf 	b.w	8002e30 <_port_irq_epilogue>
 8003e72:	bf00      	nop
 8003e74:	40026400 	.word	0x40026400
 8003e78:	20000ff0 	.word	0x20000ff0
 8003e7c:	00000000 	.word	0x00000000

08003e80 <Vector154>:
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8003e80:	4b08      	ldr	r3, [pc, #32]	; (8003ea4 <Vector154+0x24>)
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 8003e82:	4809      	ldr	r0, [pc, #36]	; (8003ea8 <Vector154+0x28>)
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8003e84:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
 8003e86:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(Vector154) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8003e88:	0c09      	lsrs	r1, r1, #16
 8003e8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 8003e8e:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
 8003e90:	040c      	lsls	r4, r1, #16
 8003e92:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8003e94:	b10a      	cbz	r2, 8003e9a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8003e96:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8003e98:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003e9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003e9e:	f7fe bfc7 	b.w	8002e30 <_port_irq_epilogue>
 8003ea2:	bf00      	nop
 8003ea4:	40026400 	.word	0x40026400
 8003ea8:	20000ff0 	.word	0x20000ff0
 8003eac:	00000000 	.word	0x00000000

08003eb0 <Vector158>:
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8003eb0:	4b08      	ldr	r3, [pc, #32]	; (8003ed4 <Vector158+0x24>)
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8003eb2:	4809      	ldr	r0, [pc, #36]	; (8003ed8 <Vector158+0x28>)
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8003eb4:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
 8003eb6:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(Vector158) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8003eb8:	0d89      	lsrs	r1, r1, #22
 8003eba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 8003ebe:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
 8003ec0:	058c      	lsls	r4, r1, #22
 8003ec2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8003ec4:	b10a      	cbz	r2, 8003eca <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8003ec6:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8003ec8:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8003eca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8003ece:	f7fe bfaf 	b.w	8002e30 <_port_irq_epilogue>
 8003ed2:	bf00      	nop
 8003ed4:	40026400 	.word	0x40026400
 8003ed8:	20000ff0 	.word	0x20000ff0
 8003edc:	00000000 	.word	0x00000000

08003ee0 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8003ee0:	490e      	ldr	r1, [pc, #56]	; (8003f1c <dmaInit+0x3c>)
 8003ee2:	4a0f      	ldr	r2, [pc, #60]	; (8003f20 <dmaInit+0x40>)
 8003ee4:	480f      	ldr	r0, [pc, #60]	; (8003f24 <dmaInit+0x44>)
 8003ee6:	2300      	movs	r3, #0
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8003ee8:	b410      	push	{r4}
  int i;

  dma_streams_mask = 0;
 8003eea:	600b      	str	r3, [r1, #0]
 8003eec:	4c0e      	ldr	r4, [pc, #56]	; (8003f28 <dmaInit+0x48>)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
 8003eee:	4619      	mov	r1, r3
 8003ef0:	e001      	b.n	8003ef6 <dmaInit+0x16>
 8003ef2:	f852 0c0c 	ldr.w	r0, [r2, #-12]
 8003ef6:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 8003ef8:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8003efc:	3301      	adds	r3, #1
 8003efe:	2b10      	cmp	r3, #16
 8003f00:	f102 020c 	add.w	r2, r2, #12
 8003f04:	d1f5      	bne.n	8003ef2 <dmaInit+0x12>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8003f06:	4909      	ldr	r1, [pc, #36]	; (8003f2c <dmaInit+0x4c>)
  DMA1->HIFCR = 0xFFFFFFFF;
  DMA2->LIFCR = 0xFFFFFFFF;
 8003f08:	4a09      	ldr	r2, [pc, #36]	; (8003f30 <dmaInit+0x50>)
  DMA2->HIFCR = 0xFFFFFFFF;
}
 8003f0a:	bc10      	pop	{r4}
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8003f0c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003f10:	608b      	str	r3, [r1, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
 8003f12:	60cb      	str	r3, [r1, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 8003f14:	6093      	str	r3, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 8003f16:	60d3      	str	r3, [r2, #12]
}
 8003f18:	4770      	bx	lr
 8003f1a:	bf00      	nop
 8003f1c:	20001070 	.word	0x20001070
 8003f20:	0800a4dc 	.word	0x0800a4dc
 8003f24:	40026010 	.word	0x40026010
 8003f28:	20000ff0 	.word	0x20000ff0
 8003f2c:	40026000 	.word	0x40026000
 8003f30:	40026400 	.word	0x40026400
	...

08003f40 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8003f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8003f42:	4f1f      	ldr	r7, [pc, #124]	; (8003fc0 <dmaStreamAllocate+0x80>)
 8003f44:	7a46      	ldrb	r6, [r0, #9]
 8003f46:	683d      	ldr	r5, [r7, #0]
 8003f48:	2401      	movs	r4, #1
 8003f4a:	fa04 fe06 	lsl.w	lr, r4, r6
 8003f4e:	ea1e 0f05 	tst.w	lr, r5
 8003f52:	d131      	bne.n	8003fb8 <dmaStreamAllocate+0x78>
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8003f54:	4c1b      	ldr	r4, [pc, #108]	; (8003fc4 <dmaStreamAllocate+0x84>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8003f56:	ea4e 0505 	orr.w	r5, lr, r5
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8003f5a:	eb04 0ec6 	add.w	lr, r4, r6, lsl #3
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8003f5e:	f015 0fff 	tst.w	r5, #255	; 0xff
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8003f62:	603d      	str	r5, [r7, #0]
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8003f64:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8003f68:	f8ce 3004 	str.w	r3, [lr, #4]
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8003f6c:	d004      	beq.n	8003f78 <dmaStreamAllocate+0x38>
    rccEnableDMA1(FALSE);
 8003f6e:	4c16      	ldr	r4, [pc, #88]	; (8003fc8 <dmaStreamAllocate+0x88>)
 8003f70:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003f72:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003f76:	6323      	str	r3, [r4, #48]	; 0x30
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
 8003f78:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 8003f7c:	d116      	bne.n	8003fac <dmaStreamAllocate+0x6c>
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8003f7e:	6805      	ldr	r5, [r0, #0]
 8003f80:	682b      	ldr	r3, [r5, #0]
 8003f82:	f023 031f 	bic.w	r3, r3, #31
 8003f86:	602b      	str	r3, [r5, #0]
 8003f88:	682b      	ldr	r3, [r5, #0]
 8003f8a:	f013 0401 	ands.w	r4, r3, #1
 8003f8e:	d1fb      	bne.n	8003f88 <dmaStreamAllocate+0x48>
 8003f90:	7a07      	ldrb	r7, [r0, #8]
 8003f92:	6846      	ldr	r6, [r0, #4]
 8003f94:	233d      	movs	r3, #61	; 0x3d
 8003f96:	40bb      	lsls	r3, r7
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8003f98:	2721      	movs	r7, #33	; 0x21
    rccEnableDMA1(FALSE);
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8003f9a:	6033      	str	r3, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8003f9c:	602c      	str	r4, [r5, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8003f9e:	616f      	str	r7, [r5, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 8003fa0:	b162      	cbz	r2, 8003fbc <dmaStreamAllocate+0x7c>
    nvicEnableVector(dmastp->vector, priority);
 8003fa2:	7a80      	ldrb	r0, [r0, #10]
 8003fa4:	f7ff fdfc 	bl	8003ba0 <nvicEnableVector>

  return FALSE;
 8003fa8:	4620      	mov	r0, r4
 8003faa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);
 8003fac:	4c06      	ldr	r4, [pc, #24]	; (8003fc8 <dmaStreamAllocate+0x88>)
 8003fae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003fb0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8003fb4:	6323      	str	r3, [r4, #48]	; 0x30
 8003fb6:	e7e2      	b.n	8003f7e <dmaStreamAllocate+0x3e>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;
 8003fb8:	4620      	mov	r0, r4
 8003fba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
    nvicEnableVector(dmastp->vector, priority);

  return FALSE;
 8003fbc:	4610      	mov	r0, r2
}
 8003fbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003fc0:	20001070 	.word	0x20001070
 8003fc4:	20000ff0 	.word	0x20000ff0
 8003fc8:	40023800 	.word	0x40023800
 8003fcc:	00000000 	.word	0x00000000

08003fd0 <hal_lld_init>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8003fd0:	4b16      	ldr	r3, [pc, #88]	; (800402c <hal_lld_init+0x5c>)
 8003fd2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003fd6:	691a      	ldr	r2, [r3, #16]
 8003fd8:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8003fda:	b410      	push	{r4}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8003fdc:	6119      	str	r1, [r3, #16]
 8003fde:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8003fe0:	6958      	ldr	r0, [r3, #20]
 8003fe2:	6159      	str	r1, [r3, #20]
 8003fe4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8003fe6:	6a18      	ldr	r0, [r3, #32]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8003fe8:	4c11      	ldr	r4, [pc, #68]	; (8004030 <hal_lld_init+0x60>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  rccResetAHB2(~0);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8003fea:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8003fee:	6218      	str	r0, [r3, #32]
 8003ff0:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8003ff2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8003ff4:	6259      	str	r1, [r3, #36]	; 0x24
 8003ff6:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8003ff8:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8003ffa:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8003ffe:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8004000:	6821      	ldr	r1, [r4, #0]
 8004002:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8004006:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8004008:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800400a:	f401 7140 	and.w	r1, r1, #768	; 0x300
 800400e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8004012:	d003      	beq.n	800401c <hal_lld_init+0x4c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8004014:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8004018:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800401a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800401c:	4a04      	ldr	r2, [pc, #16]	; (8004030 <hal_lld_init+0x60>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800401e:	bc10      	pop	{r4}

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8004020:	6853      	ldr	r3, [r2, #4]
 8004022:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8004026:	6053      	str	r3, [r2, #4]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8004028:	f7ff bf5a 	b.w	8003ee0 <dmaInit>
 800402c:	40023800 	.word	0x40023800
 8004030:	40007000 	.word	0x40007000
	...

08004040 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8004040:	492c      	ldr	r1, [pc, #176]	; (80040f4 <stm32_clock_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8004042:	4b2d      	ldr	r3, [pc, #180]	; (80040f8 <stm32_clock_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8004044:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8004048:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800404c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800404e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8004050:	680b      	ldr	r3, [r1, #0]
 8004052:	f043 0301 	orr.w	r3, r3, #1
 8004056:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8004058:	680a      	ldr	r2, [r1, #0]
 800405a:	4b26      	ldr	r3, [pc, #152]	; (80040f4 <stm32_clock_init+0xb4>)
 800405c:	0790      	lsls	r0, r2, #30
 800405e:	d5fb      	bpl.n	8004058 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8004060:	689a      	ldr	r2, [r3, #8]
 8004062:	f022 0203 	bic.w	r2, r2, #3
 8004066:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8004068:	689a      	ldr	r2, [r3, #8]
 800406a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800406c:	4619      	mov	r1, r3
 800406e:	688b      	ldr	r3, [r1, #8]
 8004070:	4a20      	ldr	r2, [pc, #128]	; (80040f4 <stm32_clock_init+0xb4>)
 8004072:	f013 030c 	ands.w	r3, r3, #12
 8004076:	d1fa      	bne.n	800406e <stm32_clock_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8004078:	6811      	ldr	r1, [r2, #0]
 800407a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800407e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8004080:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8004082:	6813      	ldr	r3, [r2, #0]
 8004084:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004088:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800408a:	6811      	ldr	r1, [r2, #0]
 800408c:	4b19      	ldr	r3, [pc, #100]	; (80040f4 <stm32_clock_init+0xb4>)
 800408e:	0389      	lsls	r1, r1, #14
 8004090:	d5fb      	bpl.n	800408a <stm32_clock_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8004092:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8004094:	f042 0201 	orr.w	r2, r2, #1
 8004098:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800409a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800409c:	4915      	ldr	r1, [pc, #84]	; (80040f4 <stm32_clock_init+0xb4>)
 800409e:	0790      	lsls	r0, r2, #30
 80040a0:	d5fb      	bpl.n	800409a <stm32_clock_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80040a2:	4b16      	ldr	r3, [pc, #88]	; (80040fc <stm32_clock_init+0xbc>)
 80040a4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80040a6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80040a8:	4a13      	ldr	r2, [pc, #76]	; (80040f8 <stm32_clock_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80040aa:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80040ae:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80040b0:	6853      	ldr	r3, [r2, #4]
 80040b2:	0459      	lsls	r1, r3, #17
 80040b4:	d5fc      	bpl.n	80040b0 <stm32_clock_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80040b6:	490f      	ldr	r1, [pc, #60]	; (80040f4 <stm32_clock_init+0xb4>)
 80040b8:	680a      	ldr	r2, [r1, #0]
 80040ba:	4b0e      	ldr	r3, [pc, #56]	; (80040f4 <stm32_clock_init+0xb4>)
 80040bc:	0192      	lsls	r2, r2, #6
 80040be:	d5fb      	bpl.n	80040b8 <stm32_clock_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80040c0:	4a0f      	ldr	r2, [pc, #60]	; (8004100 <stm32_clock_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80040c2:	4910      	ldr	r1, [pc, #64]	; (8004104 <stm32_clock_init+0xc4>)
 80040c4:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80040c6:	f240 7105 	movw	r1, #1797	; 0x705
 80040ca:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80040cc:	689a      	ldr	r2, [r3, #8]
 80040ce:	f042 0202 	orr.w	r2, r2, #2
 80040d2:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80040d4:	461a      	mov	r2, r3
 80040d6:	6893      	ldr	r3, [r2, #8]
 80040d8:	4906      	ldr	r1, [pc, #24]	; (80040f4 <stm32_clock_init+0xb4>)
 80040da:	f003 030c 	and.w	r3, r3, #12
 80040de:	2b08      	cmp	r3, #8
 80040e0:	d1f9      	bne.n	80040d6 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80040e2:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 80040e4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80040e8:	644b      	str	r3, [r1, #68]	; 0x44
 80040ea:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 80040ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80040f0:	664b      	str	r3, [r1, #100]	; 0x64
 80040f2:	4770      	bx	lr
 80040f4:	40023800 	.word	0x40023800
 80040f8:	40007000 	.word	0x40007000
 80040fc:	07405408 	.word	0x07405408
 8004100:	40023c00 	.word	0x40023c00
 8004104:	38089400 	.word	0x38089400
	...

08004110 <VectorB0>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8004110:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004114:	691a      	ldr	r2, [r3, #16]
 8004116:	0792      	lsls	r2, r2, #30
 8004118:	d401      	bmi.n	800411e <VectorB0+0xe>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800411a:	f7fe be89 	b.w	8002e30 <_port_irq_epilogue>
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800411e:	b510      	push	{r4, lr}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8004120:	2400      	movs	r4, #0
 8004122:	611c      	str	r4, [r3, #16]
 8004124:	2320      	movs	r3, #32
 8004126:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 800412a:	f7fd f8e9 	bl	8001300 <chSysTimerHandlerI>
 800412e:	f384 8811 	msr	BASEPRI, r4
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8004132:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8004136:	f7fe be7b 	b.w	8002e30 <_port_irq_epilogue>
 800413a:	bf00      	nop
 800413c:	0000      	movs	r0, r0
	...

08004140 <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8004140:	4a0f      	ldr	r2, [pc, #60]	; (8004180 <st_lld_init+0x40>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8004142:	4810      	ldr	r0, [pc, #64]	; (8004184 <st_lld_init+0x44>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8004144:	6c13      	ldr	r3, [r2, #64]	; 0x40
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8004146:	b470      	push	{r4, r5, r6}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8004148:	f043 0301 	orr.w	r3, r3, #1
 800414c:	6413      	str	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800414e:	6881      	ldr	r1, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8004150:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8004154:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8004156:	2401      	movs	r4, #1

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8004158:	f041 0101 	orr.w	r1, r1, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800415c:	f242 06cf 	movw	r6, #8399	; 0x20cf
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8004160:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8004164:	6081      	str	r1, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8004166:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8004168:	2108      	movs	r1, #8
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800416a:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800416c:	201c      	movs	r0, #28
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 800416e:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8004170:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8004172:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8004174:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8004176:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8004178:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800417a:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800417c:	f7ff bd10 	b.w	8003ba0 <nvicEnableVector>
 8004180:	40023800 	.word	0x40023800
 8004184:	e0042000 	.word	0xe0042000
	...

08004190 <adc_lld_serve_rx_interrupt>:
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004190:	f011 0f0c 	tst.w	r1, #12
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8004194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004198:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800419a:	d02e      	beq.n	80041fa <adc_lld_serve_rx_interrupt+0x6a>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800419c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800419e:	6803      	ldr	r3, [r0, #0]
 80041a0:	681a      	ldr	r2, [r3, #0]
 80041a2:	f022 021f 	bic.w	r2, r2, #31
 80041a6:	601a      	str	r2, [r3, #0]
 80041a8:	6819      	ldr	r1, [r3, #0]
 80041aa:	f011 0101 	ands.w	r1, r1, #1
 80041ae:	d1fb      	bne.n	80041a8 <adc_lld_serve_rx_interrupt+0x18>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80041b0:	6922      	ldr	r2, [r4, #16]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80041b2:	7a07      	ldrb	r7, [r0, #8]
 80041b4:	6846      	ldr	r6, [r0, #4]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80041b6:	6895      	ldr	r5, [r2, #8]
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 80041b8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80041ba:	223d      	movs	r2, #61	; 0x3d
 80041bc:	40ba      	lsls	r2, r7
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 80041be:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80041c0:	6032      	str	r2, [r6, #0]
  adcp->adc->CR1 = 0;
 80041c2:	6059      	str	r1, [r3, #4]
  adcp->adc->CR2 = 0;
 80041c4:	6099      	str	r1, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 80041c6:	6098      	str	r0, [r3, #8]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80041c8:	b145      	cbz	r5, 80041dc <adc_lld_serve_rx_interrupt+0x4c>
 80041ca:	2305      	movs	r3, #5
 80041cc:	7023      	strb	r3, [r4, #0]
 80041ce:	4620      	mov	r0, r4
 80041d0:	47a8      	blx	r5
 80041d2:	7823      	ldrb	r3, [r4, #0]
 80041d4:	2b05      	cmp	r3, #5
 80041d6:	bf04      	itt	eq
 80041d8:	2302      	moveq	r3, #2
 80041da:	7023      	strbeq	r3, [r4, #0]
 80041dc:	2500      	movs	r5, #0
 80041de:	6125      	str	r5, [r4, #16]
 80041e0:	2320      	movs	r3, #32
 80041e2:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80041e6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80041ea:	f104 0014 	add.w	r0, r4, #20
 80041ee:	f7fd fc07 	bl	8001a00 <chThdResumeI>
 80041f2:	f385 8811 	msr	BASEPRI, r5
 80041f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 80041fa:	6905      	ldr	r5, [r0, #16]
 80041fc:	b1a5      	cbz	r5, 8004228 <adc_lld_serve_rx_interrupt+0x98>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80041fe:	068a      	lsls	r2, r1, #26
 8004200:	d510      	bpl.n	8004224 <adc_lld_serve_rx_interrupt+0x94>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8004202:	782b      	ldrb	r3, [r5, #0]
 8004204:	b1db      	cbz	r3, 800423e <adc_lld_serve_rx_interrupt+0xae>
 8004206:	686b      	ldr	r3, [r5, #4]
 8004208:	b173      	cbz	r3, 8004228 <adc_lld_serve_rx_interrupt+0x98>
 800420a:	68c2      	ldr	r2, [r0, #12]
 800420c:	2a01      	cmp	r2, #1
 800420e:	d947      	bls.n	80042a0 <adc_lld_serve_rx_interrupt+0x110>
 8004210:	8869      	ldrh	r1, [r5, #2]
 8004212:	6884      	ldr	r4, [r0, #8]
 8004214:	0852      	lsrs	r2, r2, #1
 8004216:	fb02 f101 	mul.w	r1, r2, r1
 800421a:	eb04 0141 	add.w	r1, r4, r1, lsl #1
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800421e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8004222:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8004224:	06cb      	lsls	r3, r1, #27
 8004226:	d401      	bmi.n	800422c <adc_lld_serve_rx_interrupt+0x9c>
 8004228:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800422c:	686b      	ldr	r3, [r5, #4]
 800422e:	2b00      	cmp	r3, #0
 8004230:	d0fa      	beq.n	8004228 <adc_lld_serve_rx_interrupt+0x98>
 8004232:	68c2      	ldr	r2, [r0, #12]
 8004234:	6881      	ldr	r1, [r0, #8]
 8004236:	0852      	lsrs	r2, r2, #1
      }
    }
  }
}
 8004238:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800423c:	4718      	bx	r3
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800423e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8004240:	6802      	ldr	r2, [r0, #0]
 8004242:	6813      	ldr	r3, [r2, #0]
 8004244:	f023 031f 	bic.w	r3, r3, #31
 8004248:	6013      	str	r3, [r2, #0]
 800424a:	6813      	ldr	r3, [r2, #0]
 800424c:	f013 0301 	ands.w	r3, r3, #1
 8004250:	d1fb      	bne.n	800424a <adc_lld_serve_rx_interrupt+0xba>
 8004252:	7a07      	ldrb	r7, [r0, #8]
 8004254:	6846      	ldr	r6, [r0, #4]
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8004256:	686d      	ldr	r5, [r5, #4]
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 8004258:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800425a:	213d      	movs	r1, #61	; 0x3d
 800425c:	40b9      	lsls	r1, r7
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 800425e:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8004260:	6031      	str	r1, [r6, #0]
  adcp->adc->CR1 = 0;
 8004262:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
 8004264:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8004266:	6090      	str	r0, [r2, #8]
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8004268:	b1ad      	cbz	r5, 8004296 <adc_lld_serve_rx_interrupt+0x106>
 800426a:	2304      	movs	r3, #4
 800426c:	7023      	strb	r3, [r4, #0]
 800426e:	68e2      	ldr	r2, [r4, #12]
 8004270:	68a1      	ldr	r1, [r4, #8]
 8004272:	4620      	mov	r0, r4
 8004274:	47a8      	blx	r5
 8004276:	7823      	ldrb	r3, [r4, #0]
 8004278:	2b04      	cmp	r3, #4
 800427a:	d00c      	beq.n	8004296 <adc_lld_serve_rx_interrupt+0x106>
 800427c:	2320      	movs	r3, #32
 800427e:	f383 8811 	msr	BASEPRI, r3
 8004282:	2100      	movs	r1, #0
 8004284:	f104 0014 	add.w	r0, r4, #20
 8004288:	f7fd fbba 	bl	8001a00 <chThdResumeI>
 800428c:	2300      	movs	r3, #0
 800428e:	f383 8811 	msr	BASEPRI, r3
 8004292:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004296:	2202      	movs	r2, #2
 8004298:	2300      	movs	r3, #0
 800429a:	7022      	strb	r2, [r4, #0]
 800429c:	6123      	str	r3, [r4, #16]
 800429e:	e7ed      	b.n	800427c <adc_lld_serve_rx_interrupt+0xec>
 80042a0:	6881      	ldr	r1, [r0, #8]
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80042a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 80042a6:	4718      	bx	r3
	...

080042b0 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 80042b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 80042b2:	4b1e      	ldr	r3, [pc, #120]	; (800432c <Vector88+0x7c>)
 80042b4:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 80042b6:	2100      	movs	r1, #0
 80042b8:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 80042ba:	0693      	lsls	r3, r2, #26
 80042bc:	d531      	bpl.n	8004322 <Vector88+0x72>
 80042be:	4c1c      	ldr	r4, [pc, #112]	; (8004330 <Vector88+0x80>)
 80042c0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80042c2:	680a      	ldr	r2, [r1, #0]
 80042c4:	6853      	ldr	r3, [r2, #4]
 80042c6:	b363      	cbz	r3, 8004322 <Vector88+0x72>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 80042c8:	6925      	ldr	r5, [r4, #16]
 80042ca:	b355      	cbz	r5, 8004322 <Vector88+0x72>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80042cc:	6813      	ldr	r3, [r2, #0]
 80042ce:	f023 031f 	bic.w	r3, r3, #31
 80042d2:	6013      	str	r3, [r2, #0]
 80042d4:	6813      	ldr	r3, [r2, #0]
 80042d6:	f013 0301 	ands.w	r3, r3, #1
 80042da:	d1fb      	bne.n	80042d4 <Vector88+0x24>
 80042dc:	7a08      	ldrb	r0, [r1, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 80042de:	68ae      	ldr	r6, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80042e0:	684f      	ldr	r7, [r1, #4]
  adcp->adc->CR1 = 0;
 80042e2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80042e4:	4d12      	ldr	r5, [pc, #72]	; (8004330 <Vector88+0x80>)
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80042e6:	213d      	movs	r1, #61	; 0x3d
 80042e8:	fa01 f000 	lsl.w	r0, r1, r0
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 80042ec:	2101      	movs	r1, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80042ee:	6038      	str	r0, [r7, #0]
  adcp->adc->CR1 = 0;
 80042f0:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
 80042f2:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 80042f4:	6091      	str	r1, [r2, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 80042f6:	b146      	cbz	r6, 800430a <Vector88+0x5a>
 80042f8:	2305      	movs	r3, #5
 80042fa:	702b      	strb	r3, [r5, #0]
 80042fc:	4628      	mov	r0, r5
 80042fe:	47b0      	blx	r6
 8004300:	782b      	ldrb	r3, [r5, #0]
 8004302:	2b05      	cmp	r3, #5
 8004304:	bf04      	itt	eq
 8004306:	2302      	moveq	r3, #2
 8004308:	702b      	strbeq	r3, [r5, #0]
 800430a:	2500      	movs	r5, #0
 800430c:	6125      	str	r5, [r4, #16]
 800430e:	2320      	movs	r3, #32
 8004310:	f383 8811 	msr	BASEPRI, r3
 8004314:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004318:	4806      	ldr	r0, [pc, #24]	; (8004334 <Vector88+0x84>)
 800431a:	f7fd fb71 	bl	8001a00 <chThdResumeI>
 800431e:	f385 8811 	msr	BASEPRI, r5
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
}
 8004322:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 8004326:	f7fe bd83 	b.w	8002e30 <_port_irq_epilogue>
 800432a:	bf00      	nop
 800432c:	40012000 	.word	0x40012000
 8004330:	20001074 	.word	0x20001074
 8004334:	20001088 	.word	0x20001088
	...

08004340 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8004340:	b510      	push	{r4, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8004342:	4c08      	ldr	r4, [pc, #32]	; (8004364 <adc_lld_init+0x24>)
 8004344:	4620      	mov	r0, r4
 8004346:	f7fe fde3 	bl	8002f10 <adcObjectInit>
  ADCD1.adc = ADC1;
 800434a:	4907      	ldr	r1, [pc, #28]	; (8004368 <adc_lld_init+0x28>)
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 800434c:	4a07      	ldr	r2, [pc, #28]	; (800436c <adc_lld_init+0x2c>)
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 800434e:	4b08      	ldr	r3, [pc, #32]	; (8004370 <adc_lld_init+0x30>)
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 8004350:	62a1      	str	r1, [r4, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8004352:	62e2      	str	r2, [r4, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8004354:	6323      	str	r3, [r4, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 8004356:	2106      	movs	r1, #6
 8004358:	2012      	movs	r0, #18
}
 800435a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(ADC_IRQn, STM32_ADC_IRQ_PRIORITY);
 800435e:	f7ff bc1f 	b.w	8003ba0 <nvicEnableVector>
 8004362:	bf00      	nop
 8004364:	20001074 	.word	0x20001074
 8004368:	40012000 	.word	0x40012000
 800436c:	0800a560 	.word	0x0800a560
 8004370:	00022c16 	.word	0x00022c16
	...

08004380 <adc_lld_start>:
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8004380:	7803      	ldrb	r3, [r0, #0]
 8004382:	2b01      	cmp	r3, #1
 8004384:	d000      	beq.n	8004388 <adc_lld_start+0x8>
 8004386:	4770      	bx	lr
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 8004388:	4b11      	ldr	r3, [pc, #68]	; (80043d0 <adc_lld_start+0x50>)
 800438a:	4298      	cmp	r0, r3
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 800438c:	b510      	push	{r4, lr}
 800438e:	4604      	mov	r4, r0

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 8004390:	d00d      	beq.n	80043ae <adc_lld_start+0x2e>
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 8004392:	4810      	ldr	r0, [pc, #64]	; (80043d4 <adc_lld_start+0x54>)
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 8004394:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 8004396:	6843      	ldr	r3, [r0, #4]
 8004398:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800439c:	2100      	movs	r1, #0
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800439e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
    adcp->adc->CR2 = 0;
    adcp->adc->CR2 = ADC_CR2_ADON;
 80043a2:	2401      	movs	r4, #1
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 80043a4:	6043      	str	r3, [r0, #4]
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 80043a6:	6051      	str	r1, [r2, #4]
    adcp->adc->CR2 = 0;
 80043a8:	6091      	str	r1, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 80043aa:	6094      	str	r4, [r2, #8]
 80043ac:	bd10      	pop	{r4, pc}
  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 80043ae:	4603      	mov	r3, r0
 80043b0:	4a09      	ldr	r2, [pc, #36]	; (80043d8 <adc_lld_start+0x58>)
 80043b2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80043b4:	2106      	movs	r1, #6
 80043b6:	f7ff fdc3 	bl	8003f40 <dmaStreamAllocate>
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80043ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      rccEnableADC1(FALSE);
 80043bc:	4a07      	ldr	r2, [pc, #28]	; (80043dc <adc_lld_start+0x5c>)
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80043be:	681b      	ldr	r3, [r3, #0]
 80043c0:	4907      	ldr	r1, [pc, #28]	; (80043e0 <adc_lld_start+0x60>)
 80043c2:	6099      	str	r1, [r3, #8]
      rccEnableADC1(FALSE);
 80043c4:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80043c6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80043ca:	6453      	str	r3, [r2, #68]	; 0x44
 80043cc:	e7e1      	b.n	8004392 <adc_lld_start+0x12>
 80043ce:	bf00      	nop
 80043d0:	20001074 	.word	0x20001074
 80043d4:	40012300 	.word	0x40012300
 80043d8:	08004191 	.word	0x08004191
 80043dc:	40023800 	.word	0x40023800
 80043e0:	4001204c 	.word	0x4001204c
	...

080043f0 <adc_lld_start_conversion>:
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
  uint32_t mode;
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;
 80043f0:	6903      	ldr	r3, [r0, #16]

  /* DMA setup.*/
  mode = adcp->dmamode;
 80043f2:	6b01      	ldr	r1, [r0, #48]	; 0x30
  if (grpp->circular) {
 80043f4:	781a      	ldrb	r2, [r3, #0]
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 80043f6:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
 80043f8:	2a00      	cmp	r2, #0
 80043fa:	d12b      	bne.n	8004454 <adc_lld_start_conversion+0x64>
 80043fc:	68c2      	ldr	r2, [r0, #12]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 80043fe:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8004400:	885c      	ldrh	r4, [r3, #2]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8004402:	682d      	ldr	r5, [r5, #0]
 8004404:	6886      	ldr	r6, [r0, #8]
 8004406:	60ee      	str	r6, [r5, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8004408:	fb02 f204 	mul.w	r2, r2, r4
 800440c:	606a      	str	r2, [r5, #4]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800440e:	68dc      	ldr	r4, [r3, #12]
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 8004410:	6029      	str	r1, [r5, #0]
  dmaStreamEnable(adcp->dmastp);
 8004412:	682e      	ldr	r6, [r5, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 8004414:	6a82      	ldr	r2, [r0, #40]	; 0x28

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 8004416:	6919      	ldr	r1, [r3, #16]
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
 8004418:	f8d3 e014 	ldr.w	lr, [r3, #20]
  adcp->adc->SMPR2 = grpp->smpr2;
 800441c:	699f      	ldr	r7, [r3, #24]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800441e:	f044 6080 	orr.w	r0, r4, #67108864	; 0x4000000
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 8004422:	f046 0401 	orr.w	r4, r6, #1
 8004426:	602c      	str	r4, [r5, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 8004428:	2400      	movs	r4, #0
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
 800442a:	69dd      	ldr	r5, [r3, #28]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800442c:	6014      	str	r4, [r2, #0]
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
 800442e:	6a1c      	ldr	r4, [r3, #32]
  adcp->adc->SQR3  = grpp->sqr3;
 8004430:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
 8004432:	f8c2 e00c 	str.w	lr, [r2, #12]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8004436:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
 800443a:	6117      	str	r7, [r2, #16]
  adcp->adc->SQR1  = grpp->sqr1;
 800443c:	62d5      	str	r5, [r2, #44]	; 0x2c
  adcp->adc->SQR2  = grpp->sqr2;
 800443e:	6314      	str	r4, [r2, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
 8004440:	6353      	str	r3, [r2, #52]	; 0x34
  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
 8004442:	004b      	lsls	r3, r1, #1
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8004444:	6050      	str	r0, [r2, #4]
  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
 8004446:	d40d      	bmi.n	8004464 <adc_lld_start_conversion+0x74>

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;

  /* Enforcing the mandatory bits in CR2.*/
  cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
 8004448:	f441 7140 	orr.w	r1, r1, #768	; 0x300
 800444c:	f041 0101 	orr.w	r1, r1, #1

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
  }
  else
    adcp->adc->CR2 = cr2;
 8004450:	6091      	str	r1, [r2, #8]
 8004452:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
    mode |= STM32_DMA_CR_CIRC;
    if (adcp->depth > 1) {
 8004454:	68c2      	ldr	r2, [r0, #12]
 8004456:	2a01      	cmp	r2, #1
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
  if (grpp->circular) {
    mode |= STM32_DMA_CR_CIRC;
 8004458:	bf94      	ite	ls
 800445a:	f441 7180 	orrls.w	r1, r1, #256	; 0x100
    if (adcp->depth > 1) {
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
 800445e:	f441 7184 	orrhi.w	r1, r1, #264	; 0x108
 8004462:	e7cc      	b.n	80043fe <adc_lld_start_conversion+0xe>

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 8004464:	f021 4380 	bic.w	r3, r1, #1073741824	; 0x40000000
 8004468:	f023 0302 	bic.w	r3, r3, #2
 800446c:	f443 7340 	orr.w	r3, r3, #768	; 0x300

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 8004470:	f441 7140 	orr.w	r1, r1, #768	; 0x300

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 8004474:	f043 0303 	orr.w	r3, r3, #3

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 8004478:	f041 0103 	orr.w	r1, r1, #3

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800447c:	6093      	str	r3, [r2, #8]

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800447e:	6091      	str	r1, [r2, #8]
 8004480:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004482:	bf00      	nop
	...

08004490 <adcSTM32EnableTSVREFE>:
 *          temperature sensor and internal reference voltage.
 * @note    This is an STM32-only functionality.
 */
void adcSTM32EnableTSVREFE(void) {

  ADC->CCR |= ADC_CCR_TSVREFE;
 8004490:	4a02      	ldr	r2, [pc, #8]	; (800449c <adcSTM32EnableTSVREFE+0xc>)
 8004492:	6853      	ldr	r3, [r2, #4]
 8004494:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8004498:	6053      	str	r3, [r2, #4]
 800449a:	4770      	bx	lr
 800449c:	40012300 	.word	0x40012300

080044a0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80044a0:	b4f0      	push	{r4, r5, r6, r7}
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80044a2:	4d65      	ldr	r5, [pc, #404]	; (8004638 <_pal_lld_init+0x198>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80044a4:	4c65      	ldr	r4, [pc, #404]	; (800463c <_pal_lld_init+0x19c>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80044a6:	6b2f      	ldr	r7, [r5, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80044a8:	4965      	ldr	r1, [pc, #404]	; (8004640 <_pal_lld_init+0x1a0>)
 80044aa:	4a66      	ldr	r2, [pc, #408]	; (8004644 <_pal_lld_init+0x1a4>)
 80044ac:	4b66      	ldr	r3, [pc, #408]	; (8004648 <_pal_lld_init+0x1a8>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80044ae:	f240 16ff 	movw	r6, #511	; 0x1ff
 80044b2:	4337      	orrs	r7, r6
 80044b4:	632f      	str	r7, [r5, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80044b6:	6d2f      	ldr	r7, [r5, #80]	; 0x50
 80044b8:	433e      	orrs	r6, r7
 80044ba:	652e      	str	r6, [r5, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80044bc:	6845      	ldr	r5, [r0, #4]
 80044be:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80044c0:	6885      	ldr	r5, [r0, #8]
 80044c2:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80044c4:	68c5      	ldr	r5, [r0, #12]
 80044c6:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 80044c8:	6905      	ldr	r5, [r0, #16]
 80044ca:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80044cc:	6945      	ldr	r5, [r0, #20]
 80044ce:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80044d0:	6985      	ldr	r5, [r0, #24]
 80044d2:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80044d4:	6805      	ldr	r5, [r0, #0]
 80044d6:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80044d8:	6a04      	ldr	r4, [r0, #32]
 80044da:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80044dc:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80044de:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80044e0:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80044e2:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 80044e4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80044e6:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80044e8:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80044ea:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80044ec:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80044ee:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80044f0:	69c4      	ldr	r4, [r0, #28]
 80044f2:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80044f4:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 80044f6:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80044f8:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80044fa:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80044fc:	6c41      	ldr	r1, [r0, #68]	; 0x44
 80044fe:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8004500:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8004502:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8004504:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 8004506:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8004508:	6d01      	ldr	r1, [r0, #80]	; 0x50
 800450a:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800450c:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800450e:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004510:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8004512:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004514:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8004516:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8004518:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800451a:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800451c:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800451e:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8004520:	6e82      	ldr	r2, [r0, #104]	; 0x68
 8004522:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8004524:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8004526:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004528:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800452a:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800452c:	6f42      	ldr	r2, [r0, #116]	; 0x74
 800452e:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 8004532:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8004534:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 8004538:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 800453a:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 800453e:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
 8004542:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 8004546:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 800454a:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 800454e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8004552:	f8c3 2424 	str.w	r2, [r3, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 8004556:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8004558:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800455c:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8004560:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004564:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 8004568:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 800456c:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 8004570:	f8c3 280c 	str.w	r2, [r3, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8004574:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8004578:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 800457c:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
 8004580:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8004584:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
 8004588:	f8c3 2824 	str.w	r2, [r3, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800458c:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 8004590:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004594:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004598:	f8d0 20ac 	ldr.w	r2, [r0, #172]	; 0xac
 800459c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800459e:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 80045a2:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80045a4:	f8d0 20b4 	ldr.w	r2, [r0, #180]	; 0xb4
 80045a8:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80045aa:	f8d0 20b8 	ldr.w	r2, [r0, #184]	; 0xb8
 80045ae:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80045b0:	f8d0 20bc 	ldr.w	r2, [r0, #188]	; 0xbc
 80045b4:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80045b6:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 80045ba:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80045bc:	f8d0 20a8 	ldr.w	r2, [r0, #168]	; 0xa8
 80045c0:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80045c2:	f8d0 20c8 	ldr.w	r2, [r0, #200]	; 0xc8
 80045c6:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 80045ca:	f8d0 20cc 	ldr.w	r2, [r0, #204]	; 0xcc
 80045ce:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 80045d2:	f8d0 20d0 	ldr.w	r2, [r0, #208]	; 0xd0
 80045d6:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 80045da:	f8d0 20d4 	ldr.w	r2, [r0, #212]	; 0xd4
 80045de:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 80045e2:	f8d0 20d8 	ldr.w	r2, [r0, #216]	; 0xd8
 80045e6:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 80045ea:	f8d0 20dc 	ldr.w	r2, [r0, #220]	; 0xdc
 80045ee:	f8c3 2424 	str.w	r2, [r3, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 80045f2:	f8d0 20c4 	ldr.w	r2, [r0, #196]	; 0xc4
 80045f6:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80045fa:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4
 80045fe:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004602:	f8d0 20e8 	ldr.w	r2, [r0, #232]	; 0xe8
 8004606:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 800460a:	f8d0 20ec 	ldr.w	r2, [r0, #236]	; 0xec
 800460e:	f8c3 280c 	str.w	r2, [r3, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8004612:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 8004616:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 800461a:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800461e:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8004622:	f8d0 20f8 	ldr.w	r2, [r0, #248]	; 0xf8
 8004626:	f8c3 2824 	str.w	r2, [r3, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800462a:	f8d0 20e0 	ldr.w	r2, [r0, #224]	; 0xe0
 800462e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  initgpio(GPIOH, &config->PHData);
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
#endif
}
 8004632:	bcf0      	pop	{r4, r5, r6, r7}
 8004634:	4770      	bx	lr
 8004636:	bf00      	nop
 8004638:	40023800 	.word	0x40023800
 800463c:	40020000 	.word	0x40020000
 8004640:	40020400 	.word	0x40020400
 8004644:	40020800 	.word	0x40020800
 8004648:	40020c00 	.word	0x40020c00
 800464c:	00000000 	.word	0x00000000

08004650 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8004650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 8004654:	f04f 0c0f 	mov.w	ip, #15
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8004658:	f002 0e03 	and.w	lr, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800465c:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8004660:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8004664:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8004668:	2400      	movs	r4, #0

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800466a:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800466e:	f04f 0901 	mov.w	r9, #1
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8004672:	f04f 0803 	mov.w	r8, #3
 8004676:	e030      	b.n	80046da <_pal_lld_setgroupmode+0x8a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8004678:	f8d0 b020 	ldr.w	fp, [r0, #32]
 800467c:	ea2b 0303 	bic.w	r3, fp, r3
 8004680:	ea43 030a 	orr.w	r3, r3, sl
 8004684:	6203      	str	r3, [r0, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8004686:	6843      	ldr	r3, [r0, #4]
 8004688:	fa09 fa04 	lsl.w	sl, r9, r4
 800468c:	ea23 030a 	bic.w	r3, r3, sl
 8004690:	433b      	orrs	r3, r7
 8004692:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8004694:	0063      	lsls	r3, r4, #1
 8004696:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800469a:	fa08 f303 	lsl.w	r3, r8, r3
 800469e:	43db      	mvns	r3, r3
 80046a0:	ea0a 0a03 	and.w	sl, sl, r3
 80046a4:	ea4a 0a06 	orr.w	sl, sl, r6
 80046a8:	f8c0 a008 	str.w	sl, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80046ac:	f8d0 a00c 	ldr.w	sl, [r0, #12]
 80046b0:	ea03 0a0a 	and.w	sl, r3, sl
 80046b4:	ea4a 0a05 	orr.w	sl, sl, r5
 80046b8:	f8c0 a00c 	str.w	sl, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 80046bc:	f8d0 a000 	ldr.w	sl, [r0]
 80046c0:	ea03 030a 	and.w	r3, r3, sl
 80046c4:	ea43 030e 	orr.w	r3, r3, lr
 80046c8:	6003      	str	r3, [r0, #0]
    }
    mask >>= 1;
    if (!mask)
 80046ca:	0849      	lsrs	r1, r1, #1
 80046cc:	d019      	beq.n	8004702 <_pal_lld_setgroupmode+0xb2>
      return;
    otyper <<= 1;
 80046ce:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 80046d0:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 80046d2:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
 80046d4:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    bit++;
 80046d8:	3401      	adds	r4, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80046da:	f004 0307 	and.w	r3, r4, #7
 80046de:	009b      	lsls	r3, r3, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 80046e0:	f011 0f01 	tst.w	r1, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80046e4:	fa02 fa03 	lsl.w	sl, r2, r3
      m4 = 15 << ((bit & 7) * 4);
 80046e8:	fa0c f303 	lsl.w	r3, ip, r3
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 80046ec:	d0ed      	beq.n	80046ca <_pal_lld_setgroupmode+0x7a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 80046ee:	2c07      	cmp	r4, #7
 80046f0:	d9c2      	bls.n	8004678 <_pal_lld_setgroupmode+0x28>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 80046f2:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 80046f6:	ea2b 0303 	bic.w	r3, fp, r3
 80046fa:	ea43 030a 	orr.w	r3, r3, sl
 80046fe:	6243      	str	r3, [r0, #36]	; 0x24
 8004700:	e7c1      	b.n	8004686 <_pal_lld_setgroupmode+0x36>
 8004702:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004706:	bf00      	nop
	...

08004710 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8004710:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 8004714:	4bb4      	ldr	r3, [pc, #720]	; (80049e8 <usb_lld_pump+0x2d8>)
 8004716:	49b5      	ldr	r1, [pc, #724]	; (80049ec <usb_lld_pump+0x2dc>)
 8004718:	699a      	ldr	r2, [r3, #24]
 *
 * @special
 */
void usb_lld_pump(void *p) {
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 800471a:	f8d0 9050 	ldr.w	r9, [r0, #80]	; 0x50

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 800471e:	6191      	str	r1, [r2, #24]
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8004720:	b087      	sub	sp, #28
 8004722:	2320      	movs	r3, #32
 8004724:	f383 8811 	msr	BASEPRI, r3
 8004728:	9301      	str	r3, [sp, #4]
 800472a:	f100 0360 	add.w	r3, r0, #96	; 0x60
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 800472e:	46ca      	mov	sl, r9
 8004730:	9305      	str	r3, [sp, #20]
 8004732:	4681      	mov	r9, r0
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8004734:	f899 3000 	ldrb.w	r3, [r9]
 8004738:	2b01      	cmp	r3, #1
 800473a:	d006      	beq.n	800474a <usb_lld_pump+0x3a>
 800473c:	f8d9 305c 	ldr.w	r3, [r9, #92]	; 0x5c
 8004740:	b963      	cbnz	r3, 800475c <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8004742:	f8da 3014 	ldr.w	r3, [sl, #20]
 8004746:	06db      	lsls	r3, r3, #27
 8004748:	d408      	bmi.n	800475c <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 800474a:	f8da 3018 	ldr.w	r3, [sl, #24]
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 800474e:	9805      	ldr	r0, [sp, #20]
 8004750:	f043 0310 	orr.w	r3, r3, #16
 8004754:	f8ca 3018 	str.w	r3, [sl, #24]
 8004758:	f7fd f942 	bl	80019e0 <chThdSuspendS>
 800475c:	2300      	movs	r3, #0
 800475e:	f383 8811 	msr	BASEPRI, r3
 8004762:	469b      	mov	fp, r3

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8004764:	f8da 3014 	ldr.w	r3, [sl, #20]
 8004768:	f013 0310 	ands.w	r3, r3, #16
 800476c:	d024      	beq.n	80047b8 <usb_lld_pump+0xa8>
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 800476e:	f8d9 6050 	ldr.w	r6, [r9, #80]	; 0x50
 8004772:	6a33      	ldr	r3, [r6, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8004774:	f403 12f0 	and.w	r2, r3, #1966080	; 0x1e0000
 8004778:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800477c:	d032      	beq.n	80047e4 <usb_lld_pump+0xd4>
 800477e:	f5b2 2f40 	cmp.w	r2, #786432	; 0xc0000
 8004782:	d1ef      	bne.n	8004764 <usb_lld_pump+0x54>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8004784:	f003 020f 	and.w	r2, r3, #15
 8004788:	eb09 0282 	add.w	r2, r9, r2, lsl #2
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 800478c:	f3c3 130a 	ubfx	r3, r3, #4, #11
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8004790:	68d2      	ldr	r2, [r2, #12]
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 8004792:	3303      	adds	r3, #3
  max = (max + 3) / 4;
  while (n) {
 8004794:	089b      	lsrs	r3, r3, #2
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8004796:	6a10      	ldr	r0, [r2, #32]
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 8004798:	d0e4      	beq.n	8004764 <usb_lld_pump+0x54>
 800479a:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
 800479e:	2202      	movs	r2, #2
    uint32_t w = *fifop;
 80047a0:	6831      	ldr	r1, [r6, #0]
    if (max) {
 80047a2:	b112      	cbz	r2, 80047aa <usb_lld_pump+0x9a>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 80047a4:	f840 1b04 	str.w	r1, [r0], #4
      buf += 4;
      max--;
 80047a8:	3a01      	subs	r2, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 80047aa:	3b01      	subs	r3, #1
 80047ac:	d1f8      	bne.n	80047a0 <usb_lld_pump+0x90>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80047ae:	f8da 3014 	ldr.w	r3, [sl, #20]
 80047b2:	f013 0310 	ands.w	r3, r3, #16
 80047b6:	d1da      	bne.n	800476e <usb_lld_pump+0x5e>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
      if (usbp->txpending & epmask) {
 80047b8:	f8d9 205c 	ldr.w	r2, [r9, #92]	; 0x5c
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80047bc:	2101      	movs	r1, #1
 80047be:	fa01 f10b 	lsl.w	r1, r1, fp
      if (usbp->txpending & epmask) {
 80047c2:	4211      	tst	r1, r2
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80047c4:	9103      	str	r1, [sp, #12]
      if (usbp->txpending & epmask) {
 80047c6:	d169      	bne.n	800489c <usb_lld_pump+0x18c>
 80047c8:	f10b 0301 	add.w	r3, fp, #1
 80047cc:	9302      	str	r3, [sp, #8]
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80047ce:	f8d9 3054 	ldr.w	r3, [r9, #84]	; 0x54
 80047d2:	f89d b008 	ldrb.w	fp, [sp, #8]
 80047d6:	689b      	ldr	r3, [r3, #8]
 80047d8:	459b      	cmp	fp, r3
 80047da:	d9c3      	bls.n	8004764 <usb_lld_pump+0x54>
 80047dc:	9b01      	ldr	r3, [sp, #4]
 80047de:	f383 8811 	msr	BASEPRI, r3
 80047e2:	e7a7      	b.n	8004734 <usb_lld_pump+0x24>
 80047e4:	f003 050f 	and.w	r5, r3, #15
 80047e8:	eb09 0585 	add.w	r5, r9, r5, lsl #2
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 80047ec:	f3c3 140a 	ubfx	r4, r3, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
 80047f0:	68eb      	ldr	r3, [r5, #12]
 80047f2:	6999      	ldr	r1, [r3, #24]
 80047f4:	780b      	ldrb	r3, [r1, #0]
 80047f6:	b9db      	cbnz	r3, 8004830 <usb_lld_pump+0x120>
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 80047f8:	684b      	ldr	r3, [r1, #4]
 80047fa:	688a      	ldr	r2, [r1, #8]
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
                             usbp->epc[ep]->out_state->mode.queue.rxqueue,
                             cnt);
    }
    else {
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80047fc:	68c8      	ldr	r0, [r1, #12]
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 80047fe:	3303      	adds	r3, #3
 8004800:	1a9a      	subs	r2, r3, r2
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 8004802:	1ce3      	adds	r3, r4, #3
  max = (max + 3) / 4;
  while (n) {
 8004804:	089b      	lsrs	r3, r3, #2
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 8004806:	ea4f 0292 	mov.w	r2, r2, lsr #2
  while (n) {
 800480a:	d009      	beq.n	8004820 <usb_lld_pump+0x110>
 800480c:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
 8004810:	4686      	mov	lr, r0
    uint32_t w = *fifop;
 8004812:	6837      	ldr	r7, [r6, #0]
    if (max) {
 8004814:	b112      	cbz	r2, 800481c <usb_lld_pump+0x10c>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 8004816:	f84e 7b04 	str.w	r7, [lr], #4
      buf += 4;
      max--;
 800481a:	3a01      	subs	r2, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 800481c:	3b01      	subs	r3, #1
 800481e:	d1f8      	bne.n	8004812 <usb_lld_pump+0x102>
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                              usbp->epc[ep]->out_state->mode.linear.rxbuf,
                              cnt,
                              usbp->epc[ep]->out_state->rxsize -
                              usbp->epc[ep]->out_state->rxcnt);
      usbp->epc[ep]->out_state->mode.linear.rxbuf += cnt;
 8004820:	4420      	add	r0, r4
 8004822:	60c8      	str	r0, [r1, #12]
    }
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8004824:	68eb      	ldr	r3, [r5, #12]
 8004826:	699a      	ldr	r2, [r3, #24]
 8004828:	6893      	ldr	r3, [r2, #8]
 800482a:	4423      	add	r3, r4
 800482c:	6093      	str	r3, [r2, #8]
 800482e:	e799      	b.n	8004764 <usb_lld_pump+0x54>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
      /* Queue associated.*/
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
 8004830:	68c8      	ldr	r0, [r1, #12]
                                   input_queue_t *iqp,
                                   size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8004832:	b324      	cbz	r4, 800487e <usb_lld_pump+0x16e>
 8004834:	6942      	ldr	r2, [r0, #20]
 8004836:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
 800483a:	4627      	mov	r7, r4
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800483c:	2f03      	cmp	r7, #3
 800483e:	d906      	bls.n	800484e <usb_lld_pump+0x13e>
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
      if (iqp->q_wrptr >= iqp->q_top) {
 8004840:	6903      	ldr	r3, [r0, #16]
 8004842:	429a      	cmp	r2, r3
 8004844:	d303      	bcc.n	800484e <usb_lld_pump+0x13e>
        iqp->q_wrptr = iqp->q_buffer;
 8004846:	68c2      	ldr	r2, [r0, #12]
 8004848:	6142      	str	r2, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 800484a:	2f03      	cmp	r7, #3
 800484c:	d8f8      	bhi.n	8004840 <usb_lld_pump+0x130>
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
      break;

    /* One byte at time.*/
    w = *fifop;
 800484e:	f8d6 e000 	ldr.w	lr, [r6]
 8004852:	2300      	movs	r3, #0
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      *iqp->q_wrptr++ = (uint8_t)(w >> (i * 8));
 8004854:	fa2e f103 	lsr.w	r1, lr, r3
 8004858:	f102 0c01 	add.w	ip, r2, #1
 800485c:	f8c0 c014 	str.w	ip, [r0, #20]
 8004860:	7011      	strb	r1, [r2, #0]
      if (iqp->q_wrptr >= iqp->q_top)
 8004862:	6902      	ldr	r2, [r0, #16]
 8004864:	6941      	ldr	r1, [r0, #20]
 8004866:	4291      	cmp	r1, r2
        iqp->q_wrptr = iqp->q_buffer;
 8004868:	bf24      	itt	cs
 800486a:	68c2      	ldrcs	r2, [r0, #12]
 800486c:	6142      	strcs	r2, [r0, #20]
      break;

    /* One byte at time.*/
    w = *fifop;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 800486e:	3f01      	subs	r7, #1
 8004870:	f103 0308 	add.w	r3, r3, #8
 8004874:	d003      	beq.n	800487e <usb_lld_pump+0x16e>
 8004876:	2b20      	cmp	r3, #32
 8004878:	6942      	ldr	r2, [r0, #20]
 800487a:	d1eb      	bne.n	8004854 <usb_lld_pump+0x144>
 800487c:	e7de      	b.n	800483c <usb_lld_pump+0x12c>
 800487e:	9b01      	ldr	r3, [sp, #4]
 8004880:	f383 8811 	msr	BASEPRI, r3
    }
  }

  /* Updating queue.*/
  osalSysLock();
  iqp->q_counter += n;
 8004884:	6883      	ldr	r3, [r0, #8]
 8004886:	4423      	add	r3, r4
 8004888:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800488a:	2100      	movs	r1, #0
 800488c:	f7fd f8f0 	bl	8001a70 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 8004890:	f7fc ff4e 	bl	8001730 <chSchRescheduleS>
 8004894:	2300      	movs	r3, #0
 8004896:	f383 8811 	msr	BASEPRI, r3
 800489a:	e7c3      	b.n	8004824 <usb_lld_pump+0x114>
 800489c:	9a01      	ldr	r2, [sp, #4]
 800489e:	f382 8811 	msr	BASEPRI, r2
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80048a2:	f8da 1008 	ldr.w	r1, [sl, #8]
        usbp->txpending &= ~epmask;
 80048a6:	f8d9 205c 	ldr.w	r2, [r9, #92]	; 0x5c
 80048aa:	9803      	ldr	r0, [sp, #12]
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80048ac:	f021 0101 	bic.w	r1, r1, #1
        usbp->txpending &= ~epmask;
 80048b0:	ea22 0200 	bic.w	r2, r2, r0
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80048b4:	f8ca 1008 	str.w	r1, [sl, #8]
        usbp->txpending &= ~epmask;
 80048b8:	f8c9 205c 	str.w	r2, [r9, #92]	; 0x5c
 80048bc:	f383 8811 	msr	BASEPRI, r3
 80048c0:	eb09 078b 	add.w	r7, r9, fp, lsl #2
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80048c4:	68fc      	ldr	r4, [r7, #12]
 80048c6:	6962      	ldr	r2, [r4, #20]
 80048c8:	6891      	ldr	r1, [r2, #8]
 80048ca:	6853      	ldr	r3, [r2, #4]
 80048cc:	4299      	cmp	r1, r3
 80048ce:	f080 80b5 	bcs.w	8004a3c <usb_lld_pump+0x32c>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80048d2:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 80048d6:	8a26      	ldrh	r6, [r4, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80048d8:	ea4f 184b 	mov.w	r8, fp, lsl #5
 80048dc:	eb00 0408 	add.w	r4, r0, r8
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80048e0:	1a5b      	subs	r3, r3, r1
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80048e2:	f8d4 1918 	ldr.w	r1, [r4, #2328]	; 0x918
 80048e6:	429e      	cmp	r6, r3
 80048e8:	bf28      	it	cs
 80048ea:	461e      	movcs	r6, r3
 80048ec:	b28b      	uxth	r3, r1
 80048ee:	ebb6 0f83 	cmp.w	r6, r3, lsl #2
 80048f2:	f10b 0301 	add.w	r3, fp, #1
 80048f6:	9302      	str	r3, [sp, #8]
 80048f8:	d82f      	bhi.n	800495a <usb_lld_pump+0x24a>
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80048fa:	031b      	lsls	r3, r3, #12
 80048fc:	f8cd a010 	str.w	sl, [sp, #16]
 8004900:	469a      	mov	sl, r3

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
 8004902:	7813      	ldrb	r3, [r2, #0]
 8004904:	2b00      	cmp	r3, #0
 8004906:	d13d      	bne.n	8004984 <usb_lld_pump+0x274>
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  otg_do_push(fifop, (uint8_t *)buf, (n + 3) / 4);
 8004908:	1cf3      	adds	r3, r6, #3
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800490a:	68d4      	ldr	r4, [r2, #12]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 800490c:	089b      	lsrs	r3, r3, #2
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800490e:	eb00 0e0a 	add.w	lr, r0, sl
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8004912:	bf18      	it	ne
 8004914:	4621      	movne	r1, r4
 8004916:	d005      	beq.n	8004924 <usb_lld_pump+0x214>
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 8004918:	f851 0b04 	ldr.w	r0, [r1], #4
 800491c:	f8ce 0000 	str.w	r0, [lr]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8004920:	3b01      	subs	r3, #1
 8004922:	d1f9      	bne.n	8004918 <usb_lld_pump+0x208>
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                                 usbp->epc[ep]->in_state->mode.linear.txbuf,
                                 n);
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
 8004924:	4434      	add	r4, r6
 8004926:	60d4      	str	r4, [r2, #12]
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8004928:	68fc      	ldr	r4, [r7, #12]
 800492a:	6962      	ldr	r2, [r4, #20]
 800492c:	6893      	ldr	r3, [r2, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800492e:	6851      	ldr	r1, [r2, #4]
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8004930:	4433      	add	r3, r6
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8004932:	4299      	cmp	r1, r3
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8004934:	6093      	str	r3, [r2, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8004936:	d97d      	bls.n	8004a34 <usb_lld_pump+0x324>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004938:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 800493c:	8a24      	ldrh	r4, [r4, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800493e:	eb00 0508 	add.w	r5, r0, r8
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8004942:	1ace      	subs	r6, r1, r3
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004944:	f8d5 3918 	ldr.w	r3, [r5, #2328]	; 0x918
 8004948:	42a6      	cmp	r6, r4
 800494a:	bf28      	it	cs
 800494c:	4626      	movcs	r6, r4
 800494e:	b29b      	uxth	r3, r3
 8004950:	ebb6 0f83 	cmp.w	r6, r3, lsl #2
 8004954:	d9d5      	bls.n	8004902 <usb_lld_pump+0x1f2>
 8004956:	f8dd a010 	ldr.w	sl, [sp, #16]
      return FALSE;
 800495a:	2200      	movs	r2, #0
 800495c:	9b01      	ldr	r3, [sp, #4]
 800495e:	f383 8811 	msr	BASEPRI, r3
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8004962:	f8da 3008 	ldr.w	r3, [sl, #8]
 8004966:	f043 0301 	orr.w	r3, r3, #1
 800496a:	f8ca 3008 	str.w	r3, [sl, #8]
        if (!done)
 800496e:	b92a      	cbnz	r2, 800497c <usb_lld_pump+0x26c>
          otgp->DIEPEMPMSK |= epmask;
 8004970:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 8004974:	9a03      	ldr	r2, [sp, #12]
 8004976:	431a      	orrs	r2, r3
 8004978:	f8ca 2834 	str.w	r2, [sl, #2100]	; 0x834
 800497c:	2300      	movs	r3, #0
 800497e:	f383 8811 	msr	BASEPRI, r3
 8004982:	e724      	b.n	80047ce <usb_lld_pump+0xbe>
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
      /* Queue associated.*/
      otg_fifo_write_from_queue(usbp->otg->FIFO[ep],
 8004984:	eb00 0e0a 	add.w	lr, r0, sl
 8004988:	68d0      	ldr	r0, [r2, #12]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 800498a:	b1f6      	cbz	r6, 80049ca <usb_lld_pump+0x2ba>
 800498c:	f8d0 c010 	ldr.w	ip, [r0, #16]
 8004990:	4632      	mov	r2, r6
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8004992:	0891      	lsrs	r1, r2, #2
 8004994:	d12c      	bne.n	80049f0 <usb_lld_pump+0x2e0>
 8004996:	6983      	ldr	r3, [r0, #24]
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 8004998:	2100      	movs	r1, #0
 800499a:	460c      	mov	r4, r1

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 800499c:	1c5d      	adds	r5, r3, #1
 800499e:	6185      	str	r5, [r0, #24]
 80049a0:	781b      	ldrb	r3, [r3, #0]
      if (oqp->q_rdptr >= oqp->q_top)
 80049a2:	4565      	cmp	r5, ip

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 80049a4:	fa03 f301 	lsl.w	r3, r3, r1
 80049a8:	ea44 0403 	orr.w	r4, r4, r3
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
 80049ac:	bf24      	itt	cs
 80049ae:	68c3      	ldrcs	r3, [r0, #12]
 80049b0:	6183      	strcs	r3, [r0, #24]
      break;

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 80049b2:	3a01      	subs	r2, #1
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 80049b4:	f101 0108 	add.w	r1, r1, #8
      break;

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 80049b8:	d003      	beq.n	80049c2 <usb_lld_pump+0x2b2>
 80049ba:	2920      	cmp	r1, #32
 80049bc:	d001      	beq.n	80049c2 <usb_lld_pump+0x2b2>
 80049be:	6983      	ldr	r3, [r0, #24]
 80049c0:	e7ec      	b.n	800499c <usb_lld_pump+0x28c>
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
      ntogo--;
      i++;
    }
    *fifop = w;
 80049c2:	f8ce 4000 	str.w	r4, [lr]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 80049c6:	2a00      	cmp	r2, #0
 80049c8:	d1e3      	bne.n	8004992 <usb_lld_pump+0x282>
 80049ca:	9b01      	ldr	r3, [sp, #4]
 80049cc:	f383 8811 	msr	BASEPRI, r3
    *fifop = w;
  }

  /* Updating queue.*/
  osalSysLock();
  oqp->q_counter += n;
 80049d0:	6883      	ldr	r3, [r0, #8]
 80049d2:	4433      	add	r3, r6
 80049d4:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 80049d6:	2100      	movs	r1, #0
 80049d8:	f7fd f84a 	bl	8001a70 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 80049dc:	f7fc fea8 	bl	8001730 <chSchRescheduleS>
 80049e0:	2300      	movs	r3, #0
 80049e2:	f383 8811 	msr	BASEPRI, r3
 80049e6:	e79f      	b.n	8004928 <usb_lld_pump+0x218>
 80049e8:	20000e78 	.word	0x20000e78
 80049ec:	0800a5a0 	.word	0x0800a5a0
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
 80049f0:	6984      	ldr	r4, [r0, #24]

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
 80049f2:	ebbc 0304 	subs.w	r3, ip, r4
 80049f6:	bf48      	it	mi
 80049f8:	3303      	addmi	r3, #3
 80049fa:	109b      	asrs	r3, r3, #2
 80049fc:	428b      	cmp	r3, r1
 80049fe:	bf28      	it	cs
 8004a00:	460b      	movcs	r3, r1
 8004a02:	ea4f 0b83 	mov.w	fp, r3, lsl #2
 8004a06:	ebcb 0202 	rsb	r2, fp, r2
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8004a0a:	b13b      	cbz	r3, 8004a1c <usb_lld_pump+0x30c>
 8004a0c:	4621      	mov	r1, r4
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 8004a0e:	f851 5b04 	ldr.w	r5, [r1], #4
 8004a12:	f8ce 5000 	str.w	r5, [lr]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8004a16:	3b01      	subs	r3, #1
 8004a18:	d1f9      	bne.n	8004a0e <usb_lld_pump+0x2fe>
 8004a1a:	445c      	add	r4, fp
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
      if (oqp->q_rdptr >= oqp->q_top) {
 8004a1c:	45a4      	cmp	ip, r4
    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
 8004a1e:	6184      	str	r4, [r0, #24]
      if (oqp->q_rdptr >= oqp->q_top) {
 8004a20:	d804      	bhi.n	8004a2c <usb_lld_pump+0x31c>
        oqp->q_rdptr = oqp->q_buffer;
 8004a22:	68c3      	ldr	r3, [r0, #12]
 8004a24:	6183      	str	r3, [r0, #24]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8004a26:	2a00      	cmp	r2, #0
 8004a28:	d1b3      	bne.n	8004992 <usb_lld_pump+0x282>
 8004a2a:	e7ce      	b.n	80049ca <usb_lld_pump+0x2ba>
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 8004a2c:	2a00      	cmp	r2, #0
 8004a2e:	d0cc      	beq.n	80049ca <usb_lld_pump+0x2ba>
 8004a30:	4623      	mov	r3, r4
 8004a32:	e7b1      	b.n	8004998 <usb_lld_pump+0x288>
 8004a34:	f8dd a010 	ldr.w	sl, [sp, #16]
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;
 8004a38:	2201      	movs	r2, #1
 8004a3a:	e78f      	b.n	800495c <usb_lld_pump+0x24c>
 8004a3c:	f10b 0301 	add.w	r3, fp, #1
 8004a40:	9302      	str	r3, [sp, #8]
 8004a42:	e7f9      	b.n	8004a38 <usb_lld_pump+0x328>
	...

08004a50 <otg_disable_ep.isra.0>:
  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
    ;
}

static void otg_disable_ep(USBDriver *usbp) {
 8004a50:	b5f0      	push	{r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a52:	2400      	movs	r4, #0
 8004a54:	f8d1 e008 	ldr.w	lr, [r1, #8]
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
 8004a58:	4625      	mov	r5, r4
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".*/
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 8004a5a:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8004a5e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8004a62:	e014      	b.n	8004a8e <otg_disable_ep.isra.0+0x3e>
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
        ;
    }
    else
      otgp->ie[i].DIEPCTL = 0;
 8004a64:	f8c1 5900 	str.w	r5, [r1, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 8004a68:	18c2      	adds	r2, r0, r3
 8004a6a:	f8c2 5910 	str.w	r5, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8004a6e:	f8c2 7908 	str.w	r7, [r2, #2312]	; 0x908
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".
       Note that the attempt to disable the OUT EP0 is ignored by the
       hardware but the code is simpler this way.*/
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
 8004a72:	f8d1 6b00 	ldr.w	r6, [r1, #2816]	; 0xb00
 8004a76:	2e00      	cmp	r6, #0
 8004a78:	db17      	blt.n	8004aaa <otg_disable_ep.isra.0+0x5a>
      /* Wait for endpoint disable.*/
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
        ;
    }
    else
      otgp->oe[i].DOEPCTL = 0;
 8004a7a:	f8c1 5b00 	str.w	r5, [r1, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 8004a7e:	4403      	add	r3, r0

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a80:	3401      	adds	r4, #1
 8004a82:	4574      	cmp	r4, lr
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
        ;
    }
    else
      otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
 8004a84:	f8c3 5b10 	str.w	r5, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8004a88:	f8c3 7b08 	str.w	r7, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004a8c:	d814      	bhi.n	8004ab8 <otg_disable_ep.isra.0+0x68>
 8004a8e:	0163      	lsls	r3, r4, #5
 8004a90:	18c1      	adds	r1, r0, r3
    /* Disable only if enabled because this sentence in the manual:
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".*/
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
 8004a92:	f8d1 2900 	ldr.w	r2, [r1, #2304]	; 0x900
 8004a96:	2a00      	cmp	r2, #0
 8004a98:	dae4      	bge.n	8004a64 <otg_disable_ep.isra.0+0x14>
      otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
 8004a9a:	f8c1 c900 	str.w	ip, [r1, #2304]	; 0x900
      /* Wait for endpoint disable.*/
      while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
 8004a9e:	460e      	mov	r6, r1
 8004aa0:	f8d6 2908 	ldr.w	r2, [r6, #2312]	; 0x908
 8004aa4:	0792      	lsls	r2, r2, #30
 8004aa6:	d5fb      	bpl.n	8004aa0 <otg_disable_ep.isra.0+0x50>
 8004aa8:	e7de      	b.n	8004a68 <otg_disable_ep.isra.0+0x18>
       "The application must set this bit only if Endpoint Enable is
        already set for this endpoint".
       Note that the attempt to disable the OUT EP0 is ignored by the
       hardware but the code is simpler this way.*/
    if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
      otgp->oe[i].DOEPCTL = DOEPCTL_EPDIS;
 8004aaa:	f8c1 cb00 	str.w	ip, [r1, #2816]	; 0xb00
      /* Wait for endpoint disable.*/
      while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
 8004aae:	f8d2 1b08 	ldr.w	r1, [r2, #2824]	; 0xb08
 8004ab2:	06c9      	lsls	r1, r1, #27
 8004ab4:	d5fb      	bpl.n	8004aae <otg_disable_ep.isra.0+0x5e>
 8004ab6:	e7e2      	b.n	8004a7e <otg_disable_ep.isra.0+0x2e>
    else
      otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8004ab8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8004abc:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
 8004ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004ac2:	bf00      	nop
	...

08004ad0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8004ad0:	b510      	push	{r4, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8004ad2:	4c06      	ldr	r4, [pc, #24]	; (8004aec <usb_lld_init+0x1c>)
 8004ad4:	4620      	mov	r0, r4
 8004ad6:	f7fe fd53 	bl	8003580 <usbObjectInit>
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8004ada:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;
 8004ade:	4a04      	ldr	r2, [pc, #16]	; (8004af0 <usb_lld_init+0x20>)

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8004ae0:	6523      	str	r3, [r4, #80]	; 0x50
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 8004ae2:	2300      	movs	r3, #0
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8004ae4:	6562      	str	r2, [r4, #84]	; 0x54
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 8004ae6:	6623      	str	r3, [r4, #96]	; 0x60
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8004ae8:	6663      	str	r3, [r4, #100]	; 0x64
 8004aea:	bd10      	pop	{r4, pc}
 8004aec:	200010a8 	.word	0x200010a8
 8004af0:	0800a590 	.word	0x0800a590
	...

08004b00 <usb_lld_start>:
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 8004b00:	7803      	ldrb	r3, [r0, #0]
 8004b02:	2b01      	cmp	r3, #1
 8004b04:	d000      	beq.n	8004b08 <usb_lld_start+0x8>
 8004b06:	4770      	bx	lr
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8004b08:	b570      	push	{r4, r5, r6, lr}
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8004b0a:	4b31      	ldr	r3, [pc, #196]	; (8004bd0 <usb_lld_start+0xd0>)
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8004b0c:	6d06      	ldr	r6, [r0, #80]	; 0x50

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8004b0e:	4298      	cmp	r0, r3
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8004b10:	b082      	sub	sp, #8
 8004b12:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
 8004b14:	bf18      	it	ne
 8004b16:	4634      	movne	r4, r6

  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8004b18:	d03a      	beq.n	8004b90 <usb_lld_start+0x90>
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 8004b1a:	2300      	movs	r3, #0

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 8004b1c:	482d      	ldr	r0, [pc, #180]	; (8004bd4 <usb_lld_start+0xd4>)

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8004b1e:	492e      	ldr	r1, [pc, #184]	; (8004bd8 <usb_lld_start+0xd8>)
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 8004b20:	65eb      	str	r3, [r5, #92]	; 0x5c
    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
                  GCCFG_PWRDWN;
#else
    otgp->GCCFG = GCCFG_VBUSASEN | GCCFG_VBUSBSEN | GCCFG_PWRDWN;
 8004b22:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
    usbp->txpending = 0;

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 8004b26:	60f0      	str	r0, [r6, #12]

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8004b28:	f8c6 1800 	str.w	r1, [r6, #2048]	; 0x800
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8004b2c:	2020      	movs	r0, #32

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8004b2e:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00
    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
                  GCCFG_PWRDWN;
#else
    otgp->GCCFG = GCCFG_VBUSASEN | GCCFG_VBUSBSEN | GCCFG_PWRDWN;
 8004b32:	63b2      	str	r2, [r6, #56]	; 0x38
 8004b34:	f7fc fc44 	bl	80013c0 <chSysPolledDelayX>
  stm32_otg_t *otgp = usbp->otg;

  osalSysPolledDelayX(32);

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8004b38:	2301      	movs	r3, #1
 8004b3a:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8004b3c:	6923      	ldr	r3, [r4, #16]
 8004b3e:	07db      	lsls	r3, r3, #31
 8004b40:	d4fc      	bmi.n	8004b3c <usb_lld_start+0x3c>
 8004b42:	200c      	movs	r0, #12
 8004b44:	f7fc fc3c 	bl	80013c0 <chSysPolledDelayX>
    ;

  osalSysPolledDelayX(12);

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8004b48:	6923      	ldr	r3, [r4, #16]
 8004b4a:	2b00      	cmp	r3, #0
 8004b4c:	dafc      	bge.n	8004b48 <usb_lld_start+0x48>

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8004b4e:	2400      	movs	r4, #0
 8004b50:	60b4      	str	r4, [r6, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8004b52:	6d69      	ldr	r1, [r5, #84]	; 0x54
 8004b54:	6d28      	ldr	r0, [r5, #80]	; 0x50
 8004b56:	f7ff ff7b 	bl	8004a50 <otg_disable_ep.isra.0>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8004b5a:	686b      	ldr	r3, [r5, #4]
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8004b5c:	f8c6 4810 	str.w	r4, [r6, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8004b60:	68db      	ldr	r3, [r3, #12]
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
 8004b62:	f8c6 4814 	str.w	r4, [r6, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8004b66:	f8c6 481c 	str.w	r4, [r6, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8004b6a:	b16b      	cbz	r3, 8004b88 <usb_lld_start+0x88>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 8004b6c:	f243 0308 	movw	r3, #12296	; 0x3008
 8004b70:	61b3      	str	r3, [r6, #24]
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8004b72:	6e6b      	ldr	r3, [r5, #100]	; 0x64
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */
 8004b74:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004b78:	6172      	str	r2, [r6, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8004b7a:	b1d3      	cbz	r3, 8004bb2 <usb_lld_start+0xb2>
      chSchRescheduleS();
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8004b7c:	68b3      	ldr	r3, [r6, #8]
 8004b7e:	f043 0301 	orr.w	r3, r3, #1
 8004b82:	60b3      	str	r3, [r6, #8]
  }
}
 8004b84:	b002      	add	sp, #8
 8004b86:	bd70      	pop	{r4, r5, r6, pc}
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 8004b88:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8004b8c:	61b3      	str	r3, [r6, #24]
 8004b8e:	e7f0      	b.n	8004b72 <usb_lld_start+0x72>
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
 8004b90:	4b12      	ldr	r3, [pc, #72]	; (8004bdc <usb_lld_start+0xdc>)
 8004b92:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004b94:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8004b98:	635a      	str	r2, [r3, #52]	; 0x34
      rccResetOTG_FS();
 8004b9a:	695a      	ldr	r2, [r3, #20]
 8004b9c:	2000      	movs	r0, #0
 8004b9e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8004ba2:	615a      	str	r2, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8004ba4:	210e      	movs	r1, #14
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
      rccResetOTG_FS();
 8004ba6:	6158      	str	r0, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8004ba8:	2043      	movs	r0, #67	; 0x43
 8004baa:	f7fe fff9 	bl	8003ba0 <nvicEnableVector>
 8004bae:	6d2c      	ldr	r4, [r5, #80]	; 0x50
 8004bb0:	e7b3      	b.n	8004b1a <usb_lld_start+0x1a>
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8004bb2:	4b0b      	ldr	r3, [pc, #44]	; (8004be0 <usb_lld_start+0xe0>)
 8004bb4:	9500      	str	r5, [sp, #0]
 8004bb6:	2202      	movs	r2, #2
 8004bb8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004bbc:	f105 0068 	add.w	r0, r5, #104	; 0x68
 8004bc0:	f7fc fdee 	bl	80017a0 <chThdCreateI>
 8004bc4:	6668      	str	r0, [r5, #100]	; 0x64
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8004bc6:	f7fc fcdb 	bl	8001580 <chSchReadyI>
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
      chSchRescheduleS();
 8004bca:	f7fc fdb1 	bl	8001730 <chSchRescheduleS>
 8004bce:	e7d5      	b.n	8004b7c <usb_lld_start+0x7c>
 8004bd0:	200010a8 	.word	0x200010a8
 8004bd4:	40001440 	.word	0x40001440
 8004bd8:	02200003 	.word	0x02200003
 8004bdc:	40023800 	.word	0x40023800
 8004be0:	08004711 	.word	0x08004711
	...

08004bf0 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8004bf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8004bf2:	6d05      	ldr	r5, [r0, #80]	; 0x50
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004bf4:	2320      	movs	r3, #32
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8004bf6:	4607      	mov	r7, r0
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004bf8:	612b      	str	r3, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004bfa:	692b      	ldr	r3, [r5, #16]
 8004bfc:	f013 0420 	ands.w	r4, r3, #32
 8004c00:	d1fb      	bne.n	8004bfa <usb_lld_reset+0xa>
 8004c02:	200c      	movs	r0, #12
 8004c04:	f7fc fbdc 	bl	80013c0 <chSysPolledDelayX>

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004c08:	f8d7 e054 	ldr.w	lr, [r7, #84]	; 0x54
 8004c0c:	f8de 6008 	ldr.w	r6, [lr, #8]
 8004c10:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8004c12:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFF;
 8004c16:	21ff      	movs	r1, #255	; 0xff
 8004c18:	eb05 1243 	add.w	r2, r5, r3, lsl #5

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004c1c:	3301      	adds	r3, #1
 8004c1e:	42b3      	cmp	r3, r6
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8004c20:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8004c24:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFF;
 8004c28:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFF;
 8004c2c:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8004c30:	d9f2      	bls.n	8004c18 <usb_lld_reset+0x28>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8004c32:	f8de 3000 	ldr.w	r3, [lr]
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 8004c36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8004c3a:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 8004c3e:	f8c5 2818 	str.w	r2, [r5, #2072]	; 0x818
 8004c42:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8004c44:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8004c48:	65bb      	str	r3, [r7, #88]	; 0x58

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8004c4a:	f8de 3000 	ldr.w	r3, [lr]
 8004c4e:	626b      	str	r3, [r5, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8004c50:	2310      	movs	r3, #16
 8004c52:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8004c54:	6913      	ldr	r3, [r2, #16]
 8004c56:	f013 0410 	ands.w	r4, r3, #16
 8004c5a:	d1fb      	bne.n	8004c54 <usb_lld_reset+0x64>
 8004c5c:	200c      	movs	r0, #12
 8004c5e:	f7fc fbaf 	bl	80013c0 <chSysPolledDelayX>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8004c62:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8004c66:	4a11      	ldr	r2, [pc, #68]	; (8004cac <usb_lld_reset+0xbc>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8004c68:	4811      	ldr	r0, [pc, #68]	; (8004cb0 <usb_lld_reset+0xc0>)
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8004c6a:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8004c6e:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8004c72:	69ab      	ldr	r3, [r5, #24]
 8004c74:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8004c78:	f043 0310 	orr.w	r3, r3, #16
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8004c7c:	2109      	movs	r1, #9

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8004c7e:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8004c80:	f8c5 1810 	str.w	r1, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8004c84:	f8c5 1814 	str.w	r1, [r5, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8004c88:	60f8      	str	r0, [r7, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8004c8a:	f8c5 4b10 	str.w	r4, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8004c8e:	f8c5 2b00 	str.w	r2, [r5, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8004c92:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8004c96:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8004c9a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  usbp->pmnext += size;
 8004c9c:	f103 0210 	add.w	r2, r3, #16
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8004ca0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8004ca4:	65ba      	str	r2, [r7, #88]	; 0x58
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8004ca6:	62ab      	str	r3, [r5, #40]	; 0x28
 8004ca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004caa:	bf00      	nop
 8004cac:	10008040 	.word	0x10008040
 8004cb0:	0800a5b0 	.word	0x0800a5b0
	...

08004cc0 <usb_lld_set_address>:
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8004cc0:	6d02      	ldr	r2, [r0, #80]	; 0x50

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8004cc2:	f890 104e 	ldrb.w	r1, [r0, #78]	; 0x4e
 8004cc6:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 8004cca:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8004cce:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8004cd2:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 8004cd6:	4770      	bx	lr
	...

08004ce0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8004ce0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004ce4:	fa0f f881 	sxth.w	r8, r1
 8004ce8:	eb00 0788 	add.w	r7, r0, r8, lsl #2
 8004cec:	460d      	mov	r5, r1
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8004cee:	68fb      	ldr	r3, [r7, #12]
 8004cf0:	681a      	ldr	r2, [r3, #0]
 8004cf2:	f002 0203 	and.w	r2, r2, #3
 8004cf6:	2a02      	cmp	r2, #2
 8004cf8:	d05e      	beq.n	8004db8 <usb_lld_init_endpoint+0xd8>
 8004cfa:	2a03      	cmp	r2, #3
 8004cfc:	d05e      	beq.n	8004dbc <usb_lld_init_endpoint+0xdc>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8004cfe:	4e4c      	ldr	r6, [pc, #304]	; (8004e30 <usb_lld_init_endpoint+0x150>)
 8004d00:	494c      	ldr	r1, [pc, #304]	; (8004e34 <usb_lld_init_endpoint+0x154>)
 8004d02:	2a01      	cmp	r2, #1
 8004d04:	bf18      	it	ne
 8004d06:	460e      	movne	r6, r1
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8004d08:	6d04      	ldr	r4, [r0, #80]	; 0x50
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
  if (usbp->epc[ep]->out_cb != NULL) {
 8004d0a:	68d9      	ldr	r1, [r3, #12]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8004d0c:	016a      	lsls	r2, r5, #5
 8004d0e:	eb04 0e02 	add.w	lr, r4, r2
 8004d12:	f04f 0c00 	mov.w	ip, #0
 8004d16:	f8ce cb10 	str.w	ip, [lr, #2832]	; 0xb10
  if (usbp->epc[ep]->out_cb != NULL) {
 8004d1a:	2900      	cmp	r1, #0
 8004d1c:	d073      	beq.n	8004e06 <usb_lld_init_endpoint+0x126>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8004d1e:	f8b3 e012 	ldrh.w	lr, [r3, #18]
 8004d22:	f105 0158 	add.w	r1, r5, #88	; 0x58
 8004d26:	0149      	lsls	r1, r1, #5
 8004d28:	ea4e 0e06 	orr.w	lr, lr, r6
 8004d2c:	f844 e001 	str.w	lr, [r4, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8004d30:	f105 0c10 	add.w	ip, r5, #16
 8004d34:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 8004d38:	f04f 0e01 	mov.w	lr, #1
 8004d3c:	fa0e fe0c 	lsl.w	lr, lr, ip
 8004d40:	ea4e 0101 	orr.w	r1, lr, r1
 8004d44:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8004d48:	4422      	add	r2, r4
  if (usbp->epc[ep]->in_cb != NULL) {
 8004d4a:	6899      	ldr	r1, [r3, #8]
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8004d4c:	f04f 0e00 	mov.w	lr, #0
 8004d50:	f8c2 e910 	str.w	lr, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_cb != NULL) {
 8004d54:	2900      	cmp	r1, #0
 8004d56:	d033      	beq.n	8004dc0 <usb_lld_init_endpoint+0xe0>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 8004d58:	8b99      	ldrh	r1, [r3, #28]

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8004d5a:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8004d5c:	2901      	cmp	r1, #1

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8004d5e:	ea4f 0392 	mov.w	r3, r2, lsr #2
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8004d62:	6d82      	ldr	r2, [r0, #88]	; 0x58
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
 8004d64:	bf88      	it	hi
 8004d66:	434b      	mulhi	r3, r1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8004d68:	f105 013f 	add.w	r1, r5, #63	; 0x3f
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8004d6c:	eb03 0e02 	add.w	lr, r3, r2
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8004d70:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8004d74:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004d78:	01aa      	lsls	r2, r5, #6
 8004d7a:	f042 0220 	orr.w	r2, r2, #32
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8004d7e:	f8c0 e058 	str.w	lr, [r0, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8004d82:	604b      	str	r3, [r1, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004d84:	6122      	str	r2, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004d86:	6923      	ldr	r3, [r4, #16]
 8004d88:	069a      	lsls	r2, r3, #26
 8004d8a:	d4fc      	bmi.n	8004d86 <usb_lld_init_endpoint+0xa6>
 8004d8c:	200c      	movs	r0, #12
 8004d8e:	f7fc fb17 	bl	80013c0 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8004d92:	68fb      	ldr	r3, [r7, #12]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8004d94:	8a1a      	ldrh	r2, [r3, #16]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8004d96:	f105 0348 	add.w	r3, r5, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
 8004d9a:	ea42 5285 	orr.w	r2, r2, r5, lsl #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8004d9e:	015b      	lsls	r3, r3, #5
                           DIEPCTL_TXFNUM(ep) |
 8004da0:	4332      	orrs	r2, r6
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8004da2:	50e2      	str	r2, [r4, r3]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8004da4:	2101      	movs	r1, #1
 8004da6:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
 8004daa:	fa01 f505 	lsl.w	r5, r1, r5
 8004dae:	431d      	orrs	r5, r3
 8004db0:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
 8004db4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8004db8:	4e1f      	ldr	r6, [pc, #124]	; (8004e38 <usb_lld_init_endpoint+0x158>)
    break;
 8004dba:	e7a5      	b.n	8004d08 <usb_lld_init_endpoint+0x28>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8004dbc:	4e1f      	ldr	r6, [pc, #124]	; (8004e3c <usb_lld_init_endpoint+0x15c>)
    break;
 8004dbe:	e7a3      	b.n	8004d08 <usb_lld_init_endpoint+0x28>
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8004dc0:	f105 023f 	add.w	r2, r5, #63	; 0x3f
 8004dc4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004dc8:	01ab      	lsls	r3, r5, #6
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8004dca:	491d      	ldr	r1, [pc, #116]	; (8004e40 <usb_lld_init_endpoint+0x160>)
 8004dcc:	6051      	str	r1, [r2, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004dce:	f043 0320 	orr.w	r3, r3, #32
 8004dd2:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004dd4:	6923      	ldr	r3, [r4, #16]
 8004dd6:	069b      	lsls	r3, r3, #26
 8004dd8:	d4fc      	bmi.n	8004dd4 <usb_lld_init_endpoint+0xf4>
 8004dda:	eb04 1848 	add.w	r8, r4, r8, lsl #5
 8004dde:	200c      	movs	r0, #12
 8004de0:	f7fc faee 	bl	80013c0 <chSysPolledDelayX>
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8004de4:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
 8004de8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8004dec:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8004df0:	f8d4 381c 	ldr.w	r3, [r4, #2076]	; 0x81c
 8004df4:	2201      	movs	r2, #1
 8004df6:	fa02 f505 	lsl.w	r5, r2, r5
 8004dfa:	ea23 0305 	bic.w	r3, r3, r5
 8004dfe:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
 8004e02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004e06:	eb04 1148 	add.w	r1, r4, r8, lsl #5
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8004e0a:	f105 0910 	add.w	r9, r5, #16
  if (usbp->epc[ep]->out_cb != NULL) {
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8004e0e:	f8d1 cb00 	ldr.w	ip, [r1, #2816]	; 0xb00
 8004e12:	f42c 4c00 	bic.w	ip, ip, #32768	; 0x8000
 8004e16:	f8c1 cb00 	str.w	ip, [r1, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8004e1a:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 8004e1e:	f04f 0e01 	mov.w	lr, #1
 8004e22:	fa0e fe09 	lsl.w	lr, lr, r9
 8004e26:	ea21 010e 	bic.w	r1, r1, lr
 8004e2a:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c
 8004e2e:	e78b      	b.n	8004d48 <usb_lld_init_endpoint+0x68>
 8004e30:	10048000 	.word	0x10048000
 8004e34:	10008000 	.word	0x10008000
 8004e38:	10088000 	.word	0x10088000
 8004e3c:	100c8000 	.word	0x100c8000
 8004e40:	02000400 	.word	0x02000400
	...

08004e50 <usb_lld_get_status_out>:
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8004e50:	3158      	adds	r1, #88	; 0x58
 8004e52:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8004e54:	0149      	lsls	r1, r1, #5
 8004e56:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8004e58:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 8004e5c:	d004      	beq.n	8004e68 <usb_lld_get_status_out+0x18>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 8004e5e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
    return EP_STATUS_STALLED;
  return EP_STATUS_ACTIVE;
 8004e62:	bf14      	ite	ne
 8004e64:	2001      	movne	r0, #1
 8004e66:	2002      	moveq	r0, #2
}
 8004e68:	4770      	bx	lr
 8004e6a:	bf00      	nop
 8004e6c:	0000      	movs	r0, r0
	...

08004e70 <usb_lld_get_status_in>:
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8004e70:	3148      	adds	r1, #72	; 0x48
 8004e72:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8004e74:	0149      	lsls	r1, r1, #5
 8004e76:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 8004e78:	f413 4000 	ands.w	r0, r3, #32768	; 0x8000
 8004e7c:	d004      	beq.n	8004e88 <usb_lld_get_status_in+0x18>
    return EP_STATUS_DISABLED;
  if (ctl & DIEPCTL_STALL)
 8004e7e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
    return EP_STATUS_STALLED;
  return EP_STATUS_ACTIVE;
 8004e82:	bf14      	ite	ne
 8004e84:	2001      	movne	r0, #1
 8004e86:	2002      	moveq	r0, #2
}
 8004e88:	4770      	bx	lr
 8004e8a:	bf00      	nop
 8004e8c:	0000      	movs	r0, r0
	...

08004e90 <usb_lld_read_setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8004e90:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8004e94:	68cb      	ldr	r3, [r1, #12]
 8004e96:	6a1b      	ldr	r3, [r3, #32]
 8004e98:	6819      	ldr	r1, [r3, #0]
 8004e9a:	685b      	ldr	r3, [r3, #4]
 8004e9c:	6053      	str	r3, [r2, #4]
 8004e9e:	6011      	str	r1, [r2, #0]
 8004ea0:	4770      	bx	lr
 8004ea2:	bf00      	nop
	...

08004eb0 <usb_lld_prepare_receive>:
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004eb0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
 8004eb4:	b430      	push	{r4, r5}
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004eb6:	68dd      	ldr	r5, [r3, #12]
 8004eb8:	69ac      	ldr	r4, [r5, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 8004eba:	6863      	ldr	r3, [r4, #4]
 8004ebc:	6123      	str	r3, [r4, #16]
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
 8004ebe:	b931      	cbnz	r1, 8004ece <usb_lld_prepare_receive+0x1e>
 8004ec0:	2b40      	cmp	r3, #64	; 0x40
 8004ec2:	d904      	bls.n	8004ece <usb_lld_prepare_receive+0x1e>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8004ec4:	2340      	movs	r3, #64	; 0x40
 8004ec6:	6063      	str	r3, [r4, #4]
 8004ec8:	4a09      	ldr	r2, [pc, #36]	; (8004ef0 <usb_lld_prepare_receive+0x40>)
 8004eca:	243f      	movs	r4, #63	; 0x3f
 8004ecc:	e002      	b.n	8004ed4 <usb_lld_prepare_receive+0x24>
 8004ece:	1e5c      	subs	r4, r3, #1
 8004ed0:	f043 42c0 	orr.w	r2, r3, #1610612736	; 0x60000000

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8004ed4:	6d00      	ldr	r0, [r0, #80]	; 0x50
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8004ed6:	8a6d      	ldrh	r5, [r5, #18]
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8004ed8:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8004edc:	192b      	adds	r3, r5, r4
 8004ede:	fbb3 f3f5 	udiv	r3, r3, r5
 8004ee2:	ea42 43c3 	orr.w	r3, r2, r3, lsl #19
 8004ee6:	f8c1 3b10 	str.w	r3, [r1, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(osp->rxsize);

}
 8004eea:	bc30      	pop	{r4, r5}
 8004eec:	4770      	bx	lr
 8004eee:	bf00      	nop
 8004ef0:	60000040 	.word	0x60000040
	...

08004f00 <otg_epout_handler.constprop.7>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8004f00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8004f04:	4e26      	ldr	r6, [pc, #152]	; (8004fa0 <otg_epout_handler.constprop.7+0xa0>)
 8004f06:	6d37      	ldr	r7, [r6, #80]	; 0x50
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8004f08:	eb07 1340 	add.w	r3, r7, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8004f0c:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8004f0e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8004f12:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8004f16:	0720      	lsls	r0, r4, #28
 8004f18:	d503      	bpl.n	8004f22 <otg_epout_handler.constprop.7+0x22>
 8004f1a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8004f1e:	0719      	lsls	r1, r3, #28
 8004f20:	d41d      	bmi.n	8004f5e <otg_epout_handler.constprop.7+0x5e>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8004f22:	07e2      	lsls	r2, r4, #31
 8004f24:	d519      	bpl.n	8004f5a <otg_epout_handler.constprop.7+0x5a>
 8004f26:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8004f2a:	07db      	lsls	r3, r3, #31
 8004f2c:	d515      	bpl.n	8004f5a <otg_epout_handler.constprop.7+0x5a>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004f2e:	eb06 0685 	add.w	r6, r6, r5, lsl #2
 8004f32:	4c1b      	ldr	r4, [pc, #108]	; (8004fa0 <otg_epout_handler.constprop.7+0xa0>)
 8004f34:	68f1      	ldr	r1, [r6, #12]
 8004f36:	698b      	ldr	r3, [r1, #24]

    if (osp->rxsize < osp->totsize) {
 8004f38:	6858      	ldr	r0, [r3, #4]
 8004f3a:	691a      	ldr	r2, [r3, #16]
 8004f3c:	4290      	cmp	r0, r2
 8004f3e:	d316      	bcc.n	8004f6e <otg_epout_handler.constprop.7+0x6e>
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8004f40:	8962      	ldrh	r2, [r4, #10]
 8004f42:	68ce      	ldr	r6, [r1, #12]
 8004f44:	2301      	movs	r3, #1
 8004f46:	40ab      	lsls	r3, r5
 8004f48:	ea22 0303 	bic.w	r3, r2, r3
 8004f4c:	8163      	strh	r3, [r4, #10]
 8004f4e:	4629      	mov	r1, r5
 8004f50:	4620      	mov	r0, r4
 8004f52:	4633      	mov	r3, r6
    }
  }
}
 8004f54:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8004f58:	4718      	bx	r3
 8004f5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 8004f5e:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 8004f62:	4629      	mov	r1, r5
 8004f64:	68db      	ldr	r3, [r3, #12]
 8004f66:	4630      	mov	r0, r6
 8004f68:	685b      	ldr	r3, [r3, #4]
 8004f6a:	4798      	blx	r3
 8004f6c:	e7d9      	b.n	8004f22 <otg_epout_handler.constprop.7+0x22>

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8004f6e:	1a12      	subs	r2, r2, r0
      osp->rxcnt  = 0;
 8004f70:	2600      	movs	r6, #0

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8004f72:	605a      	str	r2, [r3, #4]
      osp->rxcnt  = 0;
 8004f74:	609e      	str	r6, [r3, #8]
      usb_lld_prepare_receive(usbp, ep);
 8004f76:	4629      	mov	r1, r5
 8004f78:	4620      	mov	r0, r4
 8004f7a:	f7ff ff99 	bl	8004eb0 <usb_lld_prepare_receive>
 8004f7e:	2320      	movs	r3, #32
 8004f80:	f383 8811 	msr	BASEPRI, r3
 8004f84:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8004f86:	eb03 1545 	add.w	r5, r3, r5, lsl #5
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8004f8a:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 8004f8e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8004f92:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
 8004f96:	f386 8811 	msr	BASEPRI, r6
 8004f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f9e:	bf00      	nop
 8004fa0:	200010a8 	.word	0x200010a8
	...

08004fb0 <usb_lld_prepare_transmit>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004fb0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 8004fb4:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004fb6:	68dc      	ldr	r4, [r3, #12]
 8004fb8:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8004fba:	6853      	ldr	r3, [r2, #4]
 8004fbc:	6113      	str	r3, [r2, #16]
  if (isp->txsize == 0) {
 8004fbe:	b1a3      	cbz	r3, 8004fea <usb_lld_prepare_transmit+0x3a>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8004fc0:	b169      	cbz	r1, 8004fde <usb_lld_prepare_transmit+0x2e>
 8004fc2:	1e5a      	subs	r2, r3, #1
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8004fc4:	6d00      	ldr	r0, [r0, #80]	; 0x50
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8004fc6:	8a24      	ldrh	r4, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8004fc8:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8004fcc:	4422      	add	r2, r4
 8004fce:	fbb2 f2f4 	udiv	r2, r2, r4
 8004fd2:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8004fd6:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8004fda:	bc10      	pop	{r4}
 8004fdc:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8004fde:	2b40      	cmp	r3, #64	; 0x40
 8004fe0:	d9ef      	bls.n	8004fc2 <usb_lld_prepare_transmit+0x12>
      isp->txsize = EP0_MAX_INSIZE;
 8004fe2:	2340      	movs	r3, #64	; 0x40
 8004fe4:	6053      	str	r3, [r2, #4]
 8004fe6:	223f      	movs	r2, #63	; 0x3f
 8004fe8:	e7ec      	b.n	8004fc4 <usb_lld_prepare_transmit+0x14>

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8004fea:	6d03      	ldr	r3, [r0, #80]	; 0x50
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8004fec:	bc10      	pop	{r4}

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8004fee:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8004ff2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8004ff6:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8004ffa:	4770      	bx	lr
 8004ffc:	0000      	movs	r0, r0
	...

08005000 <otg_epin_handler.constprop.8>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8005000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005004:	4f31      	ldr	r7, [pc, #196]	; (80050cc <otg_epin_handler.constprop.8+0xcc>)
 8005006:	6d3d      	ldr	r5, [r7, #80]	; 0x50
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8005008:	eb05 1340 	add.w	r3, r5, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800500c:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800500e:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 8005012:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8005016:	07e1      	lsls	r1, r4, #31
 8005018:	d503      	bpl.n	8005022 <otg_epin_handler.constprop.8+0x22>
 800501a:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 800501e:	07da      	lsls	r2, r3, #31
 8005020:	d40a      	bmi.n	8005038 <otg_epin_handler.constprop.8+0x38>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8005022:	0623      	lsls	r3, r4, #24
 8005024:	d506      	bpl.n	8005034 <otg_epin_handler.constprop.8+0x34>
 8005026:	2301      	movs	r3, #1
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8005028:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800502c:	fa03 f606 	lsl.w	r6, r3, r6
 8005030:	4216      	tst	r6, r2
 8005032:	d129      	bne.n	8005088 <otg_epin_handler.constprop.8+0x88>
 8005034:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005038:	eb07 0380 	add.w	r3, r7, r0, lsl #2
 800503c:	68d9      	ldr	r1, [r3, #12]
 800503e:	694b      	ldr	r3, [r1, #20]

    if (isp->txsize < isp->totsize) {
 8005040:	6858      	ldr	r0, [r3, #4]
 8005042:	691a      	ldr	r2, [r3, #16]
 8005044:	4290      	cmp	r0, r2
 8005046:	d234      	bcs.n	80050b2 <otg_epin_handler.constprop.8+0xb2>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 8005048:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 800504a:	f04f 0800 	mov.w	r8, #0

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800504e:	605a      	str	r2, [r3, #4]
      isp->txcnt  = 0;
 8005050:	f8c3 8008 	str.w	r8, [r3, #8]
      usb_lld_prepare_transmit(usbp, ep);
 8005054:	4631      	mov	r1, r6
 8005056:	4638      	mov	r0, r7
 8005058:	f7ff ffaa 	bl	8004fb0 <usb_lld_prepare_transmit>
 800505c:	2320      	movs	r3, #32
 800505e:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8005062:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005064:	eb03 1046 	add.w	r0, r3, r6, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8005068:	2201      	movs	r2, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800506a:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 800506e:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8005072:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8005076:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 800507a:	40b2      	lsls	r2, r6
 800507c:	430a      	orrs	r2, r1
 800507e:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 8005082:	f388 8811 	msr	BASEPRI, r8
 8005086:	e7cc      	b.n	8005022 <otg_epin_handler.constprop.8+0x22>
 8005088:	2320      	movs	r3, #32
 800508a:	f383 8811 	msr	BASEPRI, r3
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800508e:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8005092:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8005094:	480e      	ldr	r0, [pc, #56]	; (80050d0 <otg_epin_handler.constprop.8+0xd0>)
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8005096:	ea23 0306 	bic.w	r3, r3, r6
 800509a:	f8c5 3834 	str.w	r3, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800509e:	4316      	orrs	r6, r2
 80050a0:	2100      	movs	r1, #0
 80050a2:	65fe      	str	r6, [r7, #92]	; 0x5c
 80050a4:	f7fc fcac 	bl	8001a00 <chThdResumeI>
 80050a8:	2300      	movs	r3, #0
 80050aa:	f383 8811 	msr	BASEPRI, r3
 80050ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 80050b2:	893a      	ldrh	r2, [r7, #8]
 80050b4:	f8d1 8008 	ldr.w	r8, [r1, #8]
 80050b8:	2301      	movs	r3, #1
 80050ba:	40b3      	lsls	r3, r6
 80050bc:	ea22 0303 	bic.w	r3, r2, r3
 80050c0:	813b      	strh	r3, [r7, #8]
 80050c2:	4631      	mov	r1, r6
 80050c4:	4638      	mov	r0, r7
 80050c6:	47c0      	blx	r8
 80050c8:	e7ab      	b.n	8005022 <otg_epin_handler.constprop.8+0x22>
 80050ca:	bf00      	nop
 80050cc:	200010a8 	.word	0x200010a8
 80050d0:	20001108 	.word	0x20001108
	...

080050e0 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 80050e0:	b570      	push	{r4, r5, r6, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80050e2:	4d3a      	ldr	r5, [pc, #232]	; (80051cc <Vector14C+0xec>)
 80050e4:	6d2e      	ldr	r6, [r5, #80]	; 0x50
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 80050e6:	6974      	ldr	r4, [r6, #20]
  sts &= otgp->GINTMSK;
 80050e8:	69b3      	ldr	r3, [r6, #24]
 80050ea:	401c      	ands	r4, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80050ec:	04e1      	lsls	r1, r4, #19
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 80050ee:	6174      	str	r4, [r6, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80050f0:	d42d      	bmi.n	800514e <Vector14C+0x6e>
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 80050f2:	04a2      	lsls	r2, r4, #18
    (void)otgp->DSTS;
 80050f4:	bf48      	it	mi
 80050f6:	f8d6 3808 	ldrmi.w	r3, [r6, #2056]	; 0x808
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 80050fa:	0723      	lsls	r3, r4, #28
 80050fc:	d504      	bpl.n	8005108 <Vector14C+0x28>
    _usb_isr_invoke_sof_cb(usbp);
 80050fe:	686b      	ldr	r3, [r5, #4]
 8005100:	68db      	ldr	r3, [r3, #12]
 8005102:	b10b      	cbz	r3, 8005108 <Vector14C+0x28>
 8005104:	4831      	ldr	r0, [pc, #196]	; (80051cc <Vector14C+0xec>)
 8005106:	4798      	blx	r3
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8005108:	06e5      	lsls	r5, r4, #27
 800510a:	d42b      	bmi.n	8005164 <Vector14C+0x84>
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
 800510c:	0360      	lsls	r0, r4, #13
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 800510e:	f8d6 5818 	ldr.w	r5, [r6, #2072]	; 0x818
  if (sts & GINTSTS_IEPINT) {
 8005112:	d507      	bpl.n	8005124 <Vector14C+0x44>
    if (src & (1 << 0))
 8005114:	07e9      	lsls	r1, r5, #31
 8005116:	d445      	bmi.n	80051a4 <Vector14C+0xc4>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 8005118:	07aa      	lsls	r2, r5, #30
 800511a:	d448      	bmi.n	80051ae <Vector14C+0xce>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 800511c:	076b      	lsls	r3, r5, #29
 800511e:	d44b      	bmi.n	80051b8 <Vector14C+0xd8>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 8005120:	072e      	lsls	r6, r5, #28
 8005122:	d44e      	bmi.n	80051c2 <Vector14C+0xe2>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8005124:	0324      	lsls	r4, r4, #12
 8005126:	d507      	bpl.n	8005138 <Vector14C+0x58>
    if (src & (1 << 16))
 8005128:	03e8      	lsls	r0, r5, #15
 800512a:	d430      	bmi.n	800518e <Vector14C+0xae>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 800512c:	03a9      	lsls	r1, r5, #14
 800512e:	d433      	bmi.n	8005198 <Vector14C+0xb8>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 8005130:	036a      	lsls	r2, r5, #13
 8005132:	d426      	bmi.n	8005182 <Vector14C+0xa2>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 8005134:	032b      	lsls	r3, r5, #12
 8005136:	d403      	bmi.n	8005140 <Vector14C+0x60>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 8005138:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800513c:	f7fd be78 	b.w	8002e30 <_port_irq_epilogue>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 8005140:	2003      	movs	r0, #3
 8005142:	f7ff fedd 	bl	8004f00 <otg_epout_handler.constprop.7>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 8005146:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800514a:	f7fd be71 	b.w	8002e30 <_port_irq_epilogue>
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
 800514e:	4628      	mov	r0, r5
 8005150:	f7fe faa6 	bl	80036a0 <_usb_reset>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8005154:	686b      	ldr	r3, [r5, #4]
 8005156:	681b      	ldr	r3, [r3, #0]
 8005158:	2b00      	cmp	r3, #0
 800515a:	d0ca      	beq.n	80050f2 <Vector14C+0x12>
 800515c:	2100      	movs	r1, #0
 800515e:	4628      	mov	r0, r5
 8005160:	4798      	blx	r3
 8005162:	e7c6      	b.n	80050f2 <Vector14C+0x12>
 8005164:	2320      	movs	r3, #32
 8005166:	f383 8811 	msr	BASEPRI, r3
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 800516a:	69b3      	ldr	r3, [r6, #24]
 800516c:	4818      	ldr	r0, [pc, #96]	; (80051d0 <Vector14C+0xf0>)
 800516e:	f023 0310 	bic.w	r3, r3, #16
 8005172:	61b3      	str	r3, [r6, #24]
 8005174:	2100      	movs	r1, #0
 8005176:	f7fc fc43 	bl	8001a00 <chThdResumeI>
 800517a:	2300      	movs	r3, #0
 800517c:	f383 8811 	msr	BASEPRI, r3
 8005180:	e7c4      	b.n	800510c <Vector14C+0x2c>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 8005182:	2002      	movs	r0, #2
 8005184:	f7ff febc 	bl	8004f00 <otg_epout_handler.constprop.7>
    if (src & (1 << 19))
 8005188:	032b      	lsls	r3, r5, #12
 800518a:	d5d5      	bpl.n	8005138 <Vector14C+0x58>
 800518c:	e7d8      	b.n	8005140 <Vector14C+0x60>
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 800518e:	2000      	movs	r0, #0
 8005190:	f7ff feb6 	bl	8004f00 <otg_epout_handler.constprop.7>
    if (src & (1 << 17))
 8005194:	03a9      	lsls	r1, r5, #14
 8005196:	d5cb      	bpl.n	8005130 <Vector14C+0x50>
      otg_epout_handler(usbp, 1);
 8005198:	2001      	movs	r0, #1
 800519a:	f7ff feb1 	bl	8004f00 <otg_epout_handler.constprop.7>
    if (src & (1 << 18))
 800519e:	036a      	lsls	r2, r5, #13
 80051a0:	d5c8      	bpl.n	8005134 <Vector14C+0x54>
 80051a2:	e7ee      	b.n	8005182 <Vector14C+0xa2>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 80051a4:	2000      	movs	r0, #0
 80051a6:	f7ff ff2b 	bl	8005000 <otg_epin_handler.constprop.8>
    if (src & (1 << 1))
 80051aa:	07aa      	lsls	r2, r5, #30
 80051ac:	d5b6      	bpl.n	800511c <Vector14C+0x3c>
      otg_epin_handler(usbp, 1);
 80051ae:	2001      	movs	r0, #1
 80051b0:	f7ff ff26 	bl	8005000 <otg_epin_handler.constprop.8>
    if (src & (1 << 2))
 80051b4:	076b      	lsls	r3, r5, #29
 80051b6:	d5b3      	bpl.n	8005120 <Vector14C+0x40>
      otg_epin_handler(usbp, 2);
 80051b8:	2002      	movs	r0, #2
 80051ba:	f7ff ff21 	bl	8005000 <otg_epin_handler.constprop.8>
    if (src & (1 << 3))
 80051be:	072e      	lsls	r6, r5, #28
 80051c0:	d5b0      	bpl.n	8005124 <Vector14C+0x44>
      otg_epin_handler(usbp, 3);
 80051c2:	2003      	movs	r0, #3
 80051c4:	f7ff ff1c 	bl	8005000 <otg_epin_handler.constprop.8>
 80051c8:	e7ac      	b.n	8005124 <Vector14C+0x44>
 80051ca:	bf00      	nop
 80051cc:	200010a8 	.word	0x200010a8
 80051d0:	20001108 	.word	0x20001108
	...

080051e0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80051e0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80051e2:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 80051e6:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80051ea:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80051ee:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 80051f2:	4770      	bx	lr
	...

08005200 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8005200:	6d03      	ldr	r3, [r0, #80]	; 0x50
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8005202:	b410      	push	{r4}
 8005204:	eb03 1441 	add.w	r4, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8005208:	2001      	movs	r0, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800520a:	f8d4 2900 	ldr.w	r2, [r4, #2304]	; 0x900
 800520e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8005212:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8005216:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
}
 800521a:	bc10      	pop	{r4}
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800521c:	fa00 f101 	lsl.w	r1, r0, r1
 8005220:	4311      	orrs	r1, r2
 8005222:	f8c3 1834 	str.w	r1, [r3, #2100]	; 0x834
}
 8005226:	4770      	bx	lr
	...

08005230 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8005230:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8005232:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8005236:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 800523a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800523e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8005242:	4770      	bx	lr
	...

08005250 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8005250:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8005252:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8005256:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 800525a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800525e:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 8005262:	4770      	bx	lr
	...

08005270 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8005270:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8005272:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8005276:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 800527a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800527e:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8005282:	4770      	bx	lr
	...

08005290 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8005290:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8005292:	eb03 1141 	add.w	r1, r3, r1, lsl #5

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8005296:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 800529a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800529e:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 80052a2:	4770      	bx	lr
	...

080052b0 <spi_lld_serve_tx_interrupt>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80052b0:	f011 0f0c 	tst.w	r1, #12
 80052b4:	d100      	bne.n	80052b8 <spi_lld_serve_tx_interrupt+0x8>
 80052b6:	4770      	bx	lr
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 80052b8:	4801      	ldr	r0, [pc, #4]	; (80052c0 <spi_lld_serve_tx_interrupt+0x10>)
 80052ba:	f7fb bfb9 	b.w	8001230 <chSysHalt>
 80052be:	bf00      	nop
 80052c0:	0800a5e0 	.word	0x0800a5e0
	...

080052d0 <spi_lld_serve_rx_interrupt>:
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80052d0:	f011 0f0c 	tst.w	r1, #12
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 80052d4:	b538      	push	{r3, r4, r5, lr}
 80052d6:	4604      	mov	r4, r0

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80052d8:	d134      	bne.n	8005344 <spi_lld_serve_rx_interrupt+0x74>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 80052da:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80052dc:	6802      	ldr	r2, [r0, #0]
 80052de:	6813      	ldr	r3, [r2, #0]
 80052e0:	f023 031f 	bic.w	r3, r3, #31
 80052e4:	6013      	str	r3, [r2, #0]
 80052e6:	6813      	ldr	r3, [r2, #0]
 80052e8:	07d9      	lsls	r1, r3, #31
 80052ea:	d4fc      	bmi.n	80052e6 <spi_lld_serve_rx_interrupt+0x16>
 80052ec:	7a05      	ldrb	r5, [r0, #8]
  dmaStreamDisable(spip->dmarx);
 80052ee:	6a21      	ldr	r1, [r4, #32]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 80052f0:	6840      	ldr	r0, [r0, #4]
  dmaStreamDisable(spip->dmarx);
 80052f2:	680a      	ldr	r2, [r1, #0]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 80052f4:	233d      	movs	r3, #61	; 0x3d
 80052f6:	40ab      	lsls	r3, r5
 80052f8:	6003      	str	r3, [r0, #0]
  dmaStreamDisable(spip->dmarx);
 80052fa:	6813      	ldr	r3, [r2, #0]
 80052fc:	f023 031f 	bic.w	r3, r3, #31
 8005300:	6013      	str	r3, [r2, #0]
 8005302:	6813      	ldr	r3, [r2, #0]
 8005304:	07db      	lsls	r3, r3, #31
 8005306:	d4fc      	bmi.n	8005302 <spi_lld_serve_rx_interrupt+0x32>

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8005308:	6863      	ldr	r3, [r4, #4]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 800530a:	7a08      	ldrb	r0, [r1, #8]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800530c:	681a      	ldr	r2, [r3, #0]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 800530e:	6849      	ldr	r1, [r1, #4]
 8005310:	233d      	movs	r3, #61	; 0x3d
 8005312:	4083      	lsls	r3, r0
 8005314:	600b      	str	r3, [r1, #0]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8005316:	b192      	cbz	r2, 800533e <spi_lld_serve_rx_interrupt+0x6e>
 8005318:	2304      	movs	r3, #4
 800531a:	7023      	strb	r3, [r4, #0]
 800531c:	4620      	mov	r0, r4
 800531e:	4790      	blx	r2
 8005320:	7823      	ldrb	r3, [r4, #0]
 8005322:	2b04      	cmp	r3, #4
 8005324:	d00b      	beq.n	800533e <spi_lld_serve_rx_interrupt+0x6e>
 8005326:	2320      	movs	r3, #32
 8005328:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800532c:	2100      	movs	r1, #0
 800532e:	f104 0008 	add.w	r0, r4, #8
 8005332:	f7fc fb65 	bl	8001a00 <chThdResumeI>
 8005336:	2300      	movs	r3, #0
 8005338:	f383 8811 	msr	BASEPRI, r3
 800533c:	bd38      	pop	{r3, r4, r5, pc}
 800533e:	2302      	movs	r3, #2
 8005340:	7023      	strb	r3, [r4, #0]
 8005342:	e7f0      	b.n	8005326 <spi_lld_serve_rx_interrupt+0x56>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8005344:	4801      	ldr	r0, [pc, #4]	; (800534c <spi_lld_serve_rx_interrupt+0x7c>)
 8005346:	f7fb ff73 	bl	8001230 <chSysHalt>
 800534a:	e7c6      	b.n	80052da <spi_lld_serve_rx_interrupt+0xa>
 800534c:	0800a5e0 	.word	0x0800a5e0

08005350 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8005350:	b570      	push	{r4, r5, r6, lr}

  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 8005352:	4e11      	ldr	r6, [pc, #68]	; (8005398 <spi_lld_init+0x48>)
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 8005354:	4b11      	ldr	r3, [pc, #68]	; (800539c <spi_lld_init+0x4c>)
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 8005356:	4c12      	ldr	r4, [pc, #72]	; (80053a0 <spi_lld_init+0x50>)
  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8005358:	4d12      	ldr	r5, [pc, #72]	; (80053a4 <spi_lld_init+0x54>)
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 800535a:	f64f 72ff 	movw	r2, #65535	; 0xffff

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 800535e:	4630      	mov	r0, r6
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 8005360:	801a      	strh	r2, [r3, #0]

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 8005362:	f7fe f89d 	bl	80034a0 <spiObjectInit>
  SPID1.spi       = SPI1;
 8005366:	4910      	ldr	r1, [pc, #64]	; (80053a8 <spi_lld_init+0x58>)
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8005368:	4a10      	ldr	r2, [pc, #64]	; (80053ac <spi_lld_init+0x5c>)
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800536a:	4b11      	ldr	r3, [pc, #68]	; (80053b0 <spi_lld_init+0x60>)

  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 800536c:	61f1      	str	r1, [r6, #28]
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800536e:	4620      	mov	r0, r4

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8005370:	f105 0124 	add.w	r1, r5, #36	; 0x24
  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8005374:	6235      	str	r5, [r6, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8005376:	6271      	str	r1, [r6, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8005378:	62b2      	str	r2, [r6, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800537a:	62f3      	str	r3, [r6, #44]	; 0x2c
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800537c:	f7fe f890 	bl	80034a0 <spiObjectInit>
  SPID2.spi       = SPI2;
 8005380:	490c      	ldr	r1, [pc, #48]	; (80053b4 <spi_lld_init+0x64>)
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8005382:	4a0d      	ldr	r2, [pc, #52]	; (80053b8 <spi_lld_init+0x68>)
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8005384:	4b0d      	ldr	r3, [pc, #52]	; (80053bc <spi_lld_init+0x6c>)
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 8005386:	61e1      	str	r1, [r4, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8005388:	f1a5 013c 	sub.w	r1, r5, #60	; 0x3c
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800538c:	3d30      	subs	r5, #48	; 0x30
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800538e:	6221      	str	r1, [r4, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8005390:	6265      	str	r5, [r4, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8005392:	62a2      	str	r2, [r4, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8005394:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005396:	bd70      	pop	{r4, r5, r6, pc}
 8005398:	20001278 	.word	0x20001278
 800539c:	20001274 	.word	0x20001274
 80053a0:	200012a8 	.word	0x200012a8
 80053a4:	0800a530 	.word	0x0800a530
 80053a8:	40013000 	.word	0x40013000
 80053ac:	06010016 	.word	0x06010016
 80053b0:	06010046 	.word	0x06010046
 80053b4:	40003800 	.word	0x40003800
 80053b8:	00010016 	.word	0x00010016
 80053bc:	00010046 	.word	0x00010046

080053c0 <spi_lld_start>:
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 80053c0:	7803      	ldrb	r3, [r0, #0]
 80053c2:	2b01      	cmp	r3, #1
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 80053c4:	b510      	push	{r4, lr}
 80053c6:	4604      	mov	r4, r0

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 80053c8:	d01d      	beq.n	8005406 <spi_lld_start+0x46>
 80053ca:	69c3      	ldr	r3, [r0, #28]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80053cc:	6862      	ldr	r2, [r4, #4]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053ce:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80053d0:	8952      	ldrh	r2, [r2, #10]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053d2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053d4:	f420 40f0 	bic.w	r0, r0, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053d8:	f421 41f0 	bic.w	r1, r1, #30720	; 0x7800
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80053dc:	f412 6f00 	tst.w	r2, #2048	; 0x800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053e0:	bf1c      	itt	ne
 80053e2:	f440 5020 	orrne.w	r0, r0, #10240	; 0x2800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053e6:	f441 5120 	orrne.w	r1, r1, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053ea:	62a0      	str	r0, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80053ec:	62e1      	str	r1, [r4, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80053ee:	f442 7241 	orr.w	r2, r2, #772	; 0x304
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 80053f2:	2000      	movs	r0, #0
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 80053f4:	2107      	movs	r1, #7
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 80053f6:	6018      	str	r0, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80053f8:	601a      	str	r2, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 80053fa:	6059      	str	r1, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 80053fc:	681a      	ldr	r2, [r3, #0]
 80053fe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005402:	601a      	str	r2, [r3, #0]
 8005404:	bd10      	pop	{r4, pc}
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
 8005406:	4b1a      	ldr	r3, [pc, #104]	; (8005470 <spi_lld_start+0xb0>)
 8005408:	4298      	cmp	r0, r3
 800540a:	d00c      	beq.n	8005426 <spi_lld_start+0x66>
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800540c:	4b19      	ldr	r3, [pc, #100]	; (8005474 <spi_lld_start+0xb4>)
 800540e:	4298      	cmp	r0, r3
 8005410:	d01b      	beq.n	800544a <spi_lld_start+0x8a>
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8005412:	6a21      	ldr	r1, [r4, #32]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8005414:	6a62      	ldr	r2, [r4, #36]	; 0x24
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8005416:	69e3      	ldr	r3, [r4, #28]
 8005418:	6808      	ldr	r0, [r1, #0]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800541a:	6811      	ldr	r1, [r2, #0]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800541c:	f103 020c 	add.w	r2, r3, #12
 8005420:	6082      	str	r2, [r0, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8005422:	608a      	str	r2, [r1, #8]
 8005424:	e7d2      	b.n	80053cc <spi_lld_start+0xc>
  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 8005426:	4603      	mov	r3, r0
 8005428:	4a13      	ldr	r2, [pc, #76]	; (8005478 <spi_lld_start+0xb8>)
 800542a:	6a00      	ldr	r0, [r0, #32]
 800542c:	210a      	movs	r1, #10
 800542e:	f7fe fd87 	bl	8003f40 <dmaStreamAllocate>
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 8005432:	4623      	mov	r3, r4
 8005434:	4a11      	ldr	r2, [pc, #68]	; (800547c <spi_lld_start+0xbc>)
 8005436:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005438:	210a      	movs	r1, #10
 800543a:	f7fe fd81 	bl	8003f40 <dmaStreamAllocate>
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
 800543e:	4a10      	ldr	r2, [pc, #64]	; (8005480 <spi_lld_start+0xc0>)
 8005440:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8005442:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8005446:	6453      	str	r3, [r2, #68]	; 0x44
 8005448:	e7e3      	b.n	8005412 <spi_lld_start+0x52>
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800544a:	4603      	mov	r3, r0
 800544c:	4a0a      	ldr	r2, [pc, #40]	; (8005478 <spi_lld_start+0xb8>)
 800544e:	6a00      	ldr	r0, [r0, #32]
 8005450:	210a      	movs	r1, #10
 8005452:	f7fe fd75 	bl	8003f40 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 8005456:	4623      	mov	r3, r4
 8005458:	4a08      	ldr	r2, [pc, #32]	; (800547c <spi_lld_start+0xbc>)
 800545a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800545c:	210a      	movs	r1, #10
 800545e:	f7fe fd6f 	bl	8003f40 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 8005462:	4a07      	ldr	r2, [pc, #28]	; (8005480 <spi_lld_start+0xc0>)
 8005464:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8005466:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800546a:	6413      	str	r3, [r2, #64]	; 0x40
 800546c:	e7d1      	b.n	8005412 <spi_lld_start+0x52>
 800546e:	bf00      	nop
 8005470:	20001278 	.word	0x20001278
 8005474:	200012a8 	.word	0x200012a8
 8005478:	080052d1 	.word	0x080052d1
 800547c:	080052b1 	.word	0x080052b1
 8005480:	40023800 	.word	0x40023800
	...

08005490 <spi_lld_select>:
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {

  palClearPad(spip->config->ssport, spip->config->sspad);
 8005490:	6842      	ldr	r2, [r0, #4]
 8005492:	8911      	ldrh	r1, [r2, #8]
 8005494:	6852      	ldr	r2, [r2, #4]
 8005496:	2301      	movs	r3, #1
 8005498:	408b      	lsls	r3, r1
 800549a:	b29b      	uxth	r3, r3
 800549c:	8353      	strh	r3, [r2, #26]
 800549e:	4770      	bx	lr

080054a0 <spi_lld_unselect>:
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {

  palSetPad(spip->config->ssport, spip->config->sspad);
 80054a0:	6842      	ldr	r2, [r0, #4]
 80054a2:	8911      	ldrh	r1, [r2, #8]
 80054a4:	6852      	ldr	r2, [r2, #4]
 80054a6:	2301      	movs	r3, #1
 80054a8:	408b      	lsls	r3, r1
 80054aa:	b29b      	uxth	r3, r3
 80054ac:	8313      	strh	r3, [r2, #24]
 80054ae:	4770      	bx	lr

080054b0 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 80054b0:	b4f0      	push	{r4, r5, r6, r7}

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80054b2:	6a04      	ldr	r4, [r0, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80054b4:	6a47      	ldr	r7, [r0, #36]	; 0x24
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80054b6:	6a86      	ldr	r6, [r0, #40]	; 0x28

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80054b8:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80054ba:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80054bc:	6838      	ldr	r0, [r7, #0]
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80054be:	60e3      	str	r3, [r4, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80054c0:	f446 6680 	orr.w	r6, r6, #1024	; 0x400

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80054c4:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80054c8:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80054ca:	6026      	str	r6, [r4, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80054cc:	60c2      	str	r2, [r0, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80054ce:	6041      	str	r1, [r0, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80054d0:	6005      	str	r5, [r0, #0]

  dmaStreamEnable(spip->dmarx);
 80054d2:	6823      	ldr	r3, [r4, #0]
 80054d4:	f043 0301 	orr.w	r3, r3, #1
 80054d8:	6023      	str	r3, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 80054da:	6803      	ldr	r3, [r0, #0]
 80054dc:	f043 0301 	orr.w	r3, r3, #1
 80054e0:	6003      	str	r3, [r0, #0]
}
 80054e2:	bcf0      	pop	{r4, r5, r6, r7}
 80054e4:	4770      	bx	lr
 80054e6:	bf00      	nop
	...

080054f0 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 80054f0:	b470      	push	{r4, r5, r6}

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80054f2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80054f4:	6a04      	ldr	r4, [r0, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80054f6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80054f8:	6824      	ldr	r4, [r4, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80054fa:	681b      	ldr	r3, [r3, #0]
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 80054fc:	6a80      	ldr	r0, [r0, #40]	; 0x28
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 80054fe:	4e09      	ldr	r6, [pc, #36]	; (8005524 <spi_lld_send+0x34>)
 8005500:	60e6      	str	r6, [r4, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8005502:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8005506:	6061      	str	r1, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8005508:	6020      	str	r0, [r4, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800550a:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800550c:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800550e:	601d      	str	r5, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 8005510:	6822      	ldr	r2, [r4, #0]
 8005512:	f042 0201 	orr.w	r2, r2, #1
 8005516:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 8005518:	681a      	ldr	r2, [r3, #0]
 800551a:	f042 0201 	orr.w	r2, r2, #1
 800551e:	601a      	str	r2, [r3, #0]
}
 8005520:	bc70      	pop	{r4, r5, r6}
 8005522:	4770      	bx	lr
 8005524:	200012d8 	.word	0x200012d8
	...

08005530 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8005530:	b538      	push	{r3, r4, r5, lr}
 * @param[in] pwmp      pointer to a @p PWMDriver object
 */
static void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8005532:	4d17      	ldr	r5, [pc, #92]	; (8005590 <VectorB8+0x60>)
 8005534:	69ab      	ldr	r3, [r5, #24]
 8005536:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8005538:	68da      	ldr	r2, [r3, #12]
 800553a:	4014      	ands	r4, r2
  pwmp->tim->SR = ~sr;
 800553c:	b2e2      	uxtb	r2, r4
 800553e:	43d2      	mvns	r2, r2
 8005540:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005542:	07a3      	lsls	r3, r4, #30
 8005544:	d504      	bpl.n	8005550 <VectorB8+0x20>
      (pwmp->config->channels[0].callback != NULL))
 8005546:	686b      	ldr	r3, [r5, #4]
 8005548:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800554a:	b10b      	cbz	r3, 8005550 <VectorB8+0x20>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 800554c:	4628      	mov	r0, r5
 800554e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8005550:	0760      	lsls	r0, r4, #29
 8005552:	d504      	bpl.n	800555e <VectorB8+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 8005554:	686b      	ldr	r3, [r5, #4]
 8005556:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8005558:	b10b      	cbz	r3, 800555e <VectorB8+0x2e>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 800555a:	480d      	ldr	r0, [pc, #52]	; (8005590 <VectorB8+0x60>)
 800555c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800555e:	0721      	lsls	r1, r4, #28
 8005560:	d504      	bpl.n	800556c <VectorB8+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 8005562:	686b      	ldr	r3, [r5, #4]
 8005564:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8005566:	b10b      	cbz	r3, 800556c <VectorB8+0x3c>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8005568:	4809      	ldr	r0, [pc, #36]	; (8005590 <VectorB8+0x60>)
 800556a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800556c:	06e2      	lsls	r2, r4, #27
 800556e:	d504      	bpl.n	800557a <VectorB8+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 8005570:	686b      	ldr	r3, [r5, #4]
 8005572:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8005574:	b10b      	cbz	r3, 800557a <VectorB8+0x4a>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8005576:	4806      	ldr	r0, [pc, #24]	; (8005590 <VectorB8+0x60>)
 8005578:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 800557a:	07e3      	lsls	r3, r4, #31
 800557c:	d504      	bpl.n	8005588 <VectorB8+0x58>
 800557e:	686b      	ldr	r3, [r5, #4]
 8005580:	689b      	ldr	r3, [r3, #8]
 8005582:	b10b      	cbz	r3, 8005588 <VectorB8+0x58>
    pwmp->config->callback(pwmp);
 8005584:	4802      	ldr	r0, [pc, #8]	; (8005590 <VectorB8+0x60>)
 8005586:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
}
 8005588:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
 800558c:	f7fd bc50 	b.w	8002e30 <_port_irq_epilogue>
 8005590:	200012dc 	.word	0x200012dc
	...

080055a0 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 80055a0:	b510      	push	{r4, lr}
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 80055a2:	4c04      	ldr	r4, [pc, #16]	; (80055b4 <pwm_lld_init+0x14>)
 80055a4:	4620      	mov	r0, r4
 80055a6:	f7fd fcf3 	bl	8002f90 <pwmObjectInit>
  PWMD4.channels = STM32_TIM4_CHANNELS;
 80055aa:	2204      	movs	r2, #4
  PWMD4.tim = STM32_TIM4;
 80055ac:	4b02      	ldr	r3, [pc, #8]	; (80055b8 <pwm_lld_init+0x18>)
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
  PWMD4.channels = STM32_TIM4_CHANNELS;
 80055ae:	7422      	strb	r2, [r4, #16]
  PWMD4.tim = STM32_TIM4;
 80055b0:	61a3      	str	r3, [r4, #24]
 80055b2:	bd10      	pop	{r4, pc}
 80055b4:	200012dc 	.word	0x200012dc
 80055b8:	40000800 	.word	0x40000800
 80055bc:	00000000 	.word	0x00000000

080055c0 <pwm_lld_start>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 80055c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 80055c2:	7803      	ldrb	r3, [r0, #0]
 80055c4:	2b01      	cmp	r3, #1
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 80055c6:	4604      	mov	r4, r0
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 80055c8:	d04b      	beq.n	8005662 <pwm_lld_start+0xa2>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 80055ca:	6983      	ldr	r3, [r0, #24]
 80055cc:	2200      	movs	r2, #0
 80055ce:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 80055d0:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 80055d2:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 80055d4:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 80055d6:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 80055d8:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 80055da:	6861      	ldr	r1, [r4, #4]
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
 80055dc:	68a5      	ldr	r5, [r4, #8]
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80055de:	68ca      	ldr	r2, [r1, #12]
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 80055e0:	6960      	ldr	r0, [r4, #20]
 80055e2:	680f      	ldr	r7, [r1, #0]
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;
 80055e4:	6ace      	ldr	r6, [r1, #44]	; 0x2c
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 80055e6:	fbb0 f0f7 	udiv	r0, r0, r7
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80055ea:	f002 020f 	and.w	r2, r2, #15
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
 80055ee:	1e6c      	subs	r4, r5, #1
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 80055f0:	3801      	subs	r0, #1
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80055f2:	2a01      	cmp	r2, #1
  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 80055f4:	6298      	str	r0, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 80055f6:	62dc      	str	r4, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 80055f8:	605e      	str	r6, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 80055fa:	d003      	beq.n	8005604 <pwm_lld_start+0x44>
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
 80055fc:	2a02      	cmp	r2, #2
 80055fe:	bf0c      	ite	eq
 8005600:	2203      	moveq	r2, #3
 8005602:	2200      	movne	r2, #0
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8005604:	6948      	ldr	r0, [r1, #20]
 8005606:	f000 000f 	and.w	r0, r0, #15
 800560a:	2801      	cmp	r0, #1
 800560c:	d026      	beq.n	800565c <pwm_lld_start+0x9c>
 800560e:	2802      	cmp	r0, #2
 8005610:	d022      	beq.n	8005658 <pwm_lld_start+0x98>
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8005612:	69c8      	ldr	r0, [r1, #28]
 8005614:	f000 000f 	and.w	r0, r0, #15
 8005618:	2801      	cmp	r0, #1
 800561a:	d01a      	beq.n	8005652 <pwm_lld_start+0x92>
 800561c:	2802      	cmp	r0, #2
 800561e:	d016      	beq.n	800564e <pwm_lld_start+0x8e>
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8005620:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8005622:	f000 000f 	and.w	r0, r0, #15
 8005626:	2801      	cmp	r0, #1
 8005628:	d003      	beq.n	8005632 <pwm_lld_start+0x72>
 800562a:	2802      	cmp	r0, #2
 800562c:	d103      	bne.n	8005636 <pwm_lld_start+0x76>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 800562e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 8005632:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8005636:	6b09      	ldr	r1, [r1, #48]	; 0x30
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 8005638:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 800563a:	2401      	movs	r4, #1
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800563c:	f021 02ff 	bic.w	r2, r1, #255	; 0xff
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8005640:	2000      	movs	r0, #0
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8005642:	2185      	movs	r1, #133	; 0x85
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8005644:	615c      	str	r4, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8005646:	6118      	str	r0, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8005648:	60da      	str	r2, [r3, #12]
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 800564a:	6019      	str	r1, [r3, #0]
 800564c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 800564e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8005652:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005656:	e7e3      	b.n	8005620 <pwm_lld_start+0x60>
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8005658:	f042 0220 	orr.w	r2, r2, #32
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 800565c:	f042 0210 	orr.w	r2, r2, #16
 8005660:	e7d7      	b.n	8005612 <pwm_lld_start+0x52>
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_PWM_TIM3_IRQ_PRIORITY);
      pwmp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
 8005662:	4b0d      	ldr	r3, [pc, #52]	; (8005698 <pwm_lld_start+0xd8>)
 8005664:	4298      	cmp	r0, r3
 8005666:	d005      	beq.n	8005674 <pwm_lld_start+0xb4>
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8005668:	69a3      	ldr	r3, [r4, #24]
 800566a:	f646 0268 	movw	r2, #26728	; 0x6868
 800566e:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8005670:	61da      	str	r2, [r3, #28]
 8005672:	e7b2      	b.n	80055da <pwm_lld_start+0x1a>
      pwmp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
      rccEnableTIM4(FALSE);
 8005674:	4b09      	ldr	r3, [pc, #36]	; (800569c <pwm_lld_start+0xdc>)
 8005676:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005678:	f042 0204 	orr.w	r2, r2, #4
 800567c:	641a      	str	r2, [r3, #64]	; 0x40
      rccResetTIM4();
 800567e:	6a1a      	ldr	r2, [r3, #32]
 8005680:	2000      	movs	r0, #0
 8005682:	f042 0204 	orr.w	r2, r2, #4
 8005686:	621a      	str	r2, [r3, #32]
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_PWM_TIM4_IRQ_PRIORITY);
 8005688:	2107      	movs	r1, #7
    }
#endif
#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
      rccEnableTIM4(FALSE);
      rccResetTIM4();
 800568a:	6218      	str	r0, [r3, #32]
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_PWM_TIM4_IRQ_PRIORITY);
 800568c:	201e      	movs	r0, #30
 800568e:	f7fe fa87 	bl	8003ba0 <nvicEnableVector>
      pwmp->clock = STM32_TIMCLK1;
 8005692:	4b03      	ldr	r3, [pc, #12]	; (80056a0 <pwm_lld_start+0xe0>)
 8005694:	6163      	str	r3, [r4, #20]
 8005696:	e7e7      	b.n	8005668 <pwm_lld_start+0xa8>
 8005698:	200012dc 	.word	0x200012dc
 800569c:	40023800 	.word	0x40023800
 80056a0:	0501bd00 	.word	0x0501bd00
	...

080056b0 <pwm_lld_enable_channel>:
                            pwmchannel_t channel,
                            pwmcnt_t width) {

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 80056b0:	6983      	ldr	r3, [r0, #24]
 80056b2:	310c      	adds	r1, #12
 80056b4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80056b8:	605a      	str	r2, [r3, #4]
 80056ba:	4770      	bx	lr
 80056bc:	0000      	movs	r0, r0
	...

080056c0 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80056c0:	4a02      	ldr	r2, [pc, #8]	; (80056cc <notify2+0xc>)
 80056c2:	68d3      	ldr	r3, [r2, #12]
 80056c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80056c8:	60d3      	str	r3, [r2, #12]
 80056ca:	4770      	bx	lr
 80056cc:	40004400 	.word	0x40004400

080056d0 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80056d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 80056d2:	4e43      	ldr	r6, [pc, #268]	; (80057e0 <VectorD8+0x110>)
 80056d4:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 80056d6:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 80056d8:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80056da:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 80056dc:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80056de:	d44f      	bmi.n	8005780 <VectorD8+0xb0>
 80056e0:	2320      	movs	r3, #32
 80056e2:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80056e6:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80056ea:	d108      	bne.n	80056fe <VectorD8+0x2e>
 80056ec:	e029      	b.n	8005742 <VectorD8+0x72>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 80056ee:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80056f0:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 80056f2:	d41d      	bmi.n	8005730 <VectorD8+0x60>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80056f4:	682c      	ldr	r4, [r5, #0]
 80056f6:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80056f8:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80056fc:	d021      	beq.n	8005742 <VectorD8+0x72>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80056fe:	0723      	lsls	r3, r4, #28
 8005700:	d0f5      	beq.n	80056ee <VectorD8+0x1e>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8005702:	f014 0f08 	tst.w	r4, #8
 8005706:	bf0c      	ite	eq
 8005708:	2100      	moveq	r1, #0
 800570a:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 800570c:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 800570e:	bf48      	it	mi
 8005710:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8005714:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8005716:	bf48      	it	mi
 8005718:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 800571c:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 800571e:	bf48      	it	mi
 8005720:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8005724:	482f      	ldr	r0, [pc, #188]	; (80057e4 <VectorD8+0x114>)
 8005726:	f7fc fe1b 	bl	8002360 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 800572a:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 800572c:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 800572e:	d5e1      	bpl.n	80056f4 <VectorD8+0x24>
      sdIncomingDataI(sdp, b);
 8005730:	b2c9      	uxtb	r1, r1
 8005732:	482b      	ldr	r0, [pc, #172]	; (80057e0 <VectorD8+0x110>)
 8005734:	f7fd fcd4 	bl	80030e0 <sdIncomingDataI>
    sr = u->SR;
 8005738:	682c      	ldr	r4, [r5, #0]
 800573a:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800573c:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8005740:	d1dd      	bne.n	80056fe <VectorD8+0x2e>
 8005742:	2300      	movs	r3, #0
 8005744:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8005748:	0639      	lsls	r1, r7, #24
 800574a:	d501      	bpl.n	8005750 <VectorD8+0x80>
 800574c:	0622      	lsls	r2, r4, #24
 800574e:	d426      	bmi.n	800579e <VectorD8+0xce>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8005750:	0663      	lsls	r3, r4, #25
 8005752:	d511      	bpl.n	8005778 <VectorD8+0xa8>
 8005754:	2320      	movs	r3, #32
 8005756:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800575a:	6c72      	ldr	r2, [r6, #68]	; 0x44
 800575c:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 800575e:	4820      	ldr	r0, [pc, #128]	; (80057e0 <VectorD8+0x110>)
 8005760:	429a      	cmp	r2, r3
 8005762:	d029      	beq.n	80057b8 <VectorD8+0xe8>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8005764:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8005768:	403b      	ands	r3, r7
    u->SR = ~USART_SR_TC;
 800576a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800576e:	60eb      	str	r3, [r5, #12]
 8005770:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8005772:	602a      	str	r2, [r5, #0]
 8005774:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 8005778:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 800577c:	f7fd bb58 	b.w	8002e30 <_port_irq_epilogue>
 8005780:	2320      	movs	r3, #32
 8005782:	f383 8811 	msr	BASEPRI, r3
 8005786:	f44f 7100 	mov.w	r1, #512	; 0x200
 800578a:	1d30      	adds	r0, r6, #4
 800578c:	f7fc fde8 	bl	8002360 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8005790:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8005794:	602b      	str	r3, [r5, #0]
 8005796:	2300      	movs	r3, #0
 8005798:	f383 8811 	msr	BASEPRI, r3
 800579c:	e7a0      	b.n	80056e0 <VectorD8+0x10>
 800579e:	2320      	movs	r3, #32
 80057a0:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 80057a4:	4810      	ldr	r0, [pc, #64]	; (80057e8 <VectorD8+0x118>)
 80057a6:	f7fd f95b 	bl	8002a60 <chOQGetI>
    if (b < Q_OK) {
 80057aa:	2800      	cmp	r0, #0
 80057ac:	db0c      	blt.n	80057c8 <VectorD8+0xf8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 80057ae:	6068      	str	r0, [r5, #4]
 80057b0:	2300      	movs	r3, #0
 80057b2:	f383 8811 	msr	BASEPRI, r3
 80057b6:	e7cb      	b.n	8005750 <VectorD8+0x80>
 80057b8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80057ba:	2b00      	cmp	r3, #0
 80057bc:	d0d2      	beq.n	8005764 <VectorD8+0x94>
 80057be:	3004      	adds	r0, #4
 80057c0:	2110      	movs	r1, #16
 80057c2:	f7fc fdcd 	bl	8002360 <chEvtBroadcastFlagsI>
 80057c6:	e7cd      	b.n	8005764 <VectorD8+0x94>
 80057c8:	2108      	movs	r1, #8
 80057ca:	4806      	ldr	r0, [pc, #24]	; (80057e4 <VectorD8+0x114>)
 80057cc:	f7fc fdc8 	bl	8002360 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80057d0:	f64f 733f 	movw	r3, #65343	; 0xff3f
 80057d4:	403b      	ands	r3, r7
 80057d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80057da:	60eb      	str	r3, [r5, #12]
 80057dc:	e7e8      	b.n	80057b0 <VectorD8+0xe0>
 80057de:	bf00      	nop
 80057e0:	200012f8 	.word	0x200012f8
 80057e4:	200012fc 	.word	0x200012fc
 80057e8:	20001328 	.word	0x20001328
 80057ec:	00000000 	.word	0x00000000

080057f0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80057f0:	b510      	push	{r4, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80057f2:	4c04      	ldr	r4, [pc, #16]	; (8005804 <sd_lld_init+0x14>)
 80057f4:	4a04      	ldr	r2, [pc, #16]	; (8005808 <sd_lld_init+0x18>)
 80057f6:	4620      	mov	r0, r4
 80057f8:	2100      	movs	r1, #0
 80057fa:	f7fd fc41 	bl	8003080 <sdObjectInit>
  SD2.usart = USART2;
 80057fe:	4b03      	ldr	r3, [pc, #12]	; (800580c <sd_lld_init+0x1c>)
 8005800:	6763      	str	r3, [r4, #116]	; 0x74
 8005802:	bd10      	pop	{r4, pc}
 8005804:	200012f8 	.word	0x200012f8
 8005808:	080056c1 	.word	0x080056c1
 800580c:	40004400 	.word	0x40004400

08005810 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8005810:	b538      	push	{r3, r4, r5, lr}

  if (config == NULL)
    config = &default_config;
 8005812:	4c1f      	ldr	r4, [pc, #124]	; (8005890 <sd_lld_start+0x80>)

  if (sdp->state == SD_STOP) {
 8005814:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8005816:	2900      	cmp	r1, #0
 8005818:	bf18      	it	ne
 800581a:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 800581c:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800581e:	4605      	mov	r5, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8005820:	d022      	beq.n	8005868 <sd_lld_start+0x58>
 8005822:	6f6b      	ldr	r3, [r5, #116]	; 0x74
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8005824:	4a1b      	ldr	r2, [pc, #108]	; (8005894 <sd_lld_start+0x84>)
 8005826:	4293      	cmp	r3, r2
 8005828:	d02b      	beq.n	8005882 <sd_lld_start+0x72>
 800582a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800582e:	4293      	cmp	r3, r2
 8005830:	d027      	beq.n	8005882 <sd_lld_start+0x72>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8005832:	6821      	ldr	r1, [r4, #0]
 8005834:	4a18      	ldr	r2, [pc, #96]	; (8005898 <sd_lld_start+0x88>)
 8005836:	fbb2 f2f1 	udiv	r2, r2, r1
 800583a:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800583c:	88a2      	ldrh	r2, [r4, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800583e:	88e0      	ldrh	r0, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005840:	8921      	ldrh	r1, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8005842:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005846:	f040 0040 	orr.w	r0, r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800584a:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800584e:	f041 0101 	orr.w	r1, r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8005852:	b292      	uxth	r2, r2
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005854:	b280      	uxth	r0, r0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005856:	b289      	uxth	r1, r1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8005858:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800585a:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800585c:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800585e:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8005860:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8005862:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8005864:	685b      	ldr	r3, [r3, #4]
 8005866:	bd38      	pop	{r3, r4, r5, pc}
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8005868:	4b0c      	ldr	r3, [pc, #48]	; (800589c <sd_lld_start+0x8c>)
 800586a:	4298      	cmp	r0, r3
 800586c:	d1d9      	bne.n	8005822 <sd_lld_start+0x12>
      rccEnableUSART2(FALSE);
 800586e:	4a0c      	ldr	r2, [pc, #48]	; (80058a0 <sd_lld_start+0x90>)
 8005870:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8005872:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005876:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 8005878:	210c      	movs	r1, #12
 800587a:	2026      	movs	r0, #38	; 0x26
 800587c:	f7fe f990 	bl	8003ba0 <nvicEnableVector>
 8005880:	e7cf      	b.n	8005822 <sd_lld_start+0x12>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8005882:	6821      	ldr	r1, [r4, #0]
 8005884:	4a07      	ldr	r2, [pc, #28]	; (80058a4 <sd_lld_start+0x94>)
 8005886:	fbb2 f2f1 	udiv	r2, r2, r1
 800588a:	609a      	str	r2, [r3, #8]
 800588c:	e7d6      	b.n	800583c <sd_lld_start+0x2c>
 800588e:	bf00      	nop
 8005890:	0800a5f0 	.word	0x0800a5f0
 8005894:	40011000 	.word	0x40011000
 8005898:	0280de80 	.word	0x0280de80
 800589c:	200012f8 	.word	0x200012f8
 80058a0:	40023800 	.word	0x40023800
 80058a4:	0501bd00 	.word	0x0501bd00
	...

080058b0 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 80058b0:	f7fe bbc6 	b.w	8004040 <stm32_clock_init>
	...

080058c0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 80058c0:	4770      	bx	lr
 80058c2:	bf00      	nop
	...

080058d0 <tmr>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 80058d0:	4b01      	ldr	r3, [pc, #4]	; (80058d8 <tmr+0x8>)
 80058d2:	2201      	movs	r2, #1
 80058d4:	701a      	strb	r2, [r3, #0]
 80058d6:	4770      	bx	lr
 80058d8:	200019dd 	.word	0x200019dd
 80058dc:	00000000 	.word	0x00000000

080058e0 <print_line>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 80058e0:	b570      	push	{r4, r5, r6, lr}
 80058e2:	4e09      	ldr	r6, [pc, #36]	; (8005908 <print_line+0x28>)
 80058e4:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 80058e6:	6830      	ldr	r0, [r6, #0]
 80058e8:	4d07      	ldr	r5, [pc, #28]	; (8005908 <print_line+0x28>)
 80058ea:	6803      	ldr	r3, [r0, #0]
 80058ec:	212d      	movs	r1, #45	; 0x2d
 80058ee:	689b      	ldr	r3, [r3, #8]
 80058f0:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 80058f2:	3c01      	subs	r4, #1
 80058f4:	d1f7      	bne.n	80058e6 <print_line+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 80058f6:	6828      	ldr	r0, [r5, #0]
 80058f8:	4904      	ldr	r1, [pc, #16]	; (800590c <print_line+0x2c>)
 80058fa:	6803      	ldr	r3, [r0, #0]
 80058fc:	2202      	movs	r2, #2
 80058fe:	681b      	ldr	r3, [r3, #0]
}
 8005900:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8005904:	4718      	bx	r3
 8005906:	bf00      	nop
 8005908:	20001a0c 	.word	0x20001a0c
 800590c:	0800b840 	.word	0x0800b840

08005910 <test_printn>:
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 8005910:	b310      	cbz	r0, 8005958 <test_printn+0x48>
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8005912:	b570      	push	{r4, r5, r6, lr}
  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8005914:	4a13      	ldr	r2, [pc, #76]	; (8005964 <test_printn+0x54>)
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8005916:	b084      	sub	sp, #16
 8005918:	466d      	mov	r5, sp
 800591a:	466c      	mov	r4, sp
  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 800591c:	fba2 1300 	umull	r1, r3, r2, r0
 8005920:	08db      	lsrs	r3, r3, #3
 8005922:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8005926:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 800592a:	f100 0130 	add.w	r1, r0, #48	; 0x30
 800592e:	b2c9      	uxtb	r1, r1
 8005930:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 8005934:	4618      	mov	r0, r3
 8005936:	2b00      	cmp	r3, #0
 8005938:	d1f0      	bne.n	800591c <test_printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800593a:	42ac      	cmp	r4, r5
 800593c:	d90a      	bls.n	8005954 <test_printn+0x44>
 800593e:	4e0a      	ldr	r6, [pc, #40]	; (8005968 <test_printn+0x58>)
 8005940:	3c01      	subs	r4, #1
 8005942:	e001      	b.n	8005948 <test_printn+0x38>
 8005944:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      chSequentialStreamPut(chp, *--p);
 8005948:	6830      	ldr	r0, [r6, #0]
 800594a:	6803      	ldr	r3, [r0, #0]
 800594c:	689b      	ldr	r3, [r3, #8]
 800594e:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8005950:	42ac      	cmp	r4, r5
 8005952:	d1f7      	bne.n	8005944 <test_printn+0x34>
      chSequentialStreamPut(chp, *--p);
  }
}
 8005954:	b004      	add	sp, #16
 8005956:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 8005958:	4b03      	ldr	r3, [pc, #12]	; (8005968 <test_printn+0x58>)
 800595a:	6818      	ldr	r0, [r3, #0]
 800595c:	6803      	ldr	r3, [r0, #0]
 800595e:	2130      	movs	r1, #48	; 0x30
 8005960:	689b      	ldr	r3, [r3, #8]
 8005962:	4718      	bx	r3
 8005964:	cccccccd 	.word	0xcccccccd
 8005968:	20001a0c 	.word	0x20001a0c
 800596c:	00000000 	.word	0x00000000

08005970 <test_print>:
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005970:	7801      	ldrb	r1, [r0, #0]
 8005972:	b159      	cbz	r1, 800598c <test_print+0x1c>
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8005974:	b538      	push	{r3, r4, r5, lr}
 8005976:	4d06      	ldr	r5, [pc, #24]	; (8005990 <test_print+0x20>)
 8005978:	4604      	mov	r4, r0

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800597a:	6828      	ldr	r0, [r5, #0]
 800597c:	6803      	ldr	r3, [r0, #0]
 800597e:	689b      	ldr	r3, [r3, #8]
 8005980:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005982:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8005986:	2900      	cmp	r1, #0
 8005988:	d1f7      	bne.n	800597a <test_print+0xa>
 800598a:	bd38      	pop	{r3, r4, r5, pc}
 800598c:	4770      	bx	lr
 800598e:	bf00      	nop
 8005990:	20001a0c 	.word	0x20001a0c
	...

080059a0 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 80059a0:	b570      	push	{r4, r5, r6, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80059a2:	7801      	ldrb	r1, [r0, #0]
 80059a4:	b189      	cbz	r1, 80059ca <test_println+0x2a>
 80059a6:	4d0a      	ldr	r5, [pc, #40]	; (80059d0 <test_println+0x30>)
 80059a8:	4604      	mov	r4, r0
    chSequentialStreamPut(chp, *msgp++);
 80059aa:	6828      	ldr	r0, [r5, #0]
 80059ac:	6803      	ldr	r3, [r0, #0]
 80059ae:	689b      	ldr	r3, [r3, #8]
 80059b0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80059b2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80059b6:	2900      	cmp	r1, #0
 80059b8:	d1f7      	bne.n	80059aa <test_println+0xa>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 80059ba:	6828      	ldr	r0, [r5, #0]
 80059bc:	4905      	ldr	r1, [pc, #20]	; (80059d4 <test_println+0x34>)
 80059be:	6803      	ldr	r3, [r0, #0]
 80059c0:	2202      	movs	r2, #2
 80059c2:	681b      	ldr	r3, [r3, #0]
}
 80059c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 80059c8:	4718      	bx	r3
 80059ca:	4d01      	ldr	r5, [pc, #4]	; (80059d0 <test_println+0x30>)
 80059cc:	e7f5      	b.n	80059ba <test_println+0x1a>
 80059ce:	bf00      	nop
 80059d0:	20001a0c 	.word	0x20001a0c
 80059d4:	0800b840 	.word	0x0800b840
	...

080059e0 <test_emit_token>:
 80059e0:	2320      	movs	r3, #32
 80059e2:	f383 8811 	msr	BASEPRI, r3
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
  *tokp++ = token;
 80059e6:	4b04      	ldr	r3, [pc, #16]	; (80059f8 <test_emit_token+0x18>)
 80059e8:	681a      	ldr	r2, [r3, #0]
 80059ea:	1c51      	adds	r1, r2, #1
 80059ec:	6019      	str	r1, [r3, #0]
 80059ee:	7010      	strb	r0, [r2, #0]
 80059f0:	2300      	movs	r3, #0
 80059f2:	f383 8811 	msr	BASEPRI, r3
 80059f6:	4770      	bx	lr
 80059f8:	200019e0 	.word	0x200019e0
 80059fc:	00000000 	.word	0x00000000

08005a00 <_test_assert>:
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8005a00:	b951      	cbnz	r1, 8005a18 <_test_assert+0x18>
  local_fail = TRUE;
  failpoint = point;
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {
 8005a02:	b410      	push	{r4}
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005a04:	4906      	ldr	r1, [pc, #24]	; (8005a20 <_test_assert+0x20>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005a06:	4c07      	ldr	r4, [pc, #28]	; (8005a24 <_test_assert+0x24>)
  local_fail = TRUE;
  failpoint = point;
 8005a08:	4a07      	ldr	r2, [pc, #28]	; (8005a28 <_test_assert+0x28>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005a0a:	2301      	movs	r3, #1
 8005a0c:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8005a0e:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005a10:	700b      	strb	r3, [r1, #0]
bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
}
 8005a12:	4618      	mov	r0, r3
 8005a14:	bc10      	pop	{r4}
 8005a16:	4770      	bx	lr

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8005a18:	2300      	movs	r3, #0
}
 8005a1a:	4618      	mov	r0, r3
 8005a1c:	4770      	bx	lr
 8005a1e:	bf00      	nop
 8005a20:	200019dc 	.word	0x200019dc
 8005a24:	20001a20 	.word	0x20001a20
 8005a28:	200019d8 	.word	0x200019d8
 8005a2c:	00000000 	.word	0x00000000

08005a30 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 8005a30:	b4f0      	push	{r4, r5, r6, r7}
 8005a32:	4e0e      	ldr	r6, [pc, #56]	; (8005a6c <_test_assert_sequence+0x3c>)
  char *cp = tokens_buffer;
 8005a34:	4f0e      	ldr	r7, [pc, #56]	; (8005a70 <_test_assert_sequence+0x40>)
 8005a36:	6835      	ldr	r5, [r6, #0]
 8005a38:	463b      	mov	r3, r7
  while (cp < tokp) {
 8005a3a:	e005      	b.n	8005a48 <_test_assert_sequence+0x18>
    if (*cp++ != *expected++)
 8005a3c:	f813 4b01 	ldrb.w	r4, [r3], #1
 8005a40:	f811 2b01 	ldrb.w	r2, [r1], #1
 8005a44:	4294      	cmp	r4, r2
 8005a46:	d107      	bne.n	8005a58 <_test_assert_sequence+0x28>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 8005a48:	42ab      	cmp	r3, r5
 8005a4a:	d3f7      	bcc.n	8005a3c <_test_assert_sequence+0xc>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8005a4c:	780b      	ldrb	r3, [r1, #0]
 8005a4e:	b91b      	cbnz	r3, 8005a58 <_test_assert_sequence+0x28>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005a50:	6037      	str	r7, [r6, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8005a52:	4618      	mov	r0, r3
 8005a54:	bcf0      	pop	{r4, r5, r6, r7}
 8005a56:	4770      	bx	lr
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005a58:	4c06      	ldr	r4, [pc, #24]	; (8005a74 <_test_assert_sequence+0x44>)
  local_fail = TRUE;
 8005a5a:	4907      	ldr	r1, [pc, #28]	; (8005a78 <_test_assert_sequence+0x48>)
  failpoint = point;
 8005a5c:	4a07      	ldr	r2, [pc, #28]	; (8005a7c <_test_assert_sequence+0x4c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005a5e:	2301      	movs	r3, #1
 8005a60:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8005a62:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005a64:	700b      	strb	r3, [r1, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8005a66:	4618      	mov	r0, r3
 8005a68:	bcf0      	pop	{r4, r5, r6, r7}
 8005a6a:	4770      	bx	lr
 8005a6c:	200019e0 	.word	0x200019e0
 8005a70:	20001a10 	.word	0x20001a10
 8005a74:	20001a20 	.word	0x20001a20
 8005a78:	200019dc 	.word	0x200019dc
 8005a7c:	200019d8 	.word	0x200019d8

08005a80 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 8005a80:	b410      	push	{r4}
 8005a82:	2320      	movs	r3, #32
 8005a84:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005a88:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8005a8c:	2300      	movs	r3, #0
 8005a8e:	6a64      	ldr	r4, [r4, #36]	; 0x24
 8005a90:	f383 8811 	msr	BASEPRI, r3
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8005a94:	1a64      	subs	r4, r4, r1
 8005a96:	1a52      	subs	r2, r2, r1
 8005a98:	4294      	cmp	r4, r2
 8005a9a:	d306      	bcc.n	8005aaa <_test_assert_time_window+0x2a>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005a9c:	4c04      	ldr	r4, [pc, #16]	; (8005ab0 <_test_assert_time_window+0x30>)
  local_fail = TRUE;
 8005a9e:	4905      	ldr	r1, [pc, #20]	; (8005ab4 <_test_assert_time_window+0x34>)
  failpoint = point;
 8005aa0:	4a05      	ldr	r2, [pc, #20]	; (8005ab8 <_test_assert_time_window+0x38>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005aa2:	2301      	movs	r3, #1
 8005aa4:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
 8005aa6:	700b      	strb	r3, [r1, #0]
  failpoint = point;
 8005aa8:	6010      	str	r0, [r2, #0]
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8005aaa:	4618      	mov	r0, r3
 8005aac:	bc10      	pop	{r4}
 8005aae:	4770      	bx	lr
 8005ab0:	20001a20 	.word	0x20001a20
 8005ab4:	200019dc 	.word	0x200019dc
 8005ab8:	200019d8 	.word	0x200019d8
 8005abc:	00000000 	.word	0x00000000

08005ac0 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8005ac0:	b538      	push	{r3, r4, r5, lr}
 8005ac2:	4c06      	ldr	r4, [pc, #24]	; (8005adc <test_terminate_threads+0x1c>)
 8005ac4:	f104 0514 	add.w	r5, r4, #20
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8005ac8:	f854 3b04 	ldr.w	r3, [r4], #4
      chThdTerminate(threads[i]);
 8005acc:	4618      	mov	r0, r3
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8005ace:	b10b      	cbz	r3, 8005ad4 <test_terminate_threads+0x14>
      chThdTerminate(threads[i]);
 8005ad0:	f7fb fef6 	bl	80018c0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8005ad4:	42ac      	cmp	r4, r5
 8005ad6:	d1f7      	bne.n	8005ac8 <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8005ad8:	bd38      	pop	{r3, r4, r5, pc}
 8005ada:	bf00      	nop
 8005adc:	200019f8 	.word	0x200019f8

08005ae0 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8005ae0:	b570      	push	{r4, r5, r6, lr}
 8005ae2:	4c07      	ldr	r4, [pc, #28]	; (8005b00 <test_wait_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8005ae4:	2600      	movs	r6, #0
 8005ae6:	f104 0514 	add.w	r5, r4, #20
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8005aea:	f854 0b04 	ldr.w	r0, [r4], #4
 8005aee:	b118      	cbz	r0, 8005af8 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8005af0:	f7fb ff56 	bl	80019a0 <chThdWait>
      threads[i] = NULL;
 8005af4:	f844 6c04 	str.w	r6, [r4, #-4]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8005af8:	42ac      	cmp	r4, r5
 8005afa:	d1f6      	bne.n	8005aea <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8005afc:	bd70      	pop	{r4, r5, r6, pc}
 8005afe:	bf00      	nop
 8005b00:	200019f8 	.word	0x200019f8
	...

08005b10 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8005b10:	b508      	push	{r3, lr}

  chThdSleep(1);
 8005b12:	2001      	movs	r0, #1
 8005b14:	f7fb fee4 	bl	80018e0 <chThdSleep>
 8005b18:	2320      	movs	r3, #32
 8005b1a:	f383 8811 	msr	BASEPRI, r3
 8005b1e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8005b22:	2300      	movs	r3, #0
 8005b24:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8005b26:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8005b2a:	bd08      	pop	{r3, pc}
 8005b2c:	0000      	movs	r0, r0
	...

08005b30 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8005b30:	b510      	push	{r4, lr}

  systime_t duration = MS2ST(ms);
 8005b32:	f242 7410 	movw	r4, #10000	; 0x2710
 8005b36:	fb04 f000 	mul.w	r0, r4, r0
 8005b3a:	490d      	ldr	r1, [pc, #52]	; (8005b70 <test_start_timer+0x40>)
  test_timer_done = FALSE;
 8005b3c:	4b0d      	ldr	r3, [pc, #52]	; (8005b74 <test_start_timer+0x44>)
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
 8005b3e:	f200 34e7 	addw	r4, r0, #999	; 0x3e7
 8005b42:	fba1 2404 	umull	r2, r4, r1, r4
  test_timer_done = FALSE;
 8005b46:	2200      	movs	r2, #0
 8005b48:	701a      	strb	r2, [r3, #0]
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
 8005b4a:	09a4      	lsrs	r4, r4, #6
 8005b4c:	2320      	movs	r3, #32
 8005b4e:	f383 8811 	msr	BASEPRI, r3
 8005b52:	4809      	ldr	r0, [pc, #36]	; (8005b78 <test_start_timer+0x48>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8005b54:	68c3      	ldr	r3, [r0, #12]
 8005b56:	b10b      	cbz	r3, 8005b5c <test_start_timer+0x2c>
    chVTDoResetI(vtp);
 8005b58:	f7fb fc92 	bl	8001480 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8005b5c:	4621      	mov	r1, r4
 8005b5e:	2300      	movs	r3, #0
 8005b60:	4a06      	ldr	r2, [pc, #24]	; (8005b7c <test_start_timer+0x4c>)
 8005b62:	4805      	ldr	r0, [pc, #20]	; (8005b78 <test_start_timer+0x48>)
 8005b64:	f7fb fc4c 	bl	8001400 <chVTDoSetI>
 8005b68:	2300      	movs	r3, #0
 8005b6a:	f383 8811 	msr	BASEPRI, r3
 8005b6e:	bd10      	pop	{r4, pc}
 8005b70:	10624dd3 	.word	0x10624dd3
 8005b74:	200019dd 	.word	0x200019dd
 8005b78:	200019e4 	.word	0x200019e4
 8005b7c:	080058d1 	.word	0x080058d1

08005b80 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 8005b80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i, j;

  chp = p;
 8005b84:	4c9f      	ldr	r4, [pc, #636]	; (8005e04 <TestThread+0x284>)
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
 8005b86:	4da0      	ldr	r5, [pc, #640]	; (8005e08 <TestThread+0x288>)
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 8005b88:	6020      	str	r0, [r4, #0]
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 8005b8a:	b085      	sub	sp, #20
  int i, j;

  chp = p;
  test_println("");
 8005b8c:	489f      	ldr	r0, [pc, #636]	; (8005e0c <TestThread+0x28c>)
 8005b8e:	f7ff ff07 	bl	80059a0 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8005b92:	489f      	ldr	r0, [pc, #636]	; (8005e10 <TestThread+0x290>)
 8005b94:	f7ff ff04 	bl	80059a0 <test_println>
  test_println("***");
 8005b98:	489e      	ldr	r0, [pc, #632]	; (8005e14 <TestThread+0x294>)
 8005b9a:	f7ff ff01 	bl	80059a0 <test_println>
 8005b9e:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005ba0:	6820      	ldr	r0, [r4, #0]
 8005ba2:	6803      	ldr	r3, [r0, #0]
 8005ba4:	689b      	ldr	r3, [r3, #8]
 8005ba6:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005ba8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005bac:	2900      	cmp	r1, #0
 8005bae:	d1f7      	bne.n	8005ba0 <TestThread+0x20>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 8005bb0:	4899      	ldr	r0, [pc, #612]	; (8005e18 <TestThread+0x298>)
 8005bb2:	4d9a      	ldr	r5, [pc, #616]	; (8005e1c <TestThread+0x29c>)
 8005bb4:	f7ff fef4 	bl	80059a0 <test_println>
 8005bb8:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005bba:	6820      	ldr	r0, [r4, #0]
 8005bbc:	6803      	ldr	r3, [r0, #0]
 8005bbe:	689b      	ldr	r3, [r3, #8]
 8005bc0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005bc2:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005bc6:	2900      	cmp	r1, #0
 8005bc8:	d1f7      	bne.n	8005bba <TestThread+0x3a>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8005bca:	4895      	ldr	r0, [pc, #596]	; (8005e20 <TestThread+0x2a0>)
 8005bcc:	4d95      	ldr	r5, [pc, #596]	; (8005e24 <TestThread+0x2a4>)
 8005bce:	f7ff fee7 	bl	80059a0 <test_println>
 8005bd2:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005bd4:	6820      	ldr	r0, [r4, #0]
 8005bd6:	6803      	ldr	r3, [r0, #0]
 8005bd8:	689b      	ldr	r3, [r3, #8]
 8005bda:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005bdc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005be0:	2900      	cmp	r1, #0
 8005be2:	d1f7      	bne.n	8005bd4 <TestThread+0x54>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 8005be4:	4890      	ldr	r0, [pc, #576]	; (8005e28 <TestThread+0x2a8>)
 8005be6:	4d91      	ldr	r5, [pc, #580]	; (8005e2c <TestThread+0x2ac>)
 8005be8:	f7ff feda 	bl	80059a0 <test_println>
 8005bec:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005bee:	6820      	ldr	r0, [r4, #0]
 8005bf0:	6803      	ldr	r3, [r0, #0]
 8005bf2:	689b      	ldr	r3, [r3, #8]
 8005bf4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005bf6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005bfa:	2900      	cmp	r1, #0
 8005bfc:	d1f7      	bne.n	8005bee <TestThread+0x6e>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 8005bfe:	488c      	ldr	r0, [pc, #560]	; (8005e30 <TestThread+0x2b0>)
 8005c00:	4d8c      	ldr	r5, [pc, #560]	; (8005e34 <TestThread+0x2b4>)
 8005c02:	f7ff fecd 	bl	80059a0 <test_println>
 8005c06:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005c08:	6820      	ldr	r0, [r4, #0]
 8005c0a:	6803      	ldr	r3, [r0, #0]
 8005c0c:	689b      	ldr	r3, [r3, #8]
 8005c0e:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005c10:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005c14:	2900      	cmp	r1, #0
 8005c16:	d1f7      	bne.n	8005c08 <TestThread+0x88>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 8005c18:	4887      	ldr	r0, [pc, #540]	; (8005e38 <TestThread+0x2b8>)
 8005c1a:	4d88      	ldr	r5, [pc, #544]	; (8005e3c <TestThread+0x2bc>)
 8005c1c:	f7ff fec0 	bl	80059a0 <test_println>
 8005c20:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005c22:	6820      	ldr	r0, [r4, #0]
 8005c24:	6803      	ldr	r3, [r0, #0]
 8005c26:	689b      	ldr	r3, [r3, #8]
 8005c28:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005c2a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005c2e:	2900      	cmp	r1, #0
 8005c30:	d1f7      	bne.n	8005c22 <TestThread+0xa2>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 8005c32:	4883      	ldr	r0, [pc, #524]	; (8005e40 <TestThread+0x2c0>)
 8005c34:	4d83      	ldr	r5, [pc, #524]	; (8005e44 <TestThread+0x2c4>)
 8005c36:	f7ff feb3 	bl	80059a0 <test_println>
 8005c3a:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005c3c:	6820      	ldr	r0, [r4, #0]
 8005c3e:	6803      	ldr	r3, [r0, #0]
 8005c40:	689b      	ldr	r3, [r3, #8]
 8005c42:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005c44:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005c48:	2900      	cmp	r1, #0
 8005c4a:	d1f7      	bne.n	8005c3c <TestThread+0xbc>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8005c4c:	487e      	ldr	r0, [pc, #504]	; (8005e48 <TestThread+0x2c8>)
 8005c4e:	4d7f      	ldr	r5, [pc, #508]	; (8005e4c <TestThread+0x2cc>)
 8005c50:	f7ff fea6 	bl	80059a0 <test_println>
 8005c54:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005c56:	6820      	ldr	r0, [r4, #0]
 8005c58:	6803      	ldr	r3, [r0, #0]
 8005c5a:	689b      	ldr	r3, [r3, #8]
 8005c5c:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005c5e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005c62:	2900      	cmp	r1, #0
 8005c64:	d1f7      	bne.n	8005c56 <TestThread+0xd6>
 8005c66:	4b7a      	ldr	r3, [pc, #488]	; (8005e50 <TestThread+0x2d0>)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8005c68:	487a      	ldr	r0, [pc, #488]	; (8005e54 <TestThread+0x2d4>)
 8005c6a:	9302      	str	r3, [sp, #8]
#endif
  test_println("");

  test_global_fail = FALSE;
 8005c6c:	4b7a      	ldr	r3, [pc, #488]	; (8005e58 <TestThread+0x2d8>)
 8005c6e:	9101      	str	r1, [sp, #4]
 8005c70:	9303      	str	r3, [sp, #12]
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8005c72:	f7ff fe95 	bl	80059a0 <test_println>
#endif
  test_println("");
 8005c76:	4865      	ldr	r0, [pc, #404]	; (8005e0c <TestThread+0x28c>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005c78:	f8df b188 	ldr.w	fp, [pc, #392]	; 8005e04 <TestThread+0x284>
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
#endif
  test_println("");

  test_global_fail = FALSE;
 8005c7c:	4f77      	ldr	r7, [pc, #476]	; (8005e5c <TestThread+0x2dc>)
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
#endif
  test_println("");
 8005c7e:	f7ff fe8f 	bl	80059a0 <test_println>

  test_global_fail = FALSE;
 8005c82:	4b77      	ldr	r3, [pc, #476]	; (8005e60 <TestThread+0x2e0>)
 8005c84:	9901      	ldr	r1, [sp, #4]
 8005c86:	7019      	strb	r1, [r3, #0]
 8005c88:	9b01      	ldr	r3, [sp, #4]
 8005c8a:	3301      	adds	r3, #1
 8005c8c:	9301      	str	r3, [sp, #4]
 8005c8e:	3f04      	subs	r7, #4
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005c90:	f04f 0800 	mov.w	r8, #0

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8005c94:	f857 3f04 	ldr.w	r3, [r7, #4]!
 8005c98:	2b00      	cmp	r3, #0
 8005c9a:	f000 8087 	beq.w	8005dac <TestThread+0x22c>
      print_line();
 8005c9e:	4d71      	ldr	r5, [pc, #452]	; (8005e64 <TestThread+0x2e4>)
 8005ca0:	f7ff fe1e 	bl	80058e0 <print_line>
 8005ca4:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005ca6:	6820      	ldr	r0, [r4, #0]
 8005ca8:	6803      	ldr	r3, [r0, #0]
 8005caa:	689b      	ldr	r3, [r3, #8]
 8005cac:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005cae:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005cb2:	2900      	cmp	r1, #0
 8005cb4:	d1f7      	bne.n	8005ca6 <TestThread+0x126>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8005cb6:	9801      	ldr	r0, [sp, #4]
      test_print(".");
      test_printn(j + 1);
 8005cb8:	4d6b      	ldr	r5, [pc, #428]	; (8005e68 <TestThread+0x2e8>)
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8005cba:	f7ff fe29 	bl	8005910 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005cbe:	f8db 0000 	ldr.w	r0, [fp]
 8005cc2:	6803      	ldr	r3, [r0, #0]
 8005cc4:	212e      	movs	r1, #46	; 0x2e
 8005cc6:	689b      	ldr	r3, [r3, #8]
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8005cc8:	f108 0801 	add.w	r8, r8, #1
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005ccc:	4798      	blx	r3
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8005cce:	4640      	mov	r0, r8
 8005cd0:	f7ff fe1e 	bl	8005910 <test_printn>
 8005cd4:	2120      	movs	r1, #32
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005cd6:	6820      	ldr	r0, [r4, #0]
 8005cd8:	6803      	ldr	r3, [r0, #0]
 8005cda:	689b      	ldr	r3, [r3, #8]
 8005cdc:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005cde:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005ce2:	2900      	cmp	r1, #0
 8005ce4:	d1f7      	bne.n	8005cd6 <TestThread+0x156>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 8005ce6:	683b      	ldr	r3, [r7, #0]
 8005ce8:	681d      	ldr	r5, [r3, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005cea:	7829      	ldrb	r1, [r5, #0]
 8005cec:	b139      	cbz	r1, 8005cfe <TestThread+0x17e>
    chSequentialStreamPut(chp, *msgp++);
 8005cee:	6820      	ldr	r0, [r4, #0]
 8005cf0:	6803      	ldr	r3, [r0, #0]
 8005cf2:	689b      	ldr	r3, [r3, #8]
 8005cf4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005cf6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005cfa:	2900      	cmp	r1, #0
 8005cfc:	d1f7      	bne.n	8005cee <TestThread+0x16e>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8005cfe:	485b      	ldr	r0, [pc, #364]	; (8005e6c <TestThread+0x2ec>)
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8005d00:	f8df 9190 	ldr.w	r9, [pc, #400]	; 8005e94 <TestThread+0x314>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005d04:	4e5a      	ldr	r6, [pc, #360]	; (8005e70 <TestThread+0x2f0>)
 8005d06:	4d5b      	ldr	r5, [pc, #364]	; (8005e74 <TestThread+0x2f4>)
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8005d08:	f7ff fe4a 	bl	80059a0 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 8005d0c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8005d10:	f7fb fde6 	bl	80018e0 <chThdSleep>

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8005d14:	4a58      	ldr	r2, [pc, #352]	; (8005e78 <TestThread+0x2f8>)
      test_print(patterns[i][j]->name);
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
 8005d16:	f8d7 a000 	ldr.w	sl, [r7]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005d1a:	6035      	str	r5, [r6, #0]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8005d1c:	2300      	movs	r3, #0
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8005d1e:	6013      	str	r3, [r2, #0]
 8005d20:	6053      	str	r3, [r2, #4]
 8005d22:	6093      	str	r3, [r2, #8]
 8005d24:	60d3      	str	r3, [r2, #12]
 8005d26:	6113      	str	r3, [r2, #16]

  if (tcp->setup != NULL)
 8005d28:	f8da 2004 	ldr.w	r2, [sl, #4]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8005d2c:	f889 3000 	strb.w	r3, [r9]
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 8005d30:	b102      	cbz	r2, 8005d34 <TestThread+0x1b4>
    tcp->setup();
 8005d32:	4790      	blx	r2
  tcp->execute();
 8005d34:	f8da 300c 	ldr.w	r3, [sl, #12]
 8005d38:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8005d3a:	f8da 3008 	ldr.w	r3, [sl, #8]
 8005d3e:	b103      	cbz	r3, 8005d42 <TestThread+0x1c2>
    tcp->teardown();
 8005d40:	4798      	blx	r3

  test_wait_threads();
 8005d42:	f7ff fecd 	bl	8005ae0 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 8005d46:	f899 3000 	ldrb.w	r3, [r9]
 8005d4a:	2b00      	cmp	r3, #0
 8005d4c:	d038      	beq.n	8005dc0 <TestThread+0x240>
 8005d4e:	f8df 9148 	ldr.w	r9, [pc, #328]	; 8005e98 <TestThread+0x318>
 8005d52:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005d54:	6820      	ldr	r0, [r4, #0]
 8005d56:	6803      	ldr	r3, [r0, #0]
 8005d58:	689b      	ldr	r3, [r3, #8]
 8005d5a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d5c:	f819 1f01 	ldrb.w	r1, [r9, #1]!
 8005d60:	2900      	cmp	r1, #0
 8005d62:	d1f7      	bne.n	8005d54 <TestThread+0x1d4>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 8005d64:	4b45      	ldr	r3, [pc, #276]	; (8005e7c <TestThread+0x2fc>)
 8005d66:	f8df 9134 	ldr.w	r9, [pc, #308]	; 8005e9c <TestThread+0x31c>
 8005d6a:	6818      	ldr	r0, [r3, #0]
 8005d6c:	f7ff fdd0 	bl	8005910 <test_printn>
 8005d70:	2120      	movs	r1, #32
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005d72:	6820      	ldr	r0, [r4, #0]
 8005d74:	6803      	ldr	r3, [r0, #0]
 8005d76:	689b      	ldr	r3, [r3, #8]
 8005d78:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d7a:	f819 1f01 	ldrb.w	r1, [r9, #1]!
 8005d7e:	2900      	cmp	r1, #0
 8005d80:	d1f7      	bne.n	8005d72 <TestThread+0x1f2>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005d82:	6833      	ldr	r3, [r6, #0]
 8005d84:	42ab      	cmp	r3, r5
 8005d86:	d909      	bls.n	8005d9c <TestThread+0x21c>
 8005d88:	4d3a      	ldr	r5, [pc, #232]	; (8005e74 <TestThread+0x2f4>)
    chSequentialStreamPut(chp, *cp++);
 8005d8a:	6820      	ldr	r0, [r4, #0]
 8005d8c:	f815 1b01 	ldrb.w	r1, [r5], #1
 8005d90:	6803      	ldr	r3, [r0, #0]
 8005d92:	689b      	ldr	r3, [r3, #8]
 8005d94:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005d96:	6833      	ldr	r3, [r6, #0]
 8005d98:	429d      	cmp	r5, r3
 8005d9a:	d3f6      	bcc.n	8005d8a <TestThread+0x20a>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8005d9c:	4838      	ldr	r0, [pc, #224]	; (8005e80 <TestThread+0x300>)
 8005d9e:	f7ff fdff 	bl	80059a0 <test_println>

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8005da2:	f857 3f04 	ldr.w	r3, [r7, #4]!
 8005da6:	2b00      	cmp	r3, #0
 8005da8:	f47f af79 	bne.w	8005c9e <TestThread+0x11e>
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8005dac:	9b03      	ldr	r3, [sp, #12]
 8005dae:	b15b      	cbz	r3, 8005dc8 <TestThread+0x248>
 8005db0:	461f      	mov	r7, r3
 8005db2:	9b02      	ldr	r3, [sp, #8]
 8005db4:	461a      	mov	r2, r3
 8005db6:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8005dba:	9303      	str	r3, [sp, #12]
 8005dbc:	9202      	str	r2, [sp, #8]
 8005dbe:	e763      	b.n	8005c88 <TestThread+0x108>
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 8005dc0:	4830      	ldr	r0, [pc, #192]	; (8005e84 <TestThread+0x304>)
 8005dc2:	f7ff fded 	bl	80059a0 <test_println>
 8005dc6:	e765      	b.n	8005c94 <TestThread+0x114>
      j++;
    }
    i++;
  }
  print_line();
 8005dc8:	f7ff fd8a 	bl	80058e0 <print_line>
  test_println("");
 8005dcc:	4d2e      	ldr	r5, [pc, #184]	; (8005e88 <TestThread+0x308>)
 8005dce:	480f      	ldr	r0, [pc, #60]	; (8005e0c <TestThread+0x28c>)
 8005dd0:	f7ff fde6 	bl	80059a0 <test_println>
 8005dd4:	2146      	movs	r1, #70	; 0x46
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005dd6:	6820      	ldr	r0, [r4, #0]
 8005dd8:	6803      	ldr	r3, [r0, #0]
 8005dda:	689b      	ldr	r3, [r3, #8]
 8005ddc:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005dde:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005de2:	2900      	cmp	r1, #0
 8005de4:	d1f7      	bne.n	8005dd6 <TestThread+0x256>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 8005de6:	4b1e      	ldr	r3, [pc, #120]	; (8005e60 <TestThread+0x2e0>)
 8005de8:	781b      	ldrb	r3, [r3, #0]
 8005dea:	b92b      	cbnz	r3, 8005df8 <TestThread+0x278>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8005dec:	4827      	ldr	r0, [pc, #156]	; (8005e8c <TestThread+0x30c>)
}
 8005dee:	b005      	add	sp, #20
 8005df0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8005df4:	f7ff bdd4 	b.w	80059a0 <test_println>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8005df8:	4825      	ldr	r0, [pc, #148]	; (8005e90 <TestThread+0x310>)
  else
    test_println("SUCCESS");
}
 8005dfa:	b005      	add	sp, #20
 8005dfc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8005e00:	f7ff bdce 	b.w	80059a0 <test_println>
 8005e04:	20001a0c 	.word	0x20001a0c
 8005e08:	0800a760 	.word	0x0800a760
 8005e0c:	0800b4fc 	.word	0x0800b4fc
 8005e10:	0800a840 	.word	0x0800a840
 8005e14:	0800a85c 	.word	0x0800a85c
 8005e18:	0800a884 	.word	0x0800a884
 8005e1c:	0800a774 	.word	0x0800a774
 8005e20:	0800a88c 	.word	0x0800a88c
 8005e24:	0800a788 	.word	0x0800a788
 8005e28:	0800a8a4 	.word	0x0800a8a4
 8005e2c:	0800a79c 	.word	0x0800a79c
 8005e30:	0800a8ec 	.word	0x0800a8ec
 8005e34:	0800a7b0 	.word	0x0800a7b0
 8005e38:	0800a8f8 	.word	0x0800a8f8
 8005e3c:	0800a7c4 	.word	0x0800a7c4
 8005e40:	0800a904 	.word	0x0800a904
 8005e44:	0800a7d8 	.word	0x0800a7d8
 8005e48:	0800a91c 	.word	0x0800a91c
 8005e4c:	0800a7ec 	.word	0x0800a7ec
 8005e50:	0800a724 	.word	0x0800a724
 8005e54:	0800a948 	.word	0x0800a948
 8005e58:	0800a9b0 	.word	0x0800a9b0
 8005e5c:	0800afa0 	.word	0x0800afa0
 8005e60:	20001a20 	.word	0x20001a20
 8005e64:	0800a800 	.word	0x0800a800
 8005e68:	0800a810 	.word	0x0800a810
 8005e6c:	0800a860 	.word	0x0800a860
 8005e70:	200019e0 	.word	0x200019e0
 8005e74:	20001a10 	.word	0x20001a10
 8005e78:	200019f8 	.word	0x200019f8
 8005e7c:	200019d8 	.word	0x200019d8
 8005e80:	0800a864 	.word	0x0800a864
 8005e84:	0800a868 	.word	0x0800a868
 8005e88:	0800a830 	.word	0x0800a830
 8005e8c:	0800a874 	.word	0x0800a874
 8005e90:	0800a87c 	.word	0x0800a87c
 8005e94:	200019dc 	.word	0x200019dc
 8005e98:	0800a814 	.word	0x0800a814
 8005e9c:	0800a82c 	.word	0x0800a82c

08005ea0 <thd1_execute>:
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 8005ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005ea2:	4f27      	ldr	r7, [pc, #156]	; (8005f40 <thd1_execute+0xa0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005ea4:	4e27      	ldr	r6, [pc, #156]	; (8005f44 <thd1_execute+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005ea6:	69bb      	ldr	r3, [r7, #24]
 8005ea8:	4d27      	ldr	r5, [pc, #156]	; (8005f48 <thd1_execute+0xa8>)
 8005eaa:	689a      	ldr	r2, [r3, #8]
 8005eac:	4b27      	ldr	r3, [pc, #156]	; (8005f4c <thd1_execute+0xac>)
 8005eae:	6830      	ldr	r0, [r6, #0]
 8005eb0:	4c27      	ldr	r4, [pc, #156]	; (8005f50 <thd1_execute+0xb0>)
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 8005eb2:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005eb4:	3a05      	subs	r2, #5
 8005eb6:	9300      	str	r3, [sp, #0]
 8005eb8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005ebc:	462b      	mov	r3, r5
 8005ebe:	f7fb fc9f 	bl	8001800 <chThdCreateStatic>
 8005ec2:	69bb      	ldr	r3, [r7, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005ec4:	4923      	ldr	r1, [pc, #140]	; (8005f54 <thd1_execute+0xb4>)
 8005ec6:	689a      	ldr	r2, [r3, #8]
 8005ec8:	6873      	ldr	r3, [r6, #4]
  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005eca:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005ecc:	9100      	str	r1, [sp, #0]
 8005ece:	3a04      	subs	r2, #4
 8005ed0:	4618      	mov	r0, r3
 8005ed2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005ed6:	462b      	mov	r3, r5
 8005ed8:	f7fb fc92 	bl	8001800 <chThdCreateStatic>
 8005edc:	69ba      	ldr	r2, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005ede:	68b3      	ldr	r3, [r6, #8]
 8005ee0:	6892      	ldr	r2, [r2, #8]
 8005ee2:	491d      	ldr	r1, [pc, #116]	; (8005f58 <thd1_execute+0xb8>)
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005ee4:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005ee6:	9100      	str	r1, [sp, #0]
 8005ee8:	3a03      	subs	r2, #3
 8005eea:	4618      	mov	r0, r3
 8005eec:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005ef0:	462b      	mov	r3, r5
 8005ef2:	f7fb fc85 	bl	8001800 <chThdCreateStatic>
 8005ef6:	69ba      	ldr	r2, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005ef8:	68f3      	ldr	r3, [r6, #12]
 8005efa:	6892      	ldr	r2, [r2, #8]
 8005efc:	4917      	ldr	r1, [pc, #92]	; (8005f5c <thd1_execute+0xbc>)

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005efe:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005f00:	9100      	str	r1, [sp, #0]
 8005f02:	3a02      	subs	r2, #2
 8005f04:	4618      	mov	r0, r3
 8005f06:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005f0a:	462b      	mov	r3, r5
 8005f0c:	f7fb fc78 	bl	8001800 <chThdCreateStatic>
 8005f10:	69ba      	ldr	r2, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005f12:	6933      	ldr	r3, [r6, #16]
 8005f14:	6892      	ldr	r2, [r2, #8]
 8005f16:	4912      	ldr	r1, [pc, #72]	; (8005f60 <thd1_execute+0xc0>)
static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005f18:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005f1a:	3a01      	subs	r2, #1
 8005f1c:	9100      	str	r1, [sp, #0]
 8005f1e:	4618      	mov	r0, r3
 8005f20:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005f24:	462b      	mov	r3, r5
 8005f26:	f7fb fc6b 	bl	8001800 <chThdCreateStatic>
 8005f2a:	6120      	str	r0, [r4, #16]
  test_wait_threads();
 8005f2c:	f7ff fdd8 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8005f30:	490c      	ldr	r1, [pc, #48]	; (8005f64 <thd1_execute+0xc4>)
 8005f32:	2001      	movs	r0, #1
}
 8005f34:	b003      	add	sp, #12
 8005f36:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8005f3a:	f7ff bd79 	b.w	8005a30 <_test_assert_sequence>
 8005f3e:	bf00      	nop
 8005f40:	20000e78 	.word	0x20000e78
 8005f44:	0800a700 	.word	0x0800a700
 8005f48:	08005f71 	.word	0x08005f71
 8005f4c:	0800a9e0 	.word	0x0800a9e0
 8005f50:	200019f8 	.word	0x200019f8
 8005f54:	0800b864 	.word	0x0800b864
 8005f58:	0800a9d0 	.word	0x0800a9d0
 8005f5c:	0800a9d4 	.word	0x0800a9d4
 8005f60:	0800a9d8 	.word	0x0800a9d8
 8005f64:	0800a9dc 	.word	0x0800a9dc
	...

08005f70 <thread>:
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8005f70:	7800      	ldrb	r0, [r0, #0]
 8005f72:	f7ff bd35 	b.w	80059e0 <test_emit_token>
 8005f76:	bf00      	nop
	...

08005f80 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8005f80:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005f82:	4f2b      	ldr	r7, [pc, #172]	; (8006030 <thd2_execute+0xb0>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005f84:	4e2b      	ldr	r6, [pc, #172]	; (8006034 <thd2_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005f86:	69bb      	ldr	r3, [r7, #24]
 8005f88:	4d2b      	ldr	r5, [pc, #172]	; (8006038 <thd2_execute+0xb8>)
 8005f8a:	689a      	ldr	r2, [r3, #8]
 8005f8c:	4b2b      	ldr	r3, [pc, #172]	; (800603c <thd2_execute+0xbc>)
 8005f8e:	6870      	ldr	r0, [r6, #4]
 8005f90:	4c2b      	ldr	r4, [pc, #172]	; (8006040 <thd2_execute+0xc0>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8005f92:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005f94:	3a04      	subs	r2, #4
 8005f96:	9300      	str	r3, [sp, #0]
 8005f98:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005f9c:	462b      	mov	r3, r5
 8005f9e:	f7fb fc2f 	bl	8001800 <chThdCreateStatic>
 8005fa2:	69bb      	ldr	r3, [r7, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005fa4:	4927      	ldr	r1, [pc, #156]	; (8006044 <thd2_execute+0xc4>)
 8005fa6:	689a      	ldr	r2, [r3, #8]
 8005fa8:	6833      	ldr	r3, [r6, #0]
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005faa:	6060      	str	r0, [r4, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005fac:	9100      	str	r1, [sp, #0]
 8005fae:	3a05      	subs	r2, #5
 8005fb0:	4618      	mov	r0, r3
 8005fb2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005fb6:	462b      	mov	r3, r5
 8005fb8:	f7fb fc22 	bl	8001800 <chThdCreateStatic>
 8005fbc:	69ba      	ldr	r2, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005fbe:	6933      	ldr	r3, [r6, #16]
 8005fc0:	6892      	ldr	r2, [r2, #8]
 8005fc2:	4921      	ldr	r1, [pc, #132]	; (8006048 <thd2_execute+0xc8>)
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005fc4:	6020      	str	r0, [r4, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005fc6:	9100      	str	r1, [sp, #0]
 8005fc8:	3a01      	subs	r2, #1
 8005fca:	4618      	mov	r0, r3
 8005fcc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005fd0:	462b      	mov	r3, r5
 8005fd2:	f7fb fc15 	bl	8001800 <chThdCreateStatic>
 8005fd6:	69ba      	ldr	r2, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005fd8:	68f3      	ldr	r3, [r6, #12]
 8005fda:	6892      	ldr	r2, [r2, #8]
 8005fdc:	491b      	ldr	r1, [pc, #108]	; (800604c <thd2_execute+0xcc>)

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005fde:	6120      	str	r0, [r4, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005fe0:	9100      	str	r1, [sp, #0]
 8005fe2:	3a02      	subs	r2, #2
 8005fe4:	4618      	mov	r0, r3
 8005fe6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005fea:	462b      	mov	r3, r5
 8005fec:	f7fb fc08 	bl	8001800 <chThdCreateStatic>
 8005ff0:	2320      	movs	r3, #32
 8005ff2:	60e0      	str	r0, [r4, #12]
 8005ff4:	f383 8811 	msr	BASEPRI, r3
 8005ff8:	69bb      	ldr	r3, [r7, #24]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005ffa:	68b0      	ldr	r0, [r6, #8]
 8005ffc:	689a      	ldr	r2, [r3, #8]
 8005ffe:	4b14      	ldr	r3, [pc, #80]	; (8006050 <thd2_execute+0xd0>)
 8006000:	9300      	str	r3, [sp, #0]
 8006002:	3a03      	subs	r2, #3
 8006004:	462b      	mov	r3, r5
 8006006:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800600a:	f7fb fbc9 	bl	80017a0 <chThdCreateI>
 800600e:	2300      	movs	r3, #0
 8006010:	60a0      	str	r0, [r4, #8]
 8006012:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  chThdStart(threads[2]);
 8006016:	68a0      	ldr	r0, [r4, #8]
 8006018:	f7fb fc2a 	bl	8001870 <chThdStart>
  test_wait_threads();
 800601c:	f7ff fd60 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006020:	490c      	ldr	r1, [pc, #48]	; (8006054 <thd2_execute+0xd4>)
 8006022:	2001      	movs	r0, #1
}
 8006024:	b003      	add	sp, #12
 8006026:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  chSysUnlock();
  chThdStart(threads[2]);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800602a:	f7ff bd01 	b.w	8005a30 <_test_assert_sequence>
 800602e:	bf00      	nop
 8006030:	20000e78 	.word	0x20000e78
 8006034:	0800a700 	.word	0x0800a700
 8006038:	08005f71 	.word	0x08005f71
 800603c:	0800b864 	.word	0x0800b864
 8006040:	200019f8 	.word	0x200019f8
 8006044:	0800a9e0 	.word	0x0800a9e0
 8006048:	0800a9d8 	.word	0x0800a9d8
 800604c:	0800a9d4 	.word	0x0800a9d4
 8006050:	0800a9d0 	.word	0x0800a9d0
 8006054:	0800a9dc 	.word	0x0800a9dc
	...

08006060 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 8006060:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006062:	4e49      	ldr	r6, [pc, #292]	; (8006188 <thd3_execute+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006064:	69b3      	ldr	r3, [r6, #24]
 8006066:	689c      	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 8006068:	1c65      	adds	r5, r4, #1
 800606a:	4628      	mov	r0, r5
 800606c:	f7fb fc10 	bl	8001890 <chThdSetPriority>
  test_assert(1, p1 == prio,
 8006070:	1b01      	subs	r1, r0, r4
 8006072:	fab1 f181 	clz	r1, r1

static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 8006076:	4607      	mov	r7, r0
  test_assert(1, p1 == prio,
 8006078:	0949      	lsrs	r1, r1, #5
 800607a:	2001      	movs	r0, #1
 800607c:	f7ff fcc0 	bl	8005a00 <_test_assert>
 8006080:	b100      	cbz	r0, 8006084 <thd3_execute+0x24>
 8006082:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006084:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 8006086:	6899      	ldr	r1, [r3, #8]
 8006088:	1b49      	subs	r1, r1, r5
 800608a:	fab1 f181 	clz	r1, r1
 800608e:	2002      	movs	r0, #2
 8006090:	0949      	lsrs	r1, r1, #5
 8006092:	f7ff fcb5 	bl	8005a00 <_test_assert>
 8006096:	2800      	cmp	r0, #0
 8006098:	d1f3      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800609a:	4638      	mov	r0, r7
 800609c:	f7fb fbf8 	bl	8001890 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 80060a0:	1a29      	subs	r1, r5, r0
 80060a2:	fab1 f181 	clz	r1, r1
 80060a6:	0949      	lsrs	r1, r1, #5
 80060a8:	2003      	movs	r0, #3
 80060aa:	f7ff fca9 	bl	8005a00 <_test_assert>
 80060ae:	2800      	cmp	r0, #0
 80060b0:	d1e7      	bne.n	8006082 <thd3_execute+0x22>
 80060b2:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 80060b4:	6899      	ldr	r1, [r3, #8]
 80060b6:	1b09      	subs	r1, r1, r4
 80060b8:	fab1 f181 	clz	r1, r1
 80060bc:	2004      	movs	r0, #4
 80060be:	0949      	lsrs	r1, r1, #5
 80060c0:	f7ff fc9e 	bl	8005a00 <_test_assert>
 80060c4:	2800      	cmp	r0, #0
 80060c6:	d1dc      	bne.n	8006082 <thd3_execute+0x22>
 80060c8:	2320      	movs	r3, #32
 80060ca:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80060ce:	69b2      	ldr	r2, [r6, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 80060d0:	6893      	ldr	r3, [r2, #8]
 80060d2:	3302      	adds	r3, #2
 80060d4:	6093      	str	r3, [r2, #8]
 80060d6:	f380 8811 	msr	BASEPRI, r0
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80060da:	69b3      	ldr	r3, [r6, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 80060dc:	6899      	ldr	r1, [r3, #8]
 80060de:	1ca7      	adds	r7, r4, #2
 80060e0:	1bc9      	subs	r1, r1, r7
 80060e2:	fab1 f181 	clz	r1, r1
 80060e6:	0949      	lsrs	r1, r1, #5
 80060e8:	2005      	movs	r0, #5
 80060ea:	f7ff fc89 	bl	8005a00 <_test_assert>
 80060ee:	2800      	cmp	r0, #0
 80060f0:	d1c7      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 80060f2:	4628      	mov	r0, r5
 80060f4:	f7fb fbcc 	bl	8001890 <chThdSetPriority>
  test_assert(6, p1 == prio,
 80060f8:	1b01      	subs	r1, r0, r4
 80060fa:	fab1 f181 	clz	r1, r1
 80060fe:	0949      	lsrs	r1, r1, #5
 8006100:	2006      	movs	r0, #6
 8006102:	f7ff fc7d 	bl	8005a00 <_test_assert>
 8006106:	2800      	cmp	r0, #0
 8006108:	d1bb      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 800610a:	69b3      	ldr	r3, [r6, #24]
 800610c:	6899      	ldr	r1, [r3, #8]
 800610e:	1bc9      	subs	r1, r1, r7
 8006110:	fab1 f181 	clz	r1, r1
 8006114:	2007      	movs	r0, #7
 8006116:	0949      	lsrs	r1, r1, #5
 8006118:	f7ff fc72 	bl	8005a00 <_test_assert>
 800611c:	2800      	cmp	r0, #0
 800611e:	d1b0      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 8006120:	69b3      	ldr	r3, [r6, #24]
 8006122:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8006124:	1b49      	subs	r1, r1, r5
 8006126:	fab1 f181 	clz	r1, r1
 800612a:	2008      	movs	r0, #8
 800612c:	0949      	lsrs	r1, r1, #5
 800612e:	f7ff fc67 	bl	8005a00 <_test_assert>
 8006132:	2800      	cmp	r0, #0
 8006134:	d1a5      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 8006136:	1ce7      	adds	r7, r4, #3
 8006138:	4638      	mov	r0, r7
 800613a:	f7fb fba9 	bl	8001890 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 800613e:	1a28      	subs	r0, r5, r0
 8006140:	4241      	negs	r1, r0
 8006142:	4141      	adcs	r1, r0
 8006144:	2009      	movs	r0, #9
 8006146:	f7ff fc5b 	bl	8005a00 <_test_assert>
 800614a:	2800      	cmp	r0, #0
 800614c:	d199      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 800614e:	69b3      	ldr	r3, [r6, #24]
 8006150:	6899      	ldr	r1, [r3, #8]
 8006152:	1bca      	subs	r2, r1, r7
 8006154:	4251      	negs	r1, r2
 8006156:	4151      	adcs	r1, r2
 8006158:	200a      	movs	r0, #10
 800615a:	f7ff fc51 	bl	8005a00 <_test_assert>
 800615e:	2800      	cmp	r0, #0
 8006160:	d18f      	bne.n	8006082 <thd3_execute+0x22>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 8006162:	69b3      	ldr	r3, [r6, #24]
 8006164:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8006166:	1bcb      	subs	r3, r1, r7
 8006168:	4259      	negs	r1, r3
 800616a:	4159      	adcs	r1, r3
 800616c:	200b      	movs	r0, #11
 800616e:	f7ff fc47 	bl	8005a00 <_test_assert>
 8006172:	2800      	cmp	r0, #0
 8006174:	d185      	bne.n	8006082 <thd3_execute+0x22>
 8006176:	2320      	movs	r3, #32
 8006178:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800617c:	69b3      	ldr	r3, [r6, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 800617e:	609c      	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 8006180:	63dc      	str	r4, [r3, #60]	; 0x3c
 8006182:	f380 8811 	msr	BASEPRI, r0
 8006186:	e77c      	b.n	8006082 <thd3_execute+0x22>
 8006188:	20000e78 	.word	0x20000e78
 800618c:	00000000 	.word	0x00000000

08006190 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8006190:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
 8006192:	f7ff fcbd 	bl	8005b10 <test_wait_tick>
 8006196:	2620      	movs	r6, #32
 8006198:	f386 8811 	msr	BASEPRI, r6
 800619c:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 80061a0:	2300      	movs	r3, #0
 80061a2:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80061a4:	f383 8811 	msr	BASEPRI, r3

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 80061a8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80061ac:	f7fb fb98 	bl	80018e0 <chThdSleep>
  test_assert_time_window(1,
 80061b0:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 80061b4:	f504 717a 	add.w	r1, r4, #1000	; 0x3e8
 80061b8:	2001      	movs	r0, #1
 80061ba:	f7ff fc61 	bl	8005a80 <_test_assert_time_window>
 80061be:	b100      	cbz	r0, 80061c2 <thd4_execute+0x32>
 80061c0:	bd70      	pop	{r4, r5, r6, pc}
 80061c2:	f386 8811 	msr	BASEPRI, r6
 80061c6:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80061c8:	f380 8811 	msr	BASEPRI, r0
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 80061cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80061d0:	f7fb fb86 	bl	80018e0 <chThdSleep>
  test_assert_time_window(2,
 80061d4:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 80061d8:	f504 717a 	add.w	r1, r4, #1000	; 0x3e8
 80061dc:	2002      	movs	r0, #2
 80061de:	f7ff fc4f 	bl	8005a80 <_test_assert_time_window>
 80061e2:	2800      	cmp	r0, #0
 80061e4:	d1ec      	bne.n	80061c0 <thd4_execute+0x30>
 80061e6:	f386 8811 	msr	BASEPRI, r6
 80061ea:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80061ec:	f380 8811 	msr	BASEPRI, r0
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 80061f0:	f242 7010 	movw	r0, #10000	; 0x2710
 80061f4:	f7fb fb74 	bl	80018e0 <chThdSleep>
  test_assert_time_window(3,
 80061f8:	f504 521c 	add.w	r2, r4, #9984	; 0x2700
 80061fc:	4611      	mov	r1, r2
 80061fe:	3110      	adds	r1, #16
 8006200:	3213      	adds	r2, #19
 8006202:	2003      	movs	r0, #3
 8006204:	f7ff fc3c 	bl	8005a80 <_test_assert_time_window>
 8006208:	2800      	cmp	r0, #0
 800620a:	d1d9      	bne.n	80061c0 <thd4_execute+0x30>
 800620c:	f386 8811 	msr	BASEPRI, r6
 8006210:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8006212:	f380 8811 	msr	BASEPRI, r0
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 8006216:	f504 757a 	add.w	r5, r4, #1000	; 0x3e8
  chThdSleepUntil(time);
 800621a:	4628      	mov	r0, r5
 800621c:	f7fb fb70 	bl	8001900 <chThdSleepUntil>
  test_assert_time_window(4,
 8006220:	4629      	mov	r1, r5
 8006222:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 8006226:	2004      	movs	r0, #4
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 8006228:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
 800622c:	f7ff bc28 	b.w	8005a80 <_test_assert_time_window>

08006230 <sem1_execute>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8006230:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006234:	4e48      	ldr	r6, [pc, #288]	; (8006358 <sem1_execute+0x128>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006236:	4f49      	ldr	r7, [pc, #292]	; (800635c <sem1_execute+0x12c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006238:	69b3      	ldr	r3, [r6, #24]
 800623a:	f8d7 8000 	ldr.w	r8, [r7]
 800623e:	689a      	ldr	r2, [r3, #8]
 8006240:	f8df 913c 	ldr.w	r9, [pc, #316]	; 8006380 <sem1_execute+0x150>
 8006244:	4b46      	ldr	r3, [pc, #280]	; (8006360 <sem1_execute+0x130>)
 8006246:	4d47      	ldr	r5, [pc, #284]	; (8006364 <sem1_execute+0x134>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  chSemSignal(&sem1);
 8006248:	4c47      	ldr	r4, [pc, #284]	; (8006368 <sem1_execute+0x138>)

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 800624a:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800624c:	3205      	adds	r2, #5
 800624e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006252:	f8cd 9000 	str.w	r9, [sp]
 8006256:	4640      	mov	r0, r8
 8006258:	f7fb fad2 	bl	8001800 <chThdCreateStatic>
 800625c:	69b3      	ldr	r3, [r6, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800625e:	6879      	ldr	r1, [r7, #4]
 8006260:	689a      	ldr	r2, [r3, #8]
 8006262:	4b42      	ldr	r3, [pc, #264]	; (800636c <sem1_execute+0x13c>)
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006264:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8006266:	3201      	adds	r2, #1
 8006268:	4608      	mov	r0, r1
 800626a:	9300      	str	r3, [sp, #0]
 800626c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006270:	4b3b      	ldr	r3, [pc, #236]	; (8006360 <sem1_execute+0x130>)
 8006272:	f7fb fac5 	bl	8001800 <chThdCreateStatic>
 8006276:	69b3      	ldr	r3, [r6, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006278:	68b9      	ldr	r1, [r7, #8]
 800627a:	689a      	ldr	r2, [r3, #8]
 800627c:	4b3c      	ldr	r3, [pc, #240]	; (8006370 <sem1_execute+0x140>)
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800627e:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006280:	3203      	adds	r2, #3
 8006282:	4608      	mov	r0, r1
 8006284:	9300      	str	r3, [sp, #0]
 8006286:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800628a:	4b35      	ldr	r3, [pc, #212]	; (8006360 <sem1_execute+0x130>)
 800628c:	f7fb fab8 	bl	8001800 <chThdCreateStatic>
 8006290:	69b3      	ldr	r3, [r6, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8006292:	68f9      	ldr	r1, [r7, #12]
 8006294:	689a      	ldr	r2, [r3, #8]
 8006296:	4b37      	ldr	r3, [pc, #220]	; (8006374 <sem1_execute+0x144>)

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006298:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800629a:	3204      	adds	r2, #4
 800629c:	4608      	mov	r0, r1
 800629e:	9300      	str	r3, [sp, #0]
 80062a0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80062a4:	4b2e      	ldr	r3, [pc, #184]	; (8006360 <sem1_execute+0x130>)
 80062a6:	f7fb faab 	bl	8001800 <chThdCreateStatic>
 80062aa:	69b3      	ldr	r3, [r6, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80062ac:	6939      	ldr	r1, [r7, #16]
 80062ae:	689a      	ldr	r2, [r3, #8]
 80062b0:	4b31      	ldr	r3, [pc, #196]	; (8006378 <sem1_execute+0x148>)
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80062b2:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80062b4:	3202      	adds	r2, #2
 80062b6:	4608      	mov	r0, r1
 80062b8:	9300      	str	r3, [sp, #0]
 80062ba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80062be:	4b28      	ldr	r3, [pc, #160]	; (8006360 <sem1_execute+0x130>)
 80062c0:	f7fb fa9e 	bl	8001800 <chThdCreateStatic>
 80062c4:	6128      	str	r0, [r5, #16]
  chSemSignal(&sem1);
 80062c6:	4620      	mov	r0, r4
 80062c8:	f7fb fd82 	bl	8001dd0 <chSemSignal>
  chSemSignal(&sem1);
 80062cc:	4620      	mov	r0, r4
 80062ce:	f7fb fd7f 	bl	8001dd0 <chSemSignal>
  chSemSignal(&sem1);
 80062d2:	4620      	mov	r0, r4
 80062d4:	f7fb fd7c 	bl	8001dd0 <chSemSignal>
  chSemSignal(&sem1);
 80062d8:	4620      	mov	r0, r4
 80062da:	f7fb fd79 	bl	8001dd0 <chSemSignal>
  chSemSignal(&sem1);
 80062de:	4620      	mov	r0, r4
 80062e0:	f7fb fd76 	bl	8001dd0 <chSemSignal>
  test_wait_threads();
 80062e4:	f7ff fbfc 	bl	8005ae0 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 80062e8:	4924      	ldr	r1, [pc, #144]	; (800637c <sem1_execute+0x14c>)
 80062ea:	2001      	movs	r0, #1
 80062ec:	f7ff fba0 	bl	8005a30 <_test_assert_sequence>
 80062f0:	b110      	cbz	r0, 80062f8 <sem1_execute+0xc8>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 80062f2:	b003      	add	sp, #12
 80062f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80062f8:	69b2      	ldr	r2, [r6, #24]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80062fa:	4b19      	ldr	r3, [pc, #100]	; (8006360 <sem1_execute+0x130>)
 80062fc:	6892      	ldr	r2, [r2, #8]
 80062fe:	f8cd 9000 	str.w	r9, [sp]
 8006302:	4607      	mov	r7, r0
 8006304:	3205      	adds	r2, #5
 8006306:	4640      	mov	r0, r8
 8006308:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800630c:	f7fb fa78 	bl	8001800 <chThdCreateStatic>
 8006310:	2620      	movs	r6, #32
 8006312:	6028      	str	r0, [r5, #0]
 8006314:	f386 8811 	msr	BASEPRI, r6
  chSysLock();
  chSemAddCounterI(&sem1, 2);
 8006318:	2102      	movs	r1, #2
 800631a:	4620      	mov	r0, r4
 800631c:	f7fb fd88 	bl	8001e30 <chSemAddCounterI>
  chSchRescheduleS();
 8006320:	f7fb fa06 	bl	8001730 <chSchRescheduleS>
 8006324:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();
  test_wait_threads();
 8006328:	f7ff fbda 	bl	8005ae0 <test_wait_threads>
 800632c:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8006330:	68a1      	ldr	r1, [r4, #8]
 8006332:	f1a1 0101 	sub.w	r1, r1, #1
 8006336:	fab1 f181 	clz	r1, r1
 800633a:	2002      	movs	r0, #2
 800633c:	0949      	lsrs	r1, r1, #5
 800633e:	f7ff fb5f 	bl	8005a00 <_test_assert>
 8006342:	b920      	cbnz	r0, 800634e <sem1_execute+0x11e>
 8006344:	f380 8811 	msr	BASEPRI, r0
}
 8006348:	b003      	add	sp, #12
 800634a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800634e:	f387 8811 	msr	BASEPRI, r7
 8006352:	b003      	add	sp, #12
 8006354:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006358:	20000e78 	.word	0x20000e78
 800635c:	0800a700 	.word	0x0800a700
 8006360:	080063b1 	.word	0x080063b1
 8006364:	200019f8 	.word	0x200019f8
 8006368:	20000808 	.word	0x20000808
 800636c:	0800a9d4 	.word	0x0800a9d4
 8006370:	0800a9d0 	.word	0x0800a9d0
 8006374:	0800b864 	.word	0x0800b864
 8006378:	0800a9e0 	.word	0x0800a9e0
 800637c:	0800a9dc 	.word	0x0800a9dc
 8006380:	0800a9d8 	.word	0x0800a9d8
	...

08006390 <thread3>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread3, p) {
 8006390:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8006392:	4c04      	ldr	r4, [pc, #16]	; (80063a4 <thread3+0x14>)
 8006394:	4620      	mov	r0, r4
 8006396:	f7fb fcab 	bl	8001cf0 <chSemWait>
  chSemSignal(&sem1);
 800639a:	4620      	mov	r0, r4
}
 800639c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
 80063a0:	f7fb bd16 	b.w	8001dd0 <chSemSignal>
 80063a4:	20000808 	.word	0x20000808
	...

080063b0 <thread1>:
static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread1, p) {
 80063b0:	b510      	push	{r4, lr}
 80063b2:	4604      	mov	r4, r0

  chSemWait(&sem1);
 80063b4:	4803      	ldr	r0, [pc, #12]	; (80063c4 <thread1+0x14>)
 80063b6:	f7fb fc9b 	bl	8001cf0 <chSemWait>
  test_emit_token(*(char *)p);
 80063ba:	7820      	ldrb	r0, [r4, #0]
}
 80063bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
 80063c0:	f7ff bb0e 	b.w	80059e0 <test_emit_token>
 80063c4:	20000808 	.word	0x20000808
	...

080063d0 <sem3_setup>:
 * correct after each operation.
 */

static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
 80063d0:	2100      	movs	r1, #0
 80063d2:	4801      	ldr	r0, [pc, #4]	; (80063d8 <sem3_setup+0x8>)
 80063d4:	f7fb bc5c 	b.w	8001c90 <chSemObjectInit>
 80063d8:	20000808 	.word	0x20000808
 80063dc:	00000000 	.word	0x00000000

080063e0 <sem2_setup>:
 80063e0:	f7ff bff6 	b.w	80063d0 <sem3_setup>
	...

080063f0 <sem1_setup>:
 80063f0:	f7ff bfee 	b.w	80063d0 <sem3_setup>
	...

08006400 <thread2>:
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread2, p) {
 8006400:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8006402:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8006406:	f7fb fa6b 	bl	80018e0 <chThdSleep>
 800640a:	2320      	movs	r3, #32
 800640c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8006410:	4804      	ldr	r0, [pc, #16]	; (8006424 <thread2+0x24>)
 8006412:	f7fb fcfd 	bl	8001e10 <chSemSignalI>
  chSchRescheduleS();
 8006416:	f7fb f98b 	bl	8001730 <chSchRescheduleS>
 800641a:	2300      	movs	r3, #0
 800641c:	f383 8811 	msr	BASEPRI, r3
 8006420:	bd08      	pop	{r3, pc}
 8006422:	bf00      	nop
 8006424:	20000808 	.word	0x20000808
	...

08006430 <sem2_execute>:
  chSysUnlock();
}

static void sem2_execute(void) {
 8006430:	b570      	push	{r4, r5, r6, lr}
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8006432:	4c4e      	ldr	r4, [pc, #312]	; (800656c <sem2_execute+0x13c>)
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static void sem2_execute(void) {
 8006434:	b082      	sub	sp, #8
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8006436:	2100      	movs	r1, #0
 8006438:	4620      	mov	r0, r4
 800643a:	f7fb fc81 	bl	8001d40 <chSemWaitTimeout>
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800643e:	f1a0 31ff 	sub.w	r1, r0, #4294967295	; 0xffffffff
 8006442:	fab1 f181 	clz	r1, r1
 8006446:	0949      	lsrs	r1, r1, #5
 8006448:	2001      	movs	r0, #1
 800644a:	f7ff fad9 	bl	8005a00 <_test_assert>
 800644e:	b108      	cbz	r0, 8006454 <sem2_execute+0x24>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 8006450:	b002      	add	sp, #8
 8006452:	bd70      	pop	{r4, r5, r6, pc}
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 8006454:	6821      	ldr	r1, [r4, #0]
 8006456:	1b09      	subs	r1, r1, r4
 8006458:	fab1 f181 	clz	r1, r1
 800645c:	2002      	movs	r0, #2
 800645e:	0949      	lsrs	r1, r1, #5
 8006460:	f7ff face 	bl	8005a00 <_test_assert>
 8006464:	2800      	cmp	r0, #0
 8006466:	d1f3      	bne.n	8006450 <sem2_execute+0x20>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8006468:	68a1      	ldr	r1, [r4, #8]
 800646a:	fab1 f181 	clz	r1, r1
 800646e:	0949      	lsrs	r1, r1, #5
 8006470:	2003      	movs	r0, #3
 8006472:	f7ff fac5 	bl	8005a00 <_test_assert>
 8006476:	2800      	cmp	r0, #0
 8006478:	d1ea      	bne.n	8006450 <sem2_execute+0x20>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800647a:	4b3d      	ldr	r3, [pc, #244]	; (8006570 <sem2_execute+0x140>)

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800647c:	4a3d      	ldr	r2, [pc, #244]	; (8006574 <sem2_execute+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800647e:	699b      	ldr	r3, [r3, #24]
 8006480:	6811      	ldr	r1, [r2, #0]
 8006482:	689a      	ldr	r2, [r3, #8]
 8006484:	4b3c      	ldr	r3, [pc, #240]	; (8006578 <sem2_execute+0x148>)
 8006486:	9000      	str	r0, [sp, #0]
 8006488:	3a01      	subs	r2, #1
 800648a:	4608      	mov	r0, r1
 800648c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006490:	f7fb f9b6 	bl	8001800 <chThdCreateStatic>
 8006494:	4b39      	ldr	r3, [pc, #228]	; (800657c <sem2_execute+0x14c>)
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 8006496:	f241 3188 	movw	r1, #5000	; 0x1388
  test_assert(3, sem1.s_cnt == 0, "counter not zero");

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800649a:	6018      	str	r0, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 800649c:	4620      	mov	r0, r4
 800649e:	f7fb fc4f 	bl	8001d40 <chSemWaitTimeout>
 80064a2:	4605      	mov	r5, r0
  test_wait_threads();
 80064a4:	f7ff fb1c 	bl	8005ae0 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 80064a8:	fab5 f185 	clz	r1, r5
 80064ac:	0949      	lsrs	r1, r1, #5
 80064ae:	2004      	movs	r0, #4
 80064b0:	f7ff faa6 	bl	8005a00 <_test_assert>
 80064b4:	2800      	cmp	r0, #0
 80064b6:	d1cb      	bne.n	8006450 <sem2_execute+0x20>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 80064b8:	6821      	ldr	r1, [r4, #0]
 80064ba:	1b09      	subs	r1, r1, r4
 80064bc:	fab1 f181 	clz	r1, r1
 80064c0:	2005      	movs	r0, #5
 80064c2:	0949      	lsrs	r1, r1, #5
 80064c4:	f7ff fa9c 	bl	8005a00 <_test_assert>
 80064c8:	2800      	cmp	r0, #0
 80064ca:	d1c1      	bne.n	8006450 <sem2_execute+0x20>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 80064cc:	68a1      	ldr	r1, [r4, #8]
 80064ce:	fab1 f181 	clz	r1, r1
 80064d2:	0949      	lsrs	r1, r1, #5
 80064d4:	2006      	movs	r0, #6
 80064d6:	f7ff fa93 	bl	8005a00 <_test_assert>
 80064da:	4605      	mov	r5, r0
 80064dc:	2800      	cmp	r0, #0
 80064de:	d1b7      	bne.n	8006450 <sem2_execute+0x20>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 80064e0:	f7ff fb16 	bl	8005b10 <test_wait_tick>
 80064e4:	2320      	movs	r3, #32
 80064e6:	f383 8811 	msr	BASEPRI, r3
 80064ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80064ee:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 80064f0:	f385 8811 	msr	BASEPRI, r5
 80064f4:	2541      	movs	r5, #65	; 0x41
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 80064f6:	4628      	mov	r0, r5
 80064f8:	f7ff fa72 	bl	80059e0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 80064fc:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8006500:	481a      	ldr	r0, [pc, #104]	; (800656c <sem2_execute+0x13c>)
 8006502:	f7fb fc1d 	bl	8001d40 <chSemWaitTimeout>
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8006506:	f1a0 31ff 	sub.w	r1, r0, #4294967295	; 0xffffffff
 800650a:	fab1 f181 	clz	r1, r1
 800650e:	0949      	lsrs	r1, r1, #5
 8006510:	2007      	movs	r0, #7
 8006512:	f7ff fa75 	bl	8005a00 <_test_assert>
 8006516:	2800      	cmp	r0, #0
 8006518:	d19a      	bne.n	8006450 <sem2_execute+0x20>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800651a:	6821      	ldr	r1, [r4, #0]
 800651c:	1b09      	subs	r1, r1, r4
 800651e:	fab1 f181 	clz	r1, r1
 8006522:	2008      	movs	r0, #8
 8006524:	0949      	lsrs	r1, r1, #5
 8006526:	f7ff fa6b 	bl	8005a00 <_test_assert>
 800652a:	2800      	cmp	r0, #0
 800652c:	d190      	bne.n	8006450 <sem2_execute+0x20>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800652e:	68a1      	ldr	r1, [r4, #8]
 8006530:	fab1 f181 	clz	r1, r1
 8006534:	0949      	lsrs	r1, r1, #5
 8006536:	2009      	movs	r0, #9
 8006538:	f7ff fa62 	bl	8005a00 <_test_assert>
 800653c:	3501      	adds	r5, #1
 800653e:	b2ed      	uxtb	r5, r5
 8006540:	2800      	cmp	r0, #0
 8006542:	d185      	bne.n	8006450 <sem2_execute+0x20>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 8006544:	2d46      	cmp	r5, #70	; 0x46
 8006546:	d1d6      	bne.n	80064f6 <sem2_execute+0xc6>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 8006548:	490d      	ldr	r1, [pc, #52]	; (8006580 <sem2_execute+0x150>)
 800654a:	200a      	movs	r0, #10
 800654c:	f7ff fa70 	bl	8005a30 <_test_assert_sequence>
 8006550:	2800      	cmp	r0, #0
 8006552:	f47f af7d 	bne.w	8006450 <sem2_execute+0x20>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8006556:	f606 12d8 	addw	r2, r6, #2520	; 0x9d8
 800655a:	f606 11c4 	addw	r1, r6, #2500	; 0x9c4
 800655e:	200b      	movs	r0, #11
}
 8006560:	b002      	add	sp, #8
 8006562:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8006566:	f7ff ba8b 	b.w	8005a80 <_test_assert_time_window>
 800656a:	bf00      	nop
 800656c:	20000808 	.word	0x20000808
 8006570:	20000e78 	.word	0x20000e78
 8006574:	0800a700 	.word	0x0800a700
 8006578:	08006401 	.word	0x08006401
 800657c:	200019f8 	.word	0x200019f8
 8006580:	0800a9dc 	.word	0x0800a9dc
	...

08006590 <sem3_execute>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8006590:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006592:	4b20      	ldr	r3, [pc, #128]	; (8006614 <sem3_execute+0x84>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8006594:	4a20      	ldr	r2, [pc, #128]	; (8006618 <sem3_execute+0x88>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006596:	699b      	ldr	r3, [r3, #24]
 8006598:	6810      	ldr	r0, [r2, #0]
 800659a:	689a      	ldr	r2, [r3, #8]
 800659c:	4b1f      	ldr	r3, [pc, #124]	; (800661c <sem3_execute+0x8c>)
  chSemSignalWait(&sem1, &sem1);
 800659e:	4c20      	ldr	r4, [pc, #128]	; (8006620 <sem3_execute+0x90>)
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 80065a0:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80065a2:	2100      	movs	r1, #0
 80065a4:	3201      	adds	r2, #1
 80065a6:	9100      	str	r1, [sp, #0]
 80065a8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80065ac:	f7fb f928 	bl	8001800 <chThdCreateStatic>
 80065b0:	4b1c      	ldr	r3, [pc, #112]	; (8006624 <sem3_execute+0x94>)
  chSemSignalWait(&sem1, &sem1);
 80065b2:	4621      	mov	r1, r4
  chSemSignal(&sem1);
}

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80065b4:	6018      	str	r0, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 80065b6:	4620      	mov	r0, r4
 80065b8:	f7fb fc52 	bl	8001e60 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 80065bc:	6821      	ldr	r1, [r4, #0]
 80065be:	1b09      	subs	r1, r1, r4
 80065c0:	fab1 f181 	clz	r1, r1
 80065c4:	2001      	movs	r0, #1
 80065c6:	0949      	lsrs	r1, r1, #5
 80065c8:	f7ff fa1a 	bl	8005a00 <_test_assert>
 80065cc:	b108      	cbz	r0, 80065d2 <sem3_execute+0x42>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 80065ce:	b002      	add	sp, #8
 80065d0:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 80065d2:	68a1      	ldr	r1, [r4, #8]
 80065d4:	fab1 f181 	clz	r1, r1
 80065d8:	0949      	lsrs	r1, r1, #5
 80065da:	2002      	movs	r0, #2
 80065dc:	f7ff fa10 	bl	8005a00 <_test_assert>
 80065e0:	2800      	cmp	r0, #0
 80065e2:	d1f4      	bne.n	80065ce <sem3_execute+0x3e>

  chSemSignalWait(&sem1, &sem1);
 80065e4:	4621      	mov	r1, r4
 80065e6:	4620      	mov	r0, r4
 80065e8:	f7fb fc3a 	bl	8001e60 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 80065ec:	6821      	ldr	r1, [r4, #0]
 80065ee:	1b09      	subs	r1, r1, r4
 80065f0:	fab1 f181 	clz	r1, r1
 80065f4:	2003      	movs	r0, #3
 80065f6:	0949      	lsrs	r1, r1, #5
 80065f8:	f7ff fa02 	bl	8005a00 <_test_assert>
 80065fc:	2800      	cmp	r0, #0
 80065fe:	d1e6      	bne.n	80065ce <sem3_execute+0x3e>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8006600:	68a1      	ldr	r1, [r4, #8]
 8006602:	fab1 f181 	clz	r1, r1
 8006606:	0949      	lsrs	r1, r1, #5
 8006608:	2004      	movs	r0, #4
}
 800660a:	b002      	add	sp, #8
 800660c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8006610:	f7ff b9f6 	b.w	8005a00 <_test_assert>
 8006614:	20000e78 	.word	0x20000e78
 8006618:	0800a700 	.word	0x0800a700
 800661c:	08006391 	.word	0x08006391
 8006620:	20000808 	.word	0x20000808
 8006624:	200019f8 	.word	0x200019f8
	...

08006630 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 8006630:	b508      	push	{r3, lr}
 8006632:	2220      	movs	r2, #32
 8006634:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8006638:	6883      	ldr	r3, [r0, #8]
 800663a:	2b00      	cmp	r3, #0
 800663c:	dd05      	ble.n	800664a <thread4+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800663e:	f7fb f877 	bl	8001730 <chSchRescheduleS>
 8006642:	2300      	movs	r3, #0
 8006644:	f383 8811 	msr	BASEPRI, r3
 8006648:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 800664a:	f7fb fbe1 	bl	8001e10 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800664e:	f7fb f86f 	bl	8001730 <chSchRescheduleS>
 8006652:	2300      	movs	r3, #0
 8006654:	f383 8811 	msr	BASEPRI, r3
 8006658:	bd08      	pop	{r3, pc}
 800665a:	bf00      	nop
 800665c:	0000      	movs	r0, r0
	...

08006660 <sem4_execute>:

  chBSemSignal((binary_semaphore_t *)p);
}

static void sem4_execute(void) {
 8006660:	b570      	push	{r4, r5, r6, lr}
 8006662:	b086      	sub	sp, #24
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 8006664:	a803      	add	r0, sp, #12
 8006666:	2100      	movs	r1, #0
 8006668:	f7fb fb12 	bl	8001c90 <chSemObjectInit>
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800666c:	a803      	add	r0, sp, #12
 800666e:	2100      	movs	r1, #0
 8006670:	f7fb fb2e 	bl	8001cd0 <chSemReset>
 8006674:	2520      	movs	r5, #32
 8006676:	f385 8811 	msr	BASEPRI, r5
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800667a:	9905      	ldr	r1, [sp, #20]
 800667c:	2900      	cmp	r1, #0
 800667e:	bfcc      	ite	gt
 8006680:	2100      	movgt	r1, #0
 8006682:	2101      	movle	r1, #1
 8006684:	2001      	movs	r0, #1
 8006686:	f7ff f9bb 	bl	8005a00 <_test_assert>
 800668a:	b120      	cbz	r0, 8006696 <sem4_execute+0x36>
 800668c:	2300      	movs	r3, #0
 800668e:	f383 8811 	msr	BASEPRI, r3

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 8006692:	b006      	add	sp, #24
 8006694:	bd70      	pop	{r4, r5, r6, pc}
 8006696:	4604      	mov	r4, r0
 8006698:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800669c:	4b40      	ldr	r3, [pc, #256]	; (80067a0 <sem4_execute+0x140>)
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800669e:	4a41      	ldr	r2, [pc, #260]	; (80067a4 <sem4_execute+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80066a0:	699b      	ldr	r3, [r3, #24]
 80066a2:	6810      	ldr	r0, [r2, #0]
 80066a4:	689a      	ldr	r2, [r3, #8]
 80066a6:	4b40      	ldr	r3, [pc, #256]	; (80067a8 <sem4_execute+0x148>)
 80066a8:	a903      	add	r1, sp, #12
 80066aa:	9100      	str	r1, [sp, #0]
 80066ac:	3a01      	subs	r2, #1
 80066ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80066b2:	f7fb f8a5 	bl	8001800 <chThdCreateStatic>
 80066b6:	4b3d      	ldr	r3, [pc, #244]	; (80067ac <sem4_execute+0x14c>)
 80066b8:	6018      	str	r0, [r3, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 80066ba:	a803      	add	r0, sp, #12
 80066bc:	f7fb fb18 	bl	8001cf0 <chSemWait>
 80066c0:	f385 8811 	msr	BASEPRI, r5
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 80066c4:	9905      	ldr	r1, [sp, #20]
 80066c6:	2900      	cmp	r1, #0
 80066c8:	bfcc      	ite	gt
 80066ca:	2100      	movgt	r1, #0
 80066cc:	2101      	movle	r1, #1
 80066ce:	2002      	movs	r0, #2
 80066d0:	f7ff f996 	bl	8005a00 <_test_assert>
 80066d4:	b118      	cbz	r0, 80066de <sem4_execute+0x7e>
 80066d6:	f384 8811 	msr	BASEPRI, r4

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 80066da:	b006      	add	sp, #24
 80066dc:	bd70      	pop	{r4, r5, r6, pc}
 80066de:	f380 8811 	msr	BASEPRI, r0
 80066e2:	f385 8811 	msr	BASEPRI, r5
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80066e6:	9b05      	ldr	r3, [sp, #20]
 80066e8:	2b00      	cmp	r3, #0
 80066ea:	dd24      	ble.n	8006736 <sem4_execute+0xd6>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80066ec:	f7fb f820 	bl	8001730 <chSchRescheduleS>
 80066f0:	2400      	movs	r4, #0
 80066f2:	f384 8811 	msr	BASEPRI, r4
 80066f6:	2620      	movs	r6, #32
 80066f8:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 80066fc:	9905      	ldr	r1, [sp, #20]
 80066fe:	42a1      	cmp	r1, r4
 8006700:	f04f 0003 	mov.w	r0, #3
 8006704:	bfd4      	ite	le
 8006706:	2100      	movle	r1, #0
 8006708:	2101      	movgt	r1, #1
 800670a:	f7ff f979 	bl	8005a00 <_test_assert>
 800670e:	4605      	mov	r5, r0
 8006710:	2800      	cmp	r0, #0
 8006712:	d1e0      	bne.n	80066d6 <sem4_execute+0x76>
 8006714:	f380 8811 	msr	BASEPRI, r0
 8006718:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800671c:	9905      	ldr	r1, [sp, #20]
 800671e:	f1a1 0101 	sub.w	r1, r1, #1
 8006722:	fab1 f181 	clz	r1, r1
 8006726:	2004      	movs	r0, #4
 8006728:	0949      	lsrs	r1, r1, #5
 800672a:	f7ff f969 	bl	8005a00 <_test_assert>
 800672e:	b130      	cbz	r0, 800673e <sem4_execute+0xde>
 8006730:	f385 8811 	msr	BASEPRI, r5
 8006734:	e7ad      	b.n	8006692 <sem4_execute+0x32>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8006736:	a803      	add	r0, sp, #12
 8006738:	f7fb fb6a 	bl	8001e10 <chSemSignalI>
 800673c:	e7d6      	b.n	80066ec <sem4_execute+0x8c>
 800673e:	f380 8811 	msr	BASEPRI, r0
 8006742:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8006746:	9b05      	ldr	r3, [sp, #20]
 8006748:	2b00      	cmp	r3, #0
 800674a:	dd25      	ble.n	8006798 <sem4_execute+0x138>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800674c:	f7fa fff0 	bl	8001730 <chSchRescheduleS>
 8006750:	2400      	movs	r4, #0
 8006752:	f384 8811 	msr	BASEPRI, r4
 8006756:	2620      	movs	r6, #32
 8006758:	f386 8811 	msr	BASEPRI, r6

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 800675c:	9905      	ldr	r1, [sp, #20]
 800675e:	42a1      	cmp	r1, r4
 8006760:	f04f 0003 	mov.w	r0, #3
 8006764:	bfd4      	ite	le
 8006766:	2100      	movle	r1, #0
 8006768:	2101      	movgt	r1, #1
 800676a:	f7ff f949 	bl	8005a00 <_test_assert>
 800676e:	4605      	mov	r5, r0
 8006770:	2800      	cmp	r0, #0
 8006772:	d1b0      	bne.n	80066d6 <sem4_execute+0x76>
 8006774:	f380 8811 	msr	BASEPRI, r0
 8006778:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800677c:	9905      	ldr	r1, [sp, #20]
 800677e:	f1a1 0101 	sub.w	r1, r1, #1
 8006782:	fab1 f181 	clz	r1, r1
 8006786:	2005      	movs	r0, #5
 8006788:	0949      	lsrs	r1, r1, #5
 800678a:	f7ff f939 	bl	8005a00 <_test_assert>
 800678e:	2800      	cmp	r0, #0
 8006790:	d1ce      	bne.n	8006730 <sem4_execute+0xd0>
 8006792:	f380 8811 	msr	BASEPRI, r0
 8006796:	e77c      	b.n	8006692 <sem4_execute+0x32>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8006798:	a803      	add	r0, sp, #12
 800679a:	f7fb fb39 	bl	8001e10 <chSemSignalI>
 800679e:	e7d5      	b.n	800674c <sem4_execute+0xec>
 80067a0:	20000e78 	.word	0x20000e78
 80067a4:	0800a700 	.word	0x0800a700
 80067a8:	08006631 	.word	0x08006631
 80067ac:	200019f8 	.word	0x200019f8

080067b0 <mtx1_execute>:
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 80067b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80067b2:	4f2b      	ldr	r7, [pc, #172]	; (8006860 <mtx1_execute+0xb0>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80067b4:	4e2b      	ldr	r6, [pc, #172]	; (8006864 <mtx1_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80067b6:	69bb      	ldr	r3, [r7, #24]
}

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80067b8:	482b      	ldr	r0, [pc, #172]	; (8006868 <mtx1_execute+0xb8>)
 80067ba:	689c      	ldr	r4, [r3, #8]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80067bc:	4d2b      	ldr	r5, [pc, #172]	; (800686c <mtx1_execute+0xbc>)
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 80067be:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80067c0:	f7fb fbf6 	bl	8001fb0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80067c4:	4b2a      	ldr	r3, [pc, #168]	; (8006870 <mtx1_execute+0xc0>)
 80067c6:	9300      	str	r3, [sp, #0]
 80067c8:	1c62      	adds	r2, r4, #1
 80067ca:	4b2a      	ldr	r3, [pc, #168]	; (8006874 <mtx1_execute+0xc4>)
 80067cc:	6830      	ldr	r0, [r6, #0]
 80067ce:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80067d2:	f7fb f815 	bl	8001800 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80067d6:	6871      	ldr	r1, [r6, #4]
 80067d8:	4b27      	ldr	r3, [pc, #156]	; (8006878 <mtx1_execute+0xc8>)

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80067da:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80067dc:	1ca2      	adds	r2, r4, #2
 80067de:	4608      	mov	r0, r1
 80067e0:	9300      	str	r3, [sp, #0]
 80067e2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80067e6:	4b23      	ldr	r3, [pc, #140]	; (8006874 <mtx1_execute+0xc4>)
 80067e8:	f7fb f80a 	bl	8001800 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80067ec:	68b1      	ldr	r1, [r6, #8]
 80067ee:	4b23      	ldr	r3, [pc, #140]	; (800687c <mtx1_execute+0xcc>)
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80067f0:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80067f2:	1ce2      	adds	r2, r4, #3
 80067f4:	4608      	mov	r0, r1
 80067f6:	9300      	str	r3, [sp, #0]
 80067f8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80067fc:	4b1d      	ldr	r3, [pc, #116]	; (8006874 <mtx1_execute+0xc4>)
 80067fe:	f7fa ffff 	bl	8001800 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006802:	68f1      	ldr	r1, [r6, #12]
 8006804:	4b1e      	ldr	r3, [pc, #120]	; (8006880 <mtx1_execute+0xd0>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8006806:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006808:	1d22      	adds	r2, r4, #4
 800680a:	4608      	mov	r0, r1
 800680c:	9300      	str	r3, [sp, #0]
 800680e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006812:	4b18      	ldr	r3, [pc, #96]	; (8006874 <mtx1_execute+0xc4>)
 8006814:	f7fa fff4 	bl	8001800 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8006818:	6931      	ldr	r1, [r6, #16]
 800681a:	4b1a      	ldr	r3, [pc, #104]	; (8006884 <mtx1_execute+0xd4>)
  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800681c:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800681e:	1d62      	adds	r2, r4, #5
 8006820:	4608      	mov	r0, r1
 8006822:	9300      	str	r3, [sp, #0]
 8006824:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006828:	4b12      	ldr	r3, [pc, #72]	; (8006874 <mtx1_execute+0xc4>)
 800682a:	f7fa ffe9 	bl	8001800 <chThdCreateStatic>
 800682e:	6128      	str	r0, [r5, #16]
  chMtxUnlock(&m1);
 8006830:	480d      	ldr	r0, [pc, #52]	; (8006868 <mtx1_execute+0xb8>)
 8006832:	f7fb fbe5 	bl	8002000 <chMtxUnlock>
  test_wait_threads();
 8006836:	f7ff f953 	bl	8005ae0 <test_wait_threads>
 800683a:	69bb      	ldr	r3, [r7, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 800683c:	6899      	ldr	r1, [r3, #8]
 800683e:	1b09      	subs	r1, r1, r4
 8006840:	fab1 f181 	clz	r1, r1
 8006844:	2001      	movs	r0, #1
 8006846:	0949      	lsrs	r1, r1, #5
 8006848:	f7ff f8da 	bl	8005a00 <_test_assert>
 800684c:	b108      	cbz	r0, 8006852 <mtx1_execute+0xa2>
  test_assert_sequence(2, "ABCDE");
}
 800684e:	b003      	add	sp, #12
 8006850:	bdf0      	pop	{r4, r5, r6, r7, pc}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 8006852:	490d      	ldr	r1, [pc, #52]	; (8006888 <mtx1_execute+0xd8>)
 8006854:	2002      	movs	r0, #2
}
 8006856:	b003      	add	sp, #12
 8006858:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 800685c:	f7ff b8e8 	b.w	8005a30 <_test_assert_sequence>
 8006860:	20000e78 	.word	0x20000e78
 8006864:	0800a700 	.word	0x0800a700
 8006868:	20000814 	.word	0x20000814
 800686c:	200019f8 	.word	0x200019f8
 8006870:	0800a9e0 	.word	0x0800a9e0
 8006874:	08006891 	.word	0x08006891
 8006878:	0800b864 	.word	0x0800b864
 800687c:	0800a9d0 	.word	0x0800a9d0
 8006880:	0800a9d4 	.word	0x0800a9d4
 8006884:	0800a9d8 	.word	0x0800a9d8
 8006888:	0800a9dc 	.word	0x0800a9dc
 800688c:	00000000 	.word	0x00000000

08006890 <thread1>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8006890:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8006892:	4c06      	ldr	r4, [pc, #24]	; (80068ac <thread1+0x1c>)
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8006894:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8006896:	4620      	mov	r0, r4
 8006898:	f7fb fb8a 	bl	8001fb0 <chMtxLock>
  test_emit_token(*(char *)p);
 800689c:	7828      	ldrb	r0, [r5, #0]
 800689e:	f7ff f89f 	bl	80059e0 <test_emit_token>
  chMtxUnlock(&m1);
 80068a2:	4620      	mov	r0, r4
}
 80068a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread1, p) {

  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 80068a8:	f7fb bbaa 	b.w	8002000 <chMtxUnlock>
 80068ac:	20000814 	.word	0x20000814

080068b0 <thread12>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 80068b0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 80068b2:	4c06      	ldr	r4, [pc, #24]	; (80068cc <thread12+0x1c>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 80068b4:	4605      	mov	r5, r0

  chMtxLock(&m2);
 80068b6:	4620      	mov	r0, r4
 80068b8:	f7fb fb7a 	bl	8001fb0 <chMtxLock>
  test_emit_token(*(char *)p);
 80068bc:	7828      	ldrb	r0, [r5, #0]
 80068be:	f7ff f88f 	bl	80059e0 <test_emit_token>
  chMtxUnlock(&m2);
 80068c2:	4620      	mov	r0, r4
}
 80068c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread12, p) {

  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
 80068c8:	f7fb bb9a 	b.w	8002000 <chMtxUnlock>
 80068cc:	20000824 	.word	0x20000824

080068d0 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 80068d0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 80068d2:	4804      	ldr	r0, [pc, #16]	; (80068e4 <mtx4_setup+0x14>)
 80068d4:	f7fb fafc 	bl	8001ed0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 80068d8:	4803      	ldr	r0, [pc, #12]	; (80068e8 <mtx4_setup+0x18>)
}
 80068da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx4_setup(void) {

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
 80068de:	f7fb baf7 	b.w	8001ed0 <chMtxObjectInit>
 80068e2:	bf00      	nop
 80068e4:	20000814 	.word	0x20000814
 80068e8:	20000824 	.word	0x20000824
 80068ec:	00000000 	.word	0x00000000

080068f0 <mtx5_setup>:
 * operation.
 */

static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
 80068f0:	4801      	ldr	r0, [pc, #4]	; (80068f8 <mtx5_setup+0x8>)
 80068f2:	f7fb baed 	b.w	8001ed0 <chMtxObjectInit>
 80068f6:	bf00      	nop
 80068f8:	20000814 	.word	0x20000814
 80068fc:	00000000 	.word	0x00000000

08006900 <mtx1_setup>:
 8006900:	f7ff bff6 	b.w	80068f0 <mtx5_setup>
	...

08006910 <thread4b>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread4b, p) {
 8006910:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
 8006912:	4c06      	ldr	r4, [pc, #24]	; (800692c <thread4b+0x1c>)
}

static THD_FUNCTION(thread4b, p) {

  (void)p;
  chThdSleepMilliseconds(150);
 8006914:	f240 50dc 	movw	r0, #1500	; 0x5dc
 8006918:	f7fa ffe2 	bl	80018e0 <chThdSleep>
  chMtxLock(&m1);
 800691c:	4620      	mov	r0, r4
 800691e:	f7fb fb47 	bl	8001fb0 <chMtxLock>
  chMtxUnlock(&m1);
 8006922:	4620      	mov	r0, r4
}
 8006924:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4b, p) {

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
 8006928:	f7fb bb6a 	b.w	8002000 <chMtxUnlock>
 800692c:	20000814 	.word	0x20000814

08006930 <thread4a>:

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 8006930:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
 8006932:	4c06      	ldr	r4, [pc, #24]	; (800694c <thread4a+0x1c>)
}

static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8006934:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8006938:	f7fa ffd2 	bl	80018e0 <chThdSleep>
  chMtxLock(&m2);
 800693c:	4620      	mov	r0, r4
 800693e:	f7fb fb37 	bl	8001fb0 <chMtxLock>
  chMtxUnlock(&m2);
 8006942:	4620      	mov	r0, r4
}
 8006944:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
 8006948:	f7fb bb5a 	b.w	8002000 <chMtxUnlock>
 800694c:	20000824 	.word	0x20000824

08006950 <mtx4_execute>:
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8006950:	e92d 46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006954:	4d8e      	ldr	r5, [pc, #568]	; (8006b90 <mtx4_execute+0x240>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8006956:	4e8f      	ldr	r6, [pc, #572]	; (8006b94 <mtx4_execute+0x244>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006958:	69ab      	ldr	r3, [r5, #24]
 800695a:	6832      	ldr	r2, [r6, #0]
 800695c:	689c      	ldr	r4, [r3, #8]
 800695e:	4b8e      	ldr	r3, [pc, #568]	; (8006b98 <mtx4_execute+0x248>)
 8006960:	4f8e      	ldr	r7, [pc, #568]	; (8006b9c <mtx4_execute+0x24c>)
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8006962:	b085      	sub	sp, #20
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8006964:	f104 0901 	add.w	r9, r4, #1
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8006968:	4610      	mov	r0, r2
 800696a:	9203      	str	r2, [sp, #12]
 800696c:	9300      	str	r3, [sp, #0]
 800696e:	464a      	mov	r2, r9
 8006970:	4b8b      	ldr	r3, [pc, #556]	; (8006ba0 <mtx4_execute+0x250>)
 8006972:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006976:	f7fa ff43 	bl	8001800 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800697a:	6876      	ldr	r6, [r6, #4]
 800697c:	4b89      	ldr	r3, [pc, #548]	; (8006ba4 <mtx4_execute+0x254>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800697e:	6038      	str	r0, [r7, #0]
static void mtx4_execute(void) {
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
 8006980:	f104 0a02 	add.w	sl, r4, #2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8006984:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006988:	4652      	mov	r2, sl
 800698a:	9300      	str	r3, [sp, #0]
 800698c:	4630      	mov	r0, r6
 800698e:	4b86      	ldr	r3, [pc, #536]	; (8006ba8 <mtx4_execute+0x258>)
 8006990:	f7fa ff36 	bl	8001800 <chThdCreateStatic>
 8006994:	6078      	str	r0, [r7, #4]
  chMtxLock(&m2);
 8006996:	4885      	ldr	r0, [pc, #532]	; (8006bac <mtx4_execute+0x25c>)
 8006998:	f7fb fb0a 	bl	8001fb0 <chMtxLock>
 800699c:	69ab      	ldr	r3, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 800699e:	6899      	ldr	r1, [r3, #8]
 80069a0:	1b09      	subs	r1, r1, r4
 80069a2:	fab1 f181 	clz	r1, r1
 80069a6:	2001      	movs	r0, #1
 80069a8:	0949      	lsrs	r1, r1, #5
 80069aa:	f7ff f829 	bl	8005a00 <_test_assert>
 80069ae:	b110      	cbz	r0, 80069b6 <mtx4_execute+0x66>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 80069b0:	b005      	add	sp, #20
 80069b2:	e8bd 86f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 80069b6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80069ba:	f7fa ff91 	bl	80018e0 <chThdSleep>
 80069be:	69ab      	ldr	r3, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 80069c0:	6899      	ldr	r1, [r3, #8]
 80069c2:	ebc9 0101 	rsb	r1, r9, r1
 80069c6:	fab1 f181 	clz	r1, r1
 80069ca:	2002      	movs	r0, #2
 80069cc:	0949      	lsrs	r1, r1, #5
 80069ce:	f7ff f817 	bl	8005a00 <_test_assert>
 80069d2:	2800      	cmp	r0, #0
 80069d4:	d1ec      	bne.n	80069b0 <mtx4_execute+0x60>
  chMtxLock(&m1);
 80069d6:	4876      	ldr	r0, [pc, #472]	; (8006bb0 <mtx4_execute+0x260>)
 80069d8:	f7fb faea 	bl	8001fb0 <chMtxLock>
 80069dc:	69ab      	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 80069de:	6899      	ldr	r1, [r3, #8]
 80069e0:	ebc9 0101 	rsb	r1, r9, r1
 80069e4:	fab1 f181 	clz	r1, r1
 80069e8:	2003      	movs	r0, #3
 80069ea:	0949      	lsrs	r1, r1, #5
 80069ec:	f7ff f808 	bl	8005a00 <_test_assert>
 80069f0:	2800      	cmp	r0, #0
 80069f2:	d1dd      	bne.n	80069b0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 80069f4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80069f8:	f7fa ff72 	bl	80018e0 <chThdSleep>
 80069fc:	69ab      	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 80069fe:	6899      	ldr	r1, [r3, #8]
 8006a00:	ebca 0101 	rsb	r1, sl, r1
 8006a04:	fab1 f181 	clz	r1, r1
 8006a08:	2004      	movs	r0, #4
 8006a0a:	0949      	lsrs	r1, r1, #5
 8006a0c:	f7fe fff8 	bl	8005a00 <_test_assert>
 8006a10:	2800      	cmp	r0, #0
 8006a12:	d1cd      	bne.n	80069b0 <mtx4_execute+0x60>
  chMtxUnlock(&m1);
 8006a14:	4866      	ldr	r0, [pc, #408]	; (8006bb0 <mtx4_execute+0x260>)
 8006a16:	f7fb faf3 	bl	8002000 <chMtxUnlock>
 8006a1a:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 8006a1c:	6899      	ldr	r1, [r3, #8]
 8006a1e:	ebc9 0101 	rsb	r1, r9, r1
 8006a22:	fab1 f181 	clz	r1, r1
 8006a26:	2005      	movs	r0, #5
 8006a28:	0949      	lsrs	r1, r1, #5
 8006a2a:	f7fe ffe9 	bl	8005a00 <_test_assert>
 8006a2e:	2800      	cmp	r0, #0
 8006a30:	d1be      	bne.n	80069b0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006a32:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006a36:	f7fa ff53 	bl	80018e0 <chThdSleep>
 8006a3a:	69ab      	ldr	r3, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 8006a3c:	6899      	ldr	r1, [r3, #8]
 8006a3e:	ebc9 0101 	rsb	r1, r9, r1
 8006a42:	fab1 f181 	clz	r1, r1
 8006a46:	2006      	movs	r0, #6
 8006a48:	0949      	lsrs	r1, r1, #5
 8006a4a:	f7fe ffd9 	bl	8005a00 <_test_assert>
 8006a4e:	2800      	cmp	r0, #0
 8006a50:	d1ae      	bne.n	80069b0 <mtx4_execute+0x60>
  chMtxUnlockAll();
 8006a52:	f7fb fb2d 	bl	80020b0 <chMtxUnlockAll>
 8006a56:	69ab      	ldr	r3, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 8006a58:	6899      	ldr	r1, [r3, #8]
 8006a5a:	1b09      	subs	r1, r1, r4
 8006a5c:	fab1 f181 	clz	r1, r1
 8006a60:	2007      	movs	r0, #7
 8006a62:	0949      	lsrs	r1, r1, #5
 8006a64:	f7fe ffcc 	bl	8005a00 <_test_assert>
 8006a68:	2800      	cmp	r0, #0
 8006a6a:	d1a1      	bne.n	80069b0 <mtx4_execute+0x60>
  test_wait_threads();
 8006a6c:	f7ff f838 	bl	8005ae0 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8006a70:	4b50      	ldr	r3, [pc, #320]	; (8006bb4 <mtx4_execute+0x264>)
 8006a72:	9300      	str	r3, [sp, #0]
 8006a74:	464a      	mov	r2, r9
 8006a76:	4b4a      	ldr	r3, [pc, #296]	; (8006ba0 <mtx4_execute+0x250>)
 8006a78:	9803      	ldr	r0, [sp, #12]
 8006a7a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006a7e:	f7fa febf 	bl	8001800 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8006a82:	4b4d      	ldr	r3, [pc, #308]	; (8006bb8 <mtx4_execute+0x268>)
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8006a84:	6038      	str	r0, [r7, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8006a86:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006a8a:	9300      	str	r3, [sp, #0]
 8006a8c:	4652      	mov	r2, sl
 8006a8e:	4b46      	ldr	r3, [pc, #280]	; (8006ba8 <mtx4_execute+0x258>)
 8006a90:	4630      	mov	r0, r6
 8006a92:	f7fa feb5 	bl	8001800 <chThdCreateStatic>
 8006a96:	6078      	str	r0, [r7, #4]
  chMtxLock(&m2);
 8006a98:	4844      	ldr	r0, [pc, #272]	; (8006bac <mtx4_execute+0x25c>)
 8006a9a:	f7fb fa89 	bl	8001fb0 <chMtxLock>
 8006a9e:	69ab      	ldr	r3, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8006aa0:	6899      	ldr	r1, [r3, #8]
 8006aa2:	1b09      	subs	r1, r1, r4
 8006aa4:	fab1 f181 	clz	r1, r1
 8006aa8:	2008      	movs	r0, #8
 8006aaa:	0949      	lsrs	r1, r1, #5
 8006aac:	f7fe ffa8 	bl	8005a00 <_test_assert>
 8006ab0:	2800      	cmp	r0, #0
 8006ab2:	f47f af7d 	bne.w	80069b0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006ab6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006aba:	f7fa ff11 	bl	80018e0 <chThdSleep>
 8006abe:	69ab      	ldr	r3, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 8006ac0:	6899      	ldr	r1, [r3, #8]
 8006ac2:	ebc9 0c01 	rsb	ip, r9, r1
 8006ac6:	f1dc 0100 	rsbs	r1, ip, #0
 8006aca:	eb41 010c 	adc.w	r1, r1, ip
 8006ace:	2009      	movs	r0, #9
 8006ad0:	f7fe ff96 	bl	8005a00 <_test_assert>
 8006ad4:	2800      	cmp	r0, #0
 8006ad6:	f47f af6b 	bne.w	80069b0 <mtx4_execute+0x60>
  chMtxLock(&m1);
 8006ada:	4835      	ldr	r0, [pc, #212]	; (8006bb0 <mtx4_execute+0x260>)
 8006adc:	f7fb fa68 	bl	8001fb0 <chMtxLock>
 8006ae0:	69ab      	ldr	r3, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 8006ae2:	6899      	ldr	r1, [r3, #8]
 8006ae4:	ebc9 0e01 	rsb	lr, r9, r1
 8006ae8:	f1de 0100 	rsbs	r1, lr, #0
 8006aec:	eb41 010e 	adc.w	r1, r1, lr
 8006af0:	200a      	movs	r0, #10
 8006af2:	f7fe ff85 	bl	8005a00 <_test_assert>
 8006af6:	2800      	cmp	r0, #0
 8006af8:	f47f af5a 	bne.w	80069b0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006afc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006b00:	f7fa feee 	bl	80018e0 <chThdSleep>
 8006b04:	69ab      	ldr	r3, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 8006b06:	6899      	ldr	r1, [r3, #8]
 8006b08:	ebca 0701 	rsb	r7, sl, r1
 8006b0c:	4279      	negs	r1, r7
 8006b0e:	f04f 000b 	mov.w	r0, #11
 8006b12:	4179      	adcs	r1, r7
 8006b14:	f7fe ff74 	bl	8005a00 <_test_assert>
 8006b18:	4606      	mov	r6, r0
 8006b1a:	2800      	cmp	r0, #0
 8006b1c:	f47f af48 	bne.w	80069b0 <mtx4_execute+0x60>
 8006b20:	2320      	movs	r3, #32
 8006b22:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxUnlockS(&m1);
 8006b26:	4822      	ldr	r0, [pc, #136]	; (8006bb0 <mtx4_execute+0x260>)
 8006b28:	f7fb fa9a 	bl	8002060 <chMtxUnlockS>
  chSchRescheduleS();
 8006b2c:	f7fa fe00 	bl	8001730 <chSchRescheduleS>
 8006b30:	f386 8811 	msr	BASEPRI, r6
 8006b34:	69ab      	ldr	r3, [r5, #24]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 8006b36:	6899      	ldr	r1, [r3, #8]
 8006b38:	ebc9 0601 	rsb	r6, r9, r1
 8006b3c:	4271      	negs	r1, r6
 8006b3e:	4171      	adcs	r1, r6
 8006b40:	200c      	movs	r0, #12
 8006b42:	f7fe ff5d 	bl	8005a00 <_test_assert>
 8006b46:	2800      	cmp	r0, #0
 8006b48:	f47f af32 	bne.w	80069b0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006b4c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006b50:	f7fa fec6 	bl	80018e0 <chThdSleep>
 8006b54:	69ab      	ldr	r3, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8006b56:	6899      	ldr	r1, [r3, #8]
 8006b58:	ebc9 0201 	rsb	r2, r9, r1
 8006b5c:	4251      	negs	r1, r2
 8006b5e:	4151      	adcs	r1, r2
 8006b60:	200d      	movs	r0, #13
 8006b62:	f7fe ff4d 	bl	8005a00 <_test_assert>
 8006b66:	2800      	cmp	r0, #0
 8006b68:	f47f af22 	bne.w	80069b0 <mtx4_execute+0x60>
  chMtxUnlockAll();
 8006b6c:	f7fb faa0 	bl	80020b0 <chMtxUnlockAll>
 8006b70:	69ab      	ldr	r3, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8006b72:	6899      	ldr	r1, [r3, #8]
 8006b74:	1b0b      	subs	r3, r1, r4
 8006b76:	4259      	negs	r1, r3
 8006b78:	4159      	adcs	r1, r3
 8006b7a:	200e      	movs	r0, #14
 8006b7c:	f7fe ff40 	bl	8005a00 <_test_assert>
 8006b80:	2800      	cmp	r0, #0
 8006b82:	f47f af15 	bne.w	80069b0 <mtx4_execute+0x60>
  test_wait_threads();
}
 8006b86:	b005      	add	sp, #20
 8006b88:	e8bd 46f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, lr}
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
 8006b8c:	f7fe bfa8 	b.w	8005ae0 <test_wait_threads>
 8006b90:	20000e78 	.word	0x20000e78
 8006b94:	0800a700 	.word	0x0800a700
 8006b98:	0800a9d4 	.word	0x0800a9d4
 8006b9c:	200019f8 	.word	0x200019f8
 8006ba0:	08006931 	.word	0x08006931
 8006ba4:	0800a9d8 	.word	0x0800a9d8
 8006ba8:	08006911 	.word	0x08006911
 8006bac:	20000824 	.word	0x20000824
 8006bb0:	20000814 	.word	0x20000814
 8006bb4:	0800b864 	.word	0x0800b864
 8006bb8:	0800a9d0 	.word	0x0800a9d0
 8006bbc:	00000000 	.word	0x00000000

08006bc0 <mtx5_execute>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 8006bc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006bc2:	4d2b      	ldr	r5, [pc, #172]	; (8006c70 <mtx5_execute+0xb0>)

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
 8006bc4:	4c2b      	ldr	r4, [pc, #172]	; (8006c74 <mtx5_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006bc6:	69ab      	ldr	r3, [r5, #24]
 8006bc8:	4620      	mov	r0, r4
 8006bca:	689e      	ldr	r6, [r3, #8]
 8006bcc:	f7fb fa00 	bl	8001fd0 <chMtxTryLock>
  test_assert(1, b, "already locked");
 8006bd0:	4601      	mov	r1, r0
 8006bd2:	2001      	movs	r0, #1
 8006bd4:	f7fe ff14 	bl	8005a00 <_test_assert>
 8006bd8:	b100      	cbz	r0, 8006bdc <mtx5_execute+0x1c>
 8006bda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  b = chMtxTryLock(&m1);
 8006bdc:	4620      	mov	r0, r4
 8006bde:	f7fb f9f7 	bl	8001fd0 <chMtxTryLock>
  test_assert(2, !b, "not locked");
 8006be2:	f080 0101 	eor.w	r1, r0, #1
 8006be6:	b2c9      	uxtb	r1, r1
 8006be8:	2002      	movs	r0, #2
 8006bea:	f7fe ff09 	bl	8005a00 <_test_assert>
 8006bee:	4607      	mov	r7, r0
 8006bf0:	2800      	cmp	r0, #0
 8006bf2:	d1f2      	bne.n	8006bda <mtx5_execute+0x1a>
 8006bf4:	2320      	movs	r3, #32
 8006bf6:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxUnlockS(&m1);
 8006bfa:	4620      	mov	r0, r4
 8006bfc:	f7fb fa30 	bl	8002060 <chMtxUnlockS>
 8006c00:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8006c04:	6821      	ldr	r1, [r4, #0]
 8006c06:	1b09      	subs	r1, r1, r4
 8006c08:	fab1 f181 	clz	r1, r1
 8006c0c:	2003      	movs	r0, #3
 8006c0e:	0949      	lsrs	r1, r1, #5
 8006c10:	f7fe fef6 	bl	8005a00 <_test_assert>
 8006c14:	2800      	cmp	r0, #0
 8006c16:	d1e0      	bne.n	8006bda <mtx5_execute+0x1a>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8006c18:	68a1      	ldr	r1, [r4, #8]
 8006c1a:	fab1 f181 	clz	r1, r1
 8006c1e:	0949      	lsrs	r1, r1, #5
 8006c20:	2004      	movs	r0, #4
 8006c22:	f7fe feed 	bl	8005a00 <_test_assert>
 8006c26:	2800      	cmp	r0, #0
 8006c28:	d1d7      	bne.n	8006bda <mtx5_execute+0x1a>
 8006c2a:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 8006c2c:	6899      	ldr	r1, [r3, #8]
 8006c2e:	1b89      	subs	r1, r1, r6
 8006c30:	fab1 f181 	clz	r1, r1
 8006c34:	2005      	movs	r0, #5
 8006c36:	0949      	lsrs	r1, r1, #5
 8006c38:	f7fe fee2 	bl	8005a00 <_test_assert>
 8006c3c:	2800      	cmp	r0, #0
 8006c3e:	d1cc      	bne.n	8006bda <mtx5_execute+0x1a>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8006c40:	4620      	mov	r0, r4
 8006c42:	f7fb f9b5 	bl	8001fb0 <chMtxLock>
  chMtxUnlockAll();
 8006c46:	f7fb fa33 	bl	80020b0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 8006c4a:	6821      	ldr	r1, [r4, #0]
 8006c4c:	1b09      	subs	r1, r1, r4
 8006c4e:	fab1 f181 	clz	r1, r1
 8006c52:	2006      	movs	r0, #6
 8006c54:	0949      	lsrs	r1, r1, #5
 8006c56:	f7fe fed3 	bl	8005a00 <_test_assert>
 8006c5a:	2800      	cmp	r0, #0
 8006c5c:	d1bd      	bne.n	8006bda <mtx5_execute+0x1a>
  test_assert(7, m1.m_owner == NULL, "still owned");
 8006c5e:	68a1      	ldr	r1, [r4, #8]
 8006c60:	fab1 f181 	clz	r1, r1
 8006c64:	0949      	lsrs	r1, r1, #5
 8006c66:	2007      	movs	r0, #7
}
 8006c68:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
 8006c6c:	f7fe bec8 	b.w	8005a00 <_test_assert>
 8006c70:	20000e78 	.word	0x20000e78
 8006c74:	20000814 	.word	0x20000814
	...

08006c80 <mtx6_execute>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8006c80:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006c82:	4b2f      	ldr	r3, [pc, #188]	; (8006d40 <mtx6_execute+0xc0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8006c84:	4f2f      	ldr	r7, [pc, #188]	; (8006d44 <mtx6_execute+0xc4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006c86:	699b      	ldr	r3, [r3, #24]
 8006c88:	4d2f      	ldr	r5, [pc, #188]	; (8006d48 <mtx6_execute+0xc8>)
 8006c8a:	689e      	ldr	r6, [r3, #8]
 8006c8c:	4b2f      	ldr	r3, [pc, #188]	; (8006d4c <mtx6_execute+0xcc>)
 8006c8e:	6838      	ldr	r0, [r7, #0]
 8006c90:	4c2f      	ldr	r4, [pc, #188]	; (8006d50 <mtx6_execute+0xd0>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8006c92:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8006c94:	1c72      	adds	r2, r6, #1
 8006c96:	9300      	str	r3, [sp, #0]
 8006c98:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006c9c:	462b      	mov	r3, r5
 8006c9e:	f7fa fdaf 	bl	8001800 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8006ca2:	687b      	ldr	r3, [r7, #4]
 8006ca4:	492b      	ldr	r1, [pc, #172]	; (8006d54 <mtx6_execute+0xd4>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8006ca6:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8006ca8:	1cb2      	adds	r2, r6, #2
 8006caa:	9100      	str	r1, [sp, #0]
 8006cac:	4618      	mov	r0, r3
 8006cae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006cb2:	462b      	mov	r3, r5
 8006cb4:	f7fa fda4 	bl	8001800 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8006cb8:	68bb      	ldr	r3, [r7, #8]
 8006cba:	4927      	ldr	r1, [pc, #156]	; (8006d58 <mtx6_execute+0xd8>)

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8006cbc:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8006cbe:	1cf2      	adds	r2, r6, #3
 8006cc0:	9100      	str	r1, [sp, #0]
 8006cc2:	4618      	mov	r0, r3
 8006cc4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006cc8:	462b      	mov	r3, r5
 8006cca:	f7fa fd99 	bl	8001800 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8006cce:	68fb      	ldr	r3, [r7, #12]
 8006cd0:	4922      	ldr	r1, [pc, #136]	; (8006d5c <mtx6_execute+0xdc>)
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8006cd2:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8006cd4:	1d32      	adds	r2, r6, #4
 8006cd6:	9100      	str	r1, [sp, #0]
 8006cd8:	4618      	mov	r0, r3
 8006cda:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006cde:	462b      	mov	r3, r5
 8006ce0:	f7fa fd8e 	bl	8001800 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8006ce4:	693b      	ldr	r3, [r7, #16]
 8006ce6:	491e      	ldr	r1, [pc, #120]	; (8006d60 <mtx6_execute+0xe0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8006ce8:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8006cea:	1d72      	adds	r2, r6, #5
 8006cec:	9100      	str	r1, [sp, #0]
 8006cee:	4618      	mov	r0, r3
 8006cf0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006cf4:	462b      	mov	r3, r5
 8006cf6:	f7fa fd83 	bl	8001800 <chThdCreateStatic>
 8006cfa:	2320      	movs	r3, #32
 8006cfc:	6120      	str	r0, [r4, #16]
 8006cfe:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chCondSignalI(&c1);
 8006d02:	4c18      	ldr	r4, [pc, #96]	; (8006d64 <mtx6_execute+0xe4>)
 8006d04:	4620      	mov	r0, r4
 8006d06:	f7fb fa23 	bl	8002150 <chCondSignalI>
  chCondSignalI(&c1);
 8006d0a:	4620      	mov	r0, r4
 8006d0c:	f7fb fa20 	bl	8002150 <chCondSignalI>
  chCondSignalI(&c1);
 8006d10:	4620      	mov	r0, r4
 8006d12:	f7fb fa1d 	bl	8002150 <chCondSignalI>
  chCondSignalI(&c1);
 8006d16:	4620      	mov	r0, r4
 8006d18:	f7fb fa1a 	bl	8002150 <chCondSignalI>
  chCondSignalI(&c1);
 8006d1c:	4620      	mov	r0, r4
 8006d1e:	f7fb fa17 	bl	8002150 <chCondSignalI>
  chSchRescheduleS();
 8006d22:	f7fa fd05 	bl	8001730 <chSchRescheduleS>
 8006d26:	2300      	movs	r3, #0
 8006d28:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_wait_threads();
 8006d2c:	f7fe fed8 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006d30:	490d      	ldr	r1, [pc, #52]	; (8006d68 <mtx6_execute+0xe8>)
 8006d32:	2001      	movs	r0, #1
}
 8006d34:	b003      	add	sp, #12
 8006d36:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chCondSignalI(&c1);
  chCondSignalI(&c1);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8006d3a:	f7fe be79 	b.w	8005a30 <_test_assert_sequence>
 8006d3e:	bf00      	nop
 8006d40:	20000e78 	.word	0x20000e78
 8006d44:	0800a700 	.word	0x0800a700
 8006d48:	08006d71 	.word	0x08006d71
 8006d4c:	0800a9e0 	.word	0x0800a9e0
 8006d50:	200019f8 	.word	0x200019f8
 8006d54:	0800b864 	.word	0x0800b864
 8006d58:	0800a9d0 	.word	0x0800a9d0
 8006d5c:	0800a9d4 	.word	0x0800a9d4
 8006d60:	0800a9d8 	.word	0x0800a9d8
 8006d64:	20000834 	.word	0x20000834
 8006d68:	0800a9dc 	.word	0x0800a9dc
 8006d6c:	00000000 	.word	0x00000000

08006d70 <thread10>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 8006d70:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8006d72:	4c08      	ldr	r4, [pc, #32]	; (8006d94 <thread10+0x24>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 8006d74:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8006d76:	4620      	mov	r0, r4
 8006d78:	f7fb f91a 	bl	8001fb0 <chMtxLock>
  chCondWait(&c1);
 8006d7c:	4806      	ldr	r0, [pc, #24]	; (8006d98 <thread10+0x28>)
 8006d7e:	f7fb fa3f 	bl	8002200 <chCondWait>
  test_emit_token(*(char *)p);
 8006d82:	7828      	ldrb	r0, [r5, #0]
 8006d84:	f7fe fe2c 	bl	80059e0 <test_emit_token>
  chMtxUnlock(&m1);
 8006d88:	4620      	mov	r0, r4
}
 8006d8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
static THD_FUNCTION(thread10, p) {

  chMtxLock(&m1);
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 8006d8e:	f7fb b937 	b.w	8002000 <chMtxUnlock>
 8006d92:	bf00      	nop
 8006d94:	20000814 	.word	0x20000814
 8006d98:	20000834 	.word	0x20000834
 8006d9c:	00000000 	.word	0x00000000

08006da0 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 8006da0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8006da2:	4804      	ldr	r0, [pc, #16]	; (8006db4 <mtx7_setup+0x14>)
 8006da4:	f7fb f9b4 	bl	8002110 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8006da8:	4803      	ldr	r0, [pc, #12]	; (8006db8 <mtx7_setup+0x18>)
}
 8006daa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx7_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
 8006dae:	f7fb b88f 	b.w	8001ed0 <chMtxObjectInit>
 8006db2:	bf00      	nop
 8006db4:	20000834 	.word	0x20000834
 8006db8:	20000814 	.word	0x20000814
 8006dbc:	00000000 	.word	0x00000000

08006dc0 <mtx6_setup>:
 8006dc0:	f7ff bfee 	b.w	8006da0 <mtx7_setup>
	...

08006dd0 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 8006dd0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8006dd2:	4805      	ldr	r0, [pc, #20]	; (8006de8 <mtx8_setup+0x18>)
 8006dd4:	f7fb f99c 	bl	8002110 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8006dd8:	4804      	ldr	r0, [pc, #16]	; (8006dec <mtx8_setup+0x1c>)
 8006dda:	f7fb f879 	bl	8001ed0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8006dde:	4804      	ldr	r0, [pc, #16]	; (8006df0 <mtx8_setup+0x20>)
}
 8006de0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
 8006de4:	f7fb b874 	b.w	8001ed0 <chMtxObjectInit>
 8006de8:	20000834 	.word	0x20000834
 8006dec:	20000814 	.word	0x20000814
 8006df0:	20000824 	.word	0x20000824
	...

08006e00 <mtx7_execute>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8006e00:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006e02:	4b24      	ldr	r3, [pc, #144]	; (8006e94 <mtx7_execute+0x94>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8006e04:	4f24      	ldr	r7, [pc, #144]	; (8006e98 <mtx7_execute+0x98>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006e06:	699b      	ldr	r3, [r3, #24]
 8006e08:	4d24      	ldr	r5, [pc, #144]	; (8006e9c <mtx7_execute+0x9c>)
 8006e0a:	689e      	ldr	r6, [r3, #8]
 8006e0c:	4b24      	ldr	r3, [pc, #144]	; (8006ea0 <mtx7_execute+0xa0>)
 8006e0e:	6838      	ldr	r0, [r7, #0]
 8006e10:	4c24      	ldr	r4, [pc, #144]	; (8006ea4 <mtx7_execute+0xa4>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8006e12:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8006e14:	1c72      	adds	r2, r6, #1
 8006e16:	9300      	str	r3, [sp, #0]
 8006e18:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006e1c:	462b      	mov	r3, r5
 8006e1e:	f7fa fcef 	bl	8001800 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8006e22:	687b      	ldr	r3, [r7, #4]
 8006e24:	4920      	ldr	r1, [pc, #128]	; (8006ea8 <mtx7_execute+0xa8>)
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8006e26:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8006e28:	1cb2      	adds	r2, r6, #2
 8006e2a:	9100      	str	r1, [sp, #0]
 8006e2c:	4618      	mov	r0, r3
 8006e2e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006e32:	462b      	mov	r3, r5
 8006e34:	f7fa fce4 	bl	8001800 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8006e38:	68bb      	ldr	r3, [r7, #8]
 8006e3a:	491c      	ldr	r1, [pc, #112]	; (8006eac <mtx7_execute+0xac>)

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8006e3c:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8006e3e:	1cf2      	adds	r2, r6, #3
 8006e40:	9100      	str	r1, [sp, #0]
 8006e42:	4618      	mov	r0, r3
 8006e44:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006e48:	462b      	mov	r3, r5
 8006e4a:	f7fa fcd9 	bl	8001800 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8006e4e:	68fb      	ldr	r3, [r7, #12]
 8006e50:	4917      	ldr	r1, [pc, #92]	; (8006eb0 <mtx7_execute+0xb0>)
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8006e52:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8006e54:	1d32      	adds	r2, r6, #4
 8006e56:	9100      	str	r1, [sp, #0]
 8006e58:	4618      	mov	r0, r3
 8006e5a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006e5e:	462b      	mov	r3, r5
 8006e60:	f7fa fcce 	bl	8001800 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8006e64:	693b      	ldr	r3, [r7, #16]
 8006e66:	4913      	ldr	r1, [pc, #76]	; (8006eb4 <mtx7_execute+0xb4>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8006e68:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8006e6a:	1d72      	adds	r2, r6, #5
 8006e6c:	9100      	str	r1, [sp, #0]
 8006e6e:	4618      	mov	r0, r3
 8006e70:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006e74:	462b      	mov	r3, r5
 8006e76:	f7fa fcc3 	bl	8001800 <chThdCreateStatic>
 8006e7a:	6120      	str	r0, [r4, #16]
  chCondBroadcast(&c1);
 8006e7c:	480e      	ldr	r0, [pc, #56]	; (8006eb8 <mtx7_execute+0xb8>)
 8006e7e:	f7fb f977 	bl	8002170 <chCondBroadcast>
  test_wait_threads();
 8006e82:	f7fe fe2d 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006e86:	490d      	ldr	r1, [pc, #52]	; (8006ebc <mtx7_execute+0xbc>)
 8006e88:	2001      	movs	r0, #1
}
 8006e8a:	b003      	add	sp, #12
 8006e8c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
  chCondBroadcast(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8006e90:	f7fe bdce 	b.w	8005a30 <_test_assert_sequence>
 8006e94:	20000e78 	.word	0x20000e78
 8006e98:	0800a700 	.word	0x0800a700
 8006e9c:	08006d71 	.word	0x08006d71
 8006ea0:	0800a9e0 	.word	0x0800a9e0
 8006ea4:	200019f8 	.word	0x200019f8
 8006ea8:	0800b864 	.word	0x0800b864
 8006eac:	0800a9d0 	.word	0x0800a9d0
 8006eb0:	0800a9d4 	.word	0x0800a9d4
 8006eb4:	0800a9d8 	.word	0x0800a9d8
 8006eb8:	20000834 	.word	0x20000834
 8006ebc:	0800a9dc 	.word	0x0800a9dc

08006ec0 <mtx8_execute>:
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 8006ec0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006ec2:	4b1b      	ldr	r3, [pc, #108]	; (8006f30 <mtx8_execute+0x70>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8006ec4:	4e1b      	ldr	r6, [pc, #108]	; (8006f34 <mtx8_execute+0x74>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006ec6:	699b      	ldr	r3, [r3, #24]
 8006ec8:	6830      	ldr	r0, [r6, #0]
 8006eca:	689d      	ldr	r5, [r3, #8]
 8006ecc:	4b1a      	ldr	r3, [pc, #104]	; (8006f38 <mtx8_execute+0x78>)
 8006ece:	4c1b      	ldr	r4, [pc, #108]	; (8006f3c <mtx8_execute+0x7c>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
 8006ed0:	4f1b      	ldr	r7, [pc, #108]	; (8006f40 <mtx8_execute+0x80>)
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 8006ed2:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8006ed4:	1c6a      	adds	r2, r5, #1
 8006ed6:	9300      	str	r3, [sp, #0]
 8006ed8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006edc:	4b19      	ldr	r3, [pc, #100]	; (8006f44 <mtx8_execute+0x84>)
 8006ede:	f7fa fc8f 	bl	8001800 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8006ee2:	6871      	ldr	r1, [r6, #4]
 8006ee4:	4b18      	ldr	r3, [pc, #96]	; (8006f48 <mtx8_execute+0x88>)
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8006ee6:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8006ee8:	1caa      	adds	r2, r5, #2
 8006eea:	9300      	str	r3, [sp, #0]
 8006eec:	4608      	mov	r0, r1
 8006eee:	4b17      	ldr	r3, [pc, #92]	; (8006f4c <mtx8_execute+0x8c>)
 8006ef0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006ef4:	f7fa fc84 	bl	8001800 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8006ef8:	68b1      	ldr	r1, [r6, #8]
 8006efa:	4b15      	ldr	r3, [pc, #84]	; (8006f50 <mtx8_execute+0x90>)

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8006efc:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8006efe:	1cea      	adds	r2, r5, #3
 8006f00:	9300      	str	r3, [sp, #0]
 8006f02:	4608      	mov	r0, r1
 8006f04:	4b13      	ldr	r3, [pc, #76]	; (8006f54 <mtx8_execute+0x94>)
 8006f06:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006f0a:	f7fa fc79 	bl	8001800 <chThdCreateStatic>
 8006f0e:	60a0      	str	r0, [r4, #8]
  chCondSignal(&c1);
 8006f10:	4638      	mov	r0, r7
 8006f12:	f7fb f905 	bl	8002120 <chCondSignal>
  chCondSignal(&c1);
 8006f16:	4638      	mov	r0, r7
 8006f18:	f7fb f902 	bl	8002120 <chCondSignal>
  test_wait_threads();
 8006f1c:	f7fe fde0 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 8006f20:	490d      	ldr	r1, [pc, #52]	; (8006f58 <mtx8_execute+0x98>)
 8006f22:	2001      	movs	r0, #1
}
 8006f24:	b003      	add	sp, #12
 8006f26:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
  chCondSignal(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
 8006f2a:	f7fe bd81 	b.w	8005a30 <_test_assert_sequence>
 8006f2e:	bf00      	nop
 8006f30:	20000e78 	.word	0x20000e78
 8006f34:	0800a700 	.word	0x0800a700
 8006f38:	0800a9d8 	.word	0x0800a9d8
 8006f3c:	200019f8 	.word	0x200019f8
 8006f40:	20000834 	.word	0x20000834
 8006f44:	08006f61 	.word	0x08006f61
 8006f48:	0800a9d0 	.word	0x0800a9d0
 8006f4c:	08006d71 	.word	0x08006d71
 8006f50:	0800a9d4 	.word	0x0800a9d4
 8006f54:	080068b1 	.word	0x080068b1
 8006f58:	0800ab60 	.word	0x0800ab60
 8006f5c:	00000000 	.word	0x00000000

08006f60 <thread11>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8006f60:	b570      	push	{r4, r5, r6, lr}

  chMtxLock(&m2);
 8006f62:	4c0c      	ldr	r4, [pc, #48]	; (8006f94 <thread11+0x34>)
  chMtxLock(&m1);
 8006f64:	4d0c      	ldr	r5, [pc, #48]	; (8006f98 <thread11+0x38>)
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8006f66:	4606      	mov	r6, r0

  chMtxLock(&m2);
 8006f68:	4620      	mov	r0, r4
 8006f6a:	f7fb f821 	bl	8001fb0 <chMtxLock>
  chMtxLock(&m1);
 8006f6e:	4628      	mov	r0, r5
 8006f70:	f7fb f81e 	bl	8001fb0 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8006f74:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006f78:	4808      	ldr	r0, [pc, #32]	; (8006f9c <thread11+0x3c>)
 8006f7a:	f7fb f979 	bl	8002270 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8006f7e:	7830      	ldrb	r0, [r6, #0]
 8006f80:	f7fe fd2e 	bl	80059e0 <test_emit_token>
  chMtxUnlock(&m1);
 8006f84:	4628      	mov	r0, r5
 8006f86:	f7fb f83b 	bl	8002000 <chMtxUnlock>
  chMtxUnlock(&m2);
 8006f8a:	4620      	mov	r0, r4
}
 8006f8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
 8006f90:	f7fb b836 	b.w	8002000 <chMtxUnlock>
 8006f94:	20000824 	.word	0x20000824
 8006f98:	20000814 	.word	0x20000814
 8006f9c:	20000834 	.word	0x20000834

08006fa0 <msg1_execute>:
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 8006fa0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006fa2:	4a18      	ldr	r2, [pc, #96]	; (8007004 <msg1_execute+0x64>)
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8006fa4:	4b18      	ldr	r3, [pc, #96]	; (8007008 <msg1_execute+0x68>)
 8006fa6:	6991      	ldr	r1, [r2, #24]
 8006fa8:	6818      	ldr	r0, [r3, #0]
 8006faa:	688a      	ldr	r2, [r1, #8]
 8006fac:	4b17      	ldr	r3, [pc, #92]	; (800700c <msg1_execute+0x6c>)
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 8006fae:	b082      	sub	sp, #8
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8006fb0:	3201      	adds	r2, #1
 8006fb2:	9100      	str	r1, [sp, #0]
 8006fb4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006fb8:	f7fa fc22 	bl	8001800 <chThdCreateStatic>
 8006fbc:	4b14      	ldr	r3, [pc, #80]	; (8007010 <msg1_execute+0x70>)
 8006fbe:	6018      	str	r0, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 8006fc0:	f7fb fb1e 	bl	8002600 <chMsgWait>
 8006fc4:	6b04      	ldr	r4, [r0, #48]	; 0x30
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8006fc6:	4621      	mov	r1, r4
 8006fc8:	f7fb fb3a 	bl	8002640 <chMsgRelease>
  test_emit_token(msg);
 8006fcc:	b2e0      	uxtb	r0, r4
 8006fce:	f7fe fd07 	bl	80059e0 <test_emit_token>
  tp = chMsgWait();
 8006fd2:	f7fb fb15 	bl	8002600 <chMsgWait>
 8006fd6:	6b04      	ldr	r4, [r0, #48]	; 0x30
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8006fd8:	4621      	mov	r1, r4
 8006fda:	f7fb fb31 	bl	8002640 <chMsgRelease>
  test_emit_token(msg);
 8006fde:	b2e0      	uxtb	r0, r4
 8006fe0:	f7fe fcfe 	bl	80059e0 <test_emit_token>
  tp = chMsgWait();
 8006fe4:	f7fb fb0c 	bl	8002600 <chMsgWait>
 8006fe8:	6b04      	ldr	r4, [r0, #48]	; 0x30
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 8006fea:	4621      	mov	r1, r4
 8006fec:	f7fb fb28 	bl	8002640 <chMsgRelease>
  test_emit_token(msg);
 8006ff0:	b2e0      	uxtb	r0, r4
 8006ff2:	f7fe fcf5 	bl	80059e0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 8006ff6:	4907      	ldr	r1, [pc, #28]	; (8007014 <msg1_execute+0x74>)
 8006ff8:	2001      	movs	r0, #1
}
 8006ffa:	b002      	add	sp, #8
 8006ffc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  test_assert_sequence(1, "ABC");
 8007000:	f7fe bd16 	b.w	8005a30 <_test_assert_sequence>
 8007004:	20000e78 	.word	0x20000e78
 8007008:	0800a700 	.word	0x0800a700
 800700c:	08007021 	.word	0x08007021
 8007010:	200019f8 	.word	0x200019f8
 8007014:	0800ab60 	.word	0x0800ab60
	...

08007020 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8007020:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8007022:	2141      	movs	r1, #65	; 0x41
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8007024:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 8007026:	f7fb facb 	bl	80025c0 <chMsgSend>
  chMsgSend(p, 'B');
 800702a:	4620      	mov	r0, r4
 800702c:	2142      	movs	r1, #66	; 0x42
 800702e:	f7fb fac7 	bl	80025c0 <chMsgSend>
  chMsgSend(p, 'C');
 8007032:	4620      	mov	r0, r4
 8007034:	2143      	movs	r1, #67	; 0x43
}
 8007036:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread, p) {

  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
 800703a:	f7fb bac1 	b.w	80025c0 <chMsgSend>
 800703e:	bf00      	nop

08007040 <mbox1_execute>:
static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}

static void mbox1_execute(void) {
 8007040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007044:	2320      	movs	r3, #32
 8007046:	b082      	sub	sp, #8
 8007048:	f383 8811 	msr	BASEPRI, r3
 800704c:	4ecb      	ldr	r6, [pc, #812]	; (800737c <mbox1_execute+0x33c>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800704e:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8007050:	f1a1 0105 	sub.w	r1, r1, #5
 8007054:	fab1 f181 	clz	r1, r1
 8007058:	2001      	movs	r0, #1
 800705a:	0949      	lsrs	r1, r1, #5
 800705c:	f7fe fcd0 	bl	8005a00 <_test_assert>
 8007060:	2800      	cmp	r0, #0
 8007062:	f040 8118 	bne.w	8007296 <mbox1_execute+0x256>
 8007066:	f380 8811 	msr	BASEPRI, r0
 800706a:	2442      	movs	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800706c:	4dc3      	ldr	r5, [pc, #780]	; (800737c <mbox1_execute+0x33c>)
 800706e:	4621      	mov	r1, r4
 8007070:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007074:	4628      	mov	r0, r5
 8007076:	f7fb fb33 	bl	80026e0 <chMBPost>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800707a:	fab0 f180 	clz	r1, r0
 800707e:	0949      	lsrs	r1, r1, #5
 8007080:	2002      	movs	r0, #2
 8007082:	f7fe fcbd 	bl	8005a00 <_test_assert>
 8007086:	3401      	adds	r4, #1
 8007088:	b980      	cbnz	r0, 80070ac <mbox1_execute+0x6c>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800708a:	2c46      	cmp	r4, #70	; 0x46
 800708c:	d1ee      	bne.n	800706c <mbox1_execute+0x2c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800708e:	2141      	movs	r1, #65	; 0x41
 8007090:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007094:	4628      	mov	r0, r5
 8007096:	f7fb fb6b 	bl	8002770 <chMBPostAhead>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800709a:	fab0 f180 	clz	r1, r0
 800709e:	0949      	lsrs	r1, r1, #5
 80070a0:	2003      	movs	r0, #3
 80070a2:	f7fe fcad 	bl	8005a00 <_test_assert>
 80070a6:	2800      	cmp	r0, #0
 80070a8:	f000 80fb 	beq.w	80072a2 <mbox1_execute+0x262>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 80070ac:	b002      	add	sp, #8
 80070ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80070b2:	f385 8811 	msr	BASEPRI, r5
 80070b6:	f387 8811 	msr	BASEPRI, r7
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 80070ba:	69a1      	ldr	r1, [r4, #24]
 80070bc:	fab1 f181 	clz	r1, r1
 80070c0:	0949      	lsrs	r1, r1, #5
 80070c2:	201f      	movs	r0, #31
 80070c4:	f7fe fc9c 	bl	8005a00 <_test_assert>
 80070c8:	2800      	cmp	r0, #0
 80070ca:	f040 829c 	bne.w	8007606 <mbox1_execute+0x5c6>
 80070ce:	f385 8811 	msr	BASEPRI, r5
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80070d2:	68e1      	ldr	r1, [r4, #12]
 80070d4:	68a3      	ldr	r3, [r4, #8]
 80070d6:	1acb      	subs	r3, r1, r3
 80070d8:	4259      	negs	r1, r3
 80070da:	4159      	adcs	r1, r3
 80070dc:	4638      	mov	r0, r7
 80070de:	f7fe fc8f 	bl	8005a00 <_test_assert>
 80070e2:	2800      	cmp	r0, #0
 80070e4:	d1e2      	bne.n	80070ac <mbox1_execute+0x6c>
 80070e6:	f387 8811 	msr	BASEPRI, r7

  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'E');
 80070ea:	2145      	movs	r1, #69	; 0x45
 80070ec:	4620      	mov	r0, r4
 80070ee:	f7fb fb67 	bl	80027c0 <chMBPostAheadI>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 80070f2:	fab0 f180 	clz	r1, r0
 80070f6:	0949      	lsrs	r1, r1, #5
 80070f8:	2021      	movs	r0, #33	; 0x21
 80070fa:	f7fe fc81 	bl	8005a00 <_test_assert>
 80070fe:	2800      	cmp	r0, #0
 8007100:	d1d4      	bne.n	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8007102:	2144      	movs	r1, #68	; 0x44
 8007104:	4620      	mov	r0, r4
 8007106:	f7fb fb5b 	bl	80027c0 <chMBPostAheadI>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800710a:	fab0 f180 	clz	r1, r0
 800710e:	0949      	lsrs	r1, r1, #5
 8007110:	2022      	movs	r0, #34	; 0x22
 8007112:	f7fe fc75 	bl	8005a00 <_test_assert>
 8007116:	2800      	cmp	r0, #0
 8007118:	d1c8      	bne.n	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800711a:	2143      	movs	r1, #67	; 0x43
 800711c:	4620      	mov	r0, r4
 800711e:	f7fb fb4f 	bl	80027c0 <chMBPostAheadI>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 8007122:	fab0 f180 	clz	r1, r0
 8007126:	0949      	lsrs	r1, r1, #5
 8007128:	2023      	movs	r0, #35	; 0x23
 800712a:	f7fe fc69 	bl	8005a00 <_test_assert>
 800712e:	2800      	cmp	r0, #0
 8007130:	d1bc      	bne.n	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'B');
 8007132:	2142      	movs	r1, #66	; 0x42
 8007134:	4620      	mov	r0, r4
 8007136:	f7fb fb43 	bl	80027c0 <chMBPostAheadI>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 800713a:	fab0 f180 	clz	r1, r0
 800713e:	0949      	lsrs	r1, r1, #5
 8007140:	2024      	movs	r0, #36	; 0x24
 8007142:	f7fe fc5d 	bl	8005a00 <_test_assert>
 8007146:	2800      	cmp	r0, #0
 8007148:	d1b0      	bne.n	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'A');
 800714a:	4c8c      	ldr	r4, [pc, #560]	; (800737c <mbox1_execute+0x33c>)
 800714c:	2141      	movs	r1, #65	; 0x41
 800714e:	4620      	mov	r0, r4
 8007150:	f7fb fb36 	bl	80027c0 <chMBPostAheadI>
 8007154:	2300      	movs	r3, #0
 8007156:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 800715a:	fab0 f180 	clz	r1, r0
 800715e:	0949      	lsrs	r1, r1, #5
 8007160:	2025      	movs	r0, #37	; 0x25
 8007162:	f7fe fc4d 	bl	8005a00 <_test_assert>
 8007166:	2800      	cmp	r0, #0
 8007168:	d1a0      	bne.n	80070ac <mbox1_execute+0x6c>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800716a:	68e1      	ldr	r1, [r4, #12]
 800716c:	68a3      	ldr	r3, [r4, #8]
 800716e:	ebc3 0801 	rsb	r8, r3, r1
 8007172:	f1d8 0100 	rsbs	r1, r8, #0
 8007176:	eb41 0108 	adc.w	r1, r1, r8
 800717a:	2026      	movs	r0, #38	; 0x26
 800717c:	f7fe fc40 	bl	8005a00 <_test_assert>
 8007180:	2800      	cmp	r0, #0
 8007182:	d193      	bne.n	80070ac <mbox1_execute+0x6c>
 8007184:	4607      	mov	r7, r0
 8007186:	2405      	movs	r4, #5
 8007188:	f04f 0820 	mov.w	r8, #32
 800718c:	2620      	movs	r6, #32
 800718e:	f388 8811 	msr	BASEPRI, r8
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8007192:	4d7a      	ldr	r5, [pc, #488]	; (800737c <mbox1_execute+0x33c>)
 8007194:	a901      	add	r1, sp, #4
 8007196:	4628      	mov	r0, r5
 8007198:	f7fb fb52 	bl	8002840 <chMBFetchI>
 800719c:	f387 8811 	msr	BASEPRI, r7
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 80071a0:	fab0 f180 	clz	r1, r0
 80071a4:	0949      	lsrs	r1, r1, #5
 80071a6:	2027      	movs	r0, #39	; 0x27
 80071a8:	f7fe fc2a 	bl	8005a00 <_test_assert>
 80071ac:	2800      	cmp	r0, #0
 80071ae:	f47f af7d 	bne.w	80070ac <mbox1_execute+0x6c>
    test_emit_token(msg2);
 80071b2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80071b6:	f7fe fc13 	bl	80059e0 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 80071ba:	3c01      	subs	r4, #1
 80071bc:	d1e6      	bne.n	800718c <mbox1_execute+0x14c>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 80071be:	4970      	ldr	r1, [pc, #448]	; (8007380 <mbox1_execute+0x340>)
 80071c0:	2028      	movs	r0, #40	; 0x28
 80071c2:	f7fe fc35 	bl	8005a30 <_test_assert_sequence>
 80071c6:	2800      	cmp	r0, #0
 80071c8:	f47f af70 	bne.w	80070ac <mbox1_execute+0x6c>
 80071cc:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80071d0:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80071d2:	f1a1 0c05 	sub.w	ip, r1, #5
 80071d6:	f1dc 0100 	rsbs	r1, ip, #0
 80071da:	eb41 010c 	adc.w	r1, r1, ip
 80071de:	2029      	movs	r0, #41	; 0x29
 80071e0:	f7fe fc0e 	bl	8005a00 <_test_assert>
 80071e4:	2800      	cmp	r0, #0
 80071e6:	f040 80c5 	bne.w	8007374 <mbox1_execute+0x334>
 80071ea:	f384 8811 	msr	BASEPRI, r4
 80071ee:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 80071f2:	69a9      	ldr	r1, [r5, #24]
 80071f4:	fab1 f181 	clz	r1, r1
 80071f8:	0949      	lsrs	r1, r1, #5
 80071fa:	202a      	movs	r0, #42	; 0x2a
 80071fc:	f7fe fc00 	bl	8005a00 <_test_assert>
 8007200:	2800      	cmp	r0, #0
 8007202:	f040 80b7 	bne.w	8007374 <mbox1_execute+0x334>
 8007206:	f384 8811 	msr	BASEPRI, r4
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800720a:	68e9      	ldr	r1, [r5, #12]
 800720c:	68ab      	ldr	r3, [r5, #8]
 800720e:	ebc3 0e01 	rsb	lr, r3, r1
 8007212:	f1de 0100 	rsbs	r1, lr, #0
 8007216:	eb41 010e 	adc.w	r1, r1, lr
 800721a:	202b      	movs	r0, #43	; 0x2b
 800721c:	f7fe fbf0 	bl	8005a00 <_test_assert>
 8007220:	2800      	cmp	r0, #0
 8007222:	f47f af43 	bne.w	80070ac <mbox1_execute+0x6c>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 8007226:	4628      	mov	r0, r5
 8007228:	f7fb fa4a 	bl	80026c0 <chMBReset>
 800722c:	f386 8811 	msr	BASEPRI, r6

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8007230:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8007232:	1f4f      	subs	r7, r1, #5
 8007234:	4279      	negs	r1, r7
 8007236:	4179      	adcs	r1, r7
 8007238:	202c      	movs	r0, #44	; 0x2c
 800723a:	f7fe fbe1 	bl	8005a00 <_test_assert>
 800723e:	2800      	cmp	r0, #0
 8007240:	f040 8098 	bne.w	8007374 <mbox1_execute+0x334>
 8007244:	f384 8811 	msr	BASEPRI, r4
 8007248:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800724c:	69a9      	ldr	r1, [r5, #24]
 800724e:	fab1 f181 	clz	r1, r1
 8007252:	0949      	lsrs	r1, r1, #5
 8007254:	202d      	movs	r0, #45	; 0x2d
 8007256:	f7fe fbd3 	bl	8005a00 <_test_assert>
 800725a:	2800      	cmp	r0, #0
 800725c:	f040 808a 	bne.w	8007374 <mbox1_execute+0x334>
 8007260:	f384 8811 	msr	BASEPRI, r4
 8007264:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8007268:	6829      	ldr	r1, [r5, #0]
 800726a:	68ab      	ldr	r3, [r5, #8]
 800726c:	1aca      	subs	r2, r1, r3
 800726e:	4251      	negs	r1, r2
 8007270:	4151      	adcs	r1, r2
 8007272:	202e      	movs	r0, #46	; 0x2e
 8007274:	f7fe fbc4 	bl	8005a00 <_test_assert>
 8007278:	2800      	cmp	r0, #0
 800727a:	d17b      	bne.n	8007374 <mbox1_execute+0x334>
 800727c:	f384 8811 	msr	BASEPRI, r4
 8007280:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8007284:	6829      	ldr	r1, [r5, #0]
 8007286:	68eb      	ldr	r3, [r5, #12]
 8007288:	1acb      	subs	r3, r1, r3
 800728a:	4259      	negs	r1, r3
 800728c:	f04f 002f 	mov.w	r0, #47	; 0x2f
 8007290:	4159      	adcs	r1, r3
 8007292:	f7fe fbb5 	bl	8005a00 <_test_assert>
 8007296:	2300      	movs	r3, #0
 8007298:	f383 8811 	msr	BASEPRI, r3
}
 800729c:	b002      	add	sp, #8
 800729e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 80072a2:	2201      	movs	r2, #1
 80072a4:	2158      	movs	r1, #88	; 0x58
 80072a6:	4628      	mov	r0, r5
 80072a8:	f7fb fa1a 	bl	80026e0 <chMBPost>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80072ac:	f1a0 31ff 	sub.w	r1, r0, #4294967295	; 0xffffffff
 80072b0:	fab1 f181 	clz	r1, r1
 80072b4:	0949      	lsrs	r1, r1, #5
 80072b6:	2004      	movs	r0, #4
 80072b8:	f7fe fba2 	bl	8005a00 <_test_assert>
 80072bc:	4604      	mov	r4, r0
 80072be:	2800      	cmp	r0, #0
 80072c0:	f47f aef4 	bne.w	80070ac <mbox1_execute+0x6c>
 80072c4:	2720      	movs	r7, #32
 80072c6:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 80072ca:	2158      	movs	r1, #88	; 0x58
 80072cc:	4628      	mov	r0, r5
 80072ce:	f7fb fa2f 	bl	8002730 <chMBPostI>
 80072d2:	4601      	mov	r1, r0
 80072d4:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80072d8:	f1a1 31ff 	sub.w	r1, r1, #4294967295	; 0xffffffff
 80072dc:	fab1 f181 	clz	r1, r1
 80072e0:	2005      	movs	r0, #5
 80072e2:	0949      	lsrs	r1, r1, #5
 80072e4:	f7fe fb8c 	bl	8005a00 <_test_assert>
 80072e8:	2800      	cmp	r0, #0
 80072ea:	f47f aedf 	bne.w	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 80072ee:	2201      	movs	r2, #1
 80072f0:	2158      	movs	r1, #88	; 0x58
 80072f2:	4628      	mov	r0, r5
 80072f4:	f7fb fa3c 	bl	8002770 <chMBPostAhead>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80072f8:	f1a0 31ff 	sub.w	r1, r0, #4294967295	; 0xffffffff
 80072fc:	fab1 f181 	clz	r1, r1
 8007300:	0949      	lsrs	r1, r1, #5
 8007302:	2006      	movs	r0, #6
 8007304:	f7fe fb7c 	bl	8005a00 <_test_assert>
 8007308:	4604      	mov	r4, r0
 800730a:	2800      	cmp	r0, #0
 800730c:	f47f aece 	bne.w	80070ac <mbox1_execute+0x6c>
 8007310:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 8007314:	2158      	movs	r1, #88	; 0x58
 8007316:	4628      	mov	r0, r5
 8007318:	f7fb fa52 	bl	80027c0 <chMBPostAheadI>
 800731c:	4601      	mov	r1, r0
 800731e:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8007322:	f1a1 31ff 	sub.w	r1, r1, #4294967295	; 0xffffffff
 8007326:	fab1 f181 	clz	r1, r1
 800732a:	2007      	movs	r0, #7
 800732c:	0949      	lsrs	r1, r1, #5
 800732e:	f7fe fb67 	bl	8005a00 <_test_assert>
 8007332:	4680      	mov	r8, r0
 8007334:	2800      	cmp	r0, #0
 8007336:	f47f aeb9 	bne.w	80070ac <mbox1_execute+0x6c>
 800733a:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800733e:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8007340:	fab1 f181 	clz	r1, r1
 8007344:	0949      	lsrs	r1, r1, #5
 8007346:	2008      	movs	r0, #8
 8007348:	f7fe fb5a 	bl	8005a00 <_test_assert>
 800734c:	4604      	mov	r4, r0
 800734e:	b110      	cbz	r0, 8007356 <mbox1_execute+0x316>
 8007350:	f388 8811 	msr	BASEPRI, r8
 8007354:	e6aa      	b.n	80070ac <mbox1_execute+0x6c>
 8007356:	f380 8811 	msr	BASEPRI, r0
 800735a:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800735e:	69a9      	ldr	r1, [r5, #24]
 8007360:	f1a1 0e05 	sub.w	lr, r1, #5
 8007364:	f1de 0100 	rsbs	r1, lr, #0
 8007368:	eb41 010e 	adc.w	r1, r1, lr
 800736c:	2009      	movs	r0, #9
 800736e:	f7fe fb47 	bl	8005a00 <_test_assert>
 8007372:	b138      	cbz	r0, 8007384 <mbox1_execute+0x344>
 8007374:	f384 8811 	msr	BASEPRI, r4
 8007378:	e698      	b.n	80070ac <mbox1_execute+0x6c>
 800737a:	bf00      	nop
 800737c:	2000083c 	.word	0x2000083c
 8007380:	0800a9dc 	.word	0x0800a9dc
 8007384:	f380 8811 	msr	BASEPRI, r0
 8007388:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800738c:	68e9      	ldr	r1, [r5, #12]
 800738e:	68ab      	ldr	r3, [r5, #8]
 8007390:	1acc      	subs	r4, r1, r3
 8007392:	4261      	negs	r1, r4
 8007394:	f04f 000a 	mov.w	r0, #10
 8007398:	4161      	adcs	r1, r4
 800739a:	f7fe fb31 	bl	8005a00 <_test_assert>
 800739e:	2300      	movs	r3, #0
 80073a0:	2800      	cmp	r0, #0
 80073a2:	f47f af79 	bne.w	8007298 <mbox1_execute+0x258>
 80073a6:	f383 8811 	msr	BASEPRI, r3
 80073aa:	2505      	movs	r5, #5
 80073ac:	e005      	b.n	80073ba <mbox1_execute+0x37a>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 80073ae:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80073b2:	f7fe fb15 	bl	80059e0 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 80073b6:	3d01      	subs	r5, #1
 80073b8:	d00f      	beq.n	80073da <mbox1_execute+0x39a>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80073ba:	4c94      	ldr	r4, [pc, #592]	; (800760c <mbox1_execute+0x5cc>)
 80073bc:	a901      	add	r1, sp, #4
 80073be:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80073c2:	4620      	mov	r0, r4
 80073c4:	f7fb fa14 	bl	80027f0 <chMBFetch>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 80073c8:	fab0 f180 	clz	r1, r0
 80073cc:	0949      	lsrs	r1, r1, #5
 80073ce:	200b      	movs	r0, #11
 80073d0:	f7fe fb16 	bl	8005a00 <_test_assert>
 80073d4:	2800      	cmp	r0, #0
 80073d6:	d0ea      	beq.n	80073ae <mbox1_execute+0x36e>
 80073d8:	e668      	b.n	80070ac <mbox1_execute+0x6c>
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 80073da:	498d      	ldr	r1, [pc, #564]	; (8007610 <mbox1_execute+0x5d0>)
 80073dc:	200c      	movs	r0, #12
 80073de:	f7fe fb27 	bl	8005a30 <_test_assert_sequence>
 80073e2:	2800      	cmp	r0, #0
 80073e4:	f47f ae62 	bne.w	80070ac <mbox1_execute+0x6c>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80073e8:	2147      	movs	r1, #71	; 0x47
 80073ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80073ee:	4620      	mov	r0, r4
 80073f0:	f7fb f976 	bl	80026e0 <chMBPost>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 80073f4:	fab0 f180 	clz	r1, r0
 80073f8:	0949      	lsrs	r1, r1, #5
 80073fa:	200d      	movs	r0, #13
 80073fc:	f7fe fb00 	bl	8005a00 <_test_assert>
 8007400:	2800      	cmp	r0, #0
 8007402:	f47f ae53 	bne.w	80070ac <mbox1_execute+0x6c>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8007406:	a901      	add	r1, sp, #4
 8007408:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800740c:	4620      	mov	r0, r4
 800740e:	f7fb f9ef 	bl	80027f0 <chMBFetch>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 8007412:	fab0 f180 	clz	r1, r0
 8007416:	0949      	lsrs	r1, r1, #5
 8007418:	200e      	movs	r0, #14
 800741a:	f7fe faf1 	bl	8005a00 <_test_assert>
 800741e:	2800      	cmp	r0, #0
 8007420:	f47f ae44 	bne.w	80070ac <mbox1_execute+0x6c>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8007424:	6821      	ldr	r1, [r4, #0]
 8007426:	68a3      	ldr	r3, [r4, #8]
 8007428:	1aca      	subs	r2, r1, r3
 800742a:	4251      	negs	r1, r2
 800742c:	4151      	adcs	r1, r2
 800742e:	200f      	movs	r0, #15
 8007430:	f7fe fae6 	bl	8005a00 <_test_assert>
 8007434:	2800      	cmp	r0, #0
 8007436:	f47f ae39 	bne.w	80070ac <mbox1_execute+0x6c>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800743a:	6821      	ldr	r1, [r4, #0]
 800743c:	68e3      	ldr	r3, [r4, #12]
 800743e:	1acb      	subs	r3, r1, r3
 8007440:	4259      	negs	r1, r3
 8007442:	4159      	adcs	r1, r3
 8007444:	2010      	movs	r0, #16
 8007446:	f7fe fadb 	bl	8005a00 <_test_assert>
 800744a:	2800      	cmp	r0, #0
 800744c:	f47f ae2e 	bne.w	80070ac <mbox1_execute+0x6c>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 8007450:	a901      	add	r1, sp, #4
 8007452:	2201      	movs	r2, #1
 8007454:	4620      	mov	r0, r4
 8007456:	f7fb f9cb 	bl	80027f0 <chMBFetch>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800745a:	f100 0801 	add.w	r8, r0, #1
 800745e:	f1d8 0100 	rsbs	r1, r8, #0
 8007462:	eb41 0108 	adc.w	r1, r1, r8
 8007466:	2011      	movs	r0, #17
 8007468:	f7fe faca 	bl	8005a00 <_test_assert>
 800746c:	2800      	cmp	r0, #0
 800746e:	f47f ae1d 	bne.w	80070ac <mbox1_execute+0x6c>
 8007472:	2720      	movs	r7, #32
 8007474:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
 8007478:	a901      	add	r1, sp, #4
 800747a:	4620      	mov	r0, r4
 800747c:	f7fb f9e0 	bl	8002840 <chMBFetchI>
 8007480:	4601      	mov	r1, r0
 8007482:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8007486:	f101 0c01 	add.w	ip, r1, #1
 800748a:	f1dc 0100 	rsbs	r1, ip, #0
 800748e:	eb41 010c 	adc.w	r1, r1, ip
 8007492:	2012      	movs	r0, #18
 8007494:	f7fe fab4 	bl	8005a00 <_test_assert>
 8007498:	2800      	cmp	r0, #0
 800749a:	f47f ae07 	bne.w	80070ac <mbox1_execute+0x6c>
 800749e:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80074a2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80074a4:	f1a1 0e05 	sub.w	lr, r1, #5
 80074a8:	f1de 0100 	rsbs	r1, lr, #0
 80074ac:	eb41 010e 	adc.w	r1, r1, lr
 80074b0:	2013      	movs	r0, #19
 80074b2:	f7fe faa5 	bl	8005a00 <_test_assert>
 80074b6:	2800      	cmp	r0, #0
 80074b8:	f47f aeed 	bne.w	8007296 <mbox1_execute+0x256>
 80074bc:	2700      	movs	r7, #0
 80074be:	f387 8811 	msr	BASEPRI, r7
 80074c2:	2520      	movs	r5, #32
 80074c4:	f385 8811 	msr	BASEPRI, r5
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 80074c8:	69b1      	ldr	r1, [r6, #24]
 80074ca:	4c50      	ldr	r4, [pc, #320]	; (800760c <mbox1_execute+0x5cc>)
 80074cc:	fab1 f181 	clz	r1, r1
 80074d0:	0949      	lsrs	r1, r1, #5
 80074d2:	2014      	movs	r0, #20
 80074d4:	f7fe fa94 	bl	8005a00 <_test_assert>
 80074d8:	4606      	mov	r6, r0
 80074da:	b110      	cbz	r0, 80074e2 <mbox1_execute+0x4a2>
 80074dc:	f387 8811 	msr	BASEPRI, r7
 80074e0:	e5e4      	b.n	80070ac <mbox1_execute+0x6c>
 80074e2:	f380 8811 	msr	BASEPRI, r0
 80074e6:	f385 8811 	msr	BASEPRI, r5
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80074ea:	68e1      	ldr	r1, [r4, #12]
 80074ec:	68a3      	ldr	r3, [r4, #8]
 80074ee:	1acf      	subs	r7, r1, r3
 80074f0:	4279      	negs	r1, r7
 80074f2:	4179      	adcs	r1, r7
 80074f4:	2015      	movs	r0, #21
 80074f6:	f7fe fa83 	bl	8005a00 <_test_assert>
 80074fa:	b110      	cbz	r0, 8007502 <mbox1_execute+0x4c2>
 80074fc:	f386 8811 	msr	BASEPRI, r6
 8007500:	e5d4      	b.n	80070ac <mbox1_execute+0x6c>
 8007502:	f380 8811 	msr	BASEPRI, r0
 8007506:	f385 8811 	msr	BASEPRI, r5

  /*
   * Testing I-Class.
   */
  chSysLock();
  msg1 = chMBPostI(&mb1, 'A');
 800750a:	2141      	movs	r1, #65	; 0x41
 800750c:	4620      	mov	r0, r4
 800750e:	f7fb f90f 	bl	8002730 <chMBPostI>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 8007512:	fab0 f180 	clz	r1, r0
 8007516:	0949      	lsrs	r1, r1, #5
 8007518:	2016      	movs	r0, #22
 800751a:	f7fe fa71 	bl	8005a00 <_test_assert>
 800751e:	2800      	cmp	r0, #0
 8007520:	f47f adc4 	bne.w	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'B');
 8007524:	2142      	movs	r1, #66	; 0x42
 8007526:	4620      	mov	r0, r4
 8007528:	f7fb f902 	bl	8002730 <chMBPostI>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 800752c:	fab0 f180 	clz	r1, r0
 8007530:	0949      	lsrs	r1, r1, #5
 8007532:	2017      	movs	r0, #23
 8007534:	f7fe fa64 	bl	8005a00 <_test_assert>
 8007538:	2800      	cmp	r0, #0
 800753a:	f47f adb7 	bne.w	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'C');
 800753e:	2143      	movs	r1, #67	; 0x43
 8007540:	4620      	mov	r0, r4
 8007542:	f7fb f8f5 	bl	8002730 <chMBPostI>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 8007546:	fab0 f180 	clz	r1, r0
 800754a:	0949      	lsrs	r1, r1, #5
 800754c:	2018      	movs	r0, #24
 800754e:	f7fe fa57 	bl	8005a00 <_test_assert>
 8007552:	2800      	cmp	r0, #0
 8007554:	f47f adaa 	bne.w	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'D');
 8007558:	2144      	movs	r1, #68	; 0x44
 800755a:	4620      	mov	r0, r4
 800755c:	f7fb f8e8 	bl	8002730 <chMBPostI>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 8007560:	fab0 f180 	clz	r1, r0
 8007564:	0949      	lsrs	r1, r1, #5
 8007566:	2019      	movs	r0, #25
 8007568:	f7fe fa4a 	bl	8005a00 <_test_assert>
 800756c:	4606      	mov	r6, r0
 800756e:	2800      	cmp	r0, #0
 8007570:	f47f ad9c 	bne.w	80070ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'E');
 8007574:	2145      	movs	r1, #69	; 0x45
 8007576:	4620      	mov	r0, r4
 8007578:	f7fb f8da 	bl	8002730 <chMBPostI>
 800757c:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 8007580:	fab0 f180 	clz	r1, r0
 8007584:	0949      	lsrs	r1, r1, #5
 8007586:	201a      	movs	r0, #26
 8007588:	f7fe fa3a 	bl	8005a00 <_test_assert>
 800758c:	2800      	cmp	r0, #0
 800758e:	f47f ad8d 	bne.w	80070ac <mbox1_execute+0x6c>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8007592:	68e1      	ldr	r1, [r4, #12]
 8007594:	68a3      	ldr	r3, [r4, #8]
 8007596:	1acc      	subs	r4, r1, r3
 8007598:	4261      	negs	r1, r4
 800759a:	4161      	adcs	r1, r4
 800759c:	201b      	movs	r0, #27
 800759e:	f7fe fa2f 	bl	8005a00 <_test_assert>
 80075a2:	2800      	cmp	r0, #0
 80075a4:	f47f ad82 	bne.w	80070ac <mbox1_execute+0x6c>
 80075a8:	462e      	mov	r6, r5
 80075aa:	4680      	mov	r8, r0
 80075ac:	2505      	movs	r5, #5
 80075ae:	2720      	movs	r7, #32
 80075b0:	f386 8811 	msr	BASEPRI, r6
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 80075b4:	4c15      	ldr	r4, [pc, #84]	; (800760c <mbox1_execute+0x5cc>)
 80075b6:	a901      	add	r1, sp, #4
 80075b8:	4620      	mov	r0, r4
 80075ba:	f7fb f941 	bl	8002840 <chMBFetchI>
 80075be:	f388 8811 	msr	BASEPRI, r8
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 80075c2:	fab0 f180 	clz	r1, r0
 80075c6:	0949      	lsrs	r1, r1, #5
 80075c8:	201c      	movs	r0, #28
 80075ca:	f7fe fa19 	bl	8005a00 <_test_assert>
 80075ce:	2800      	cmp	r0, #0
 80075d0:	f47f ad6c 	bne.w	80070ac <mbox1_execute+0x6c>
    test_emit_token(msg2);
 80075d4:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80075d8:	f7fe fa02 	bl	80059e0 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 80075dc:	3d01      	subs	r5, #1
 80075de:	d1e6      	bne.n	80075ae <mbox1_execute+0x56e>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 80075e0:	490b      	ldr	r1, [pc, #44]	; (8007610 <mbox1_execute+0x5d0>)
 80075e2:	201d      	movs	r0, #29
 80075e4:	f7fe fa24 	bl	8005a30 <_test_assert_sequence>
 80075e8:	2800      	cmp	r0, #0
 80075ea:	f47f ad5f 	bne.w	80070ac <mbox1_execute+0x6c>
 80075ee:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80075f2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80075f4:	1f4a      	subs	r2, r1, #5
 80075f6:	4251      	negs	r1, r2
 80075f8:	4151      	adcs	r1, r2
 80075fa:	201e      	movs	r0, #30
 80075fc:	f7fe fa00 	bl	8005a00 <_test_assert>
 8007600:	2800      	cmp	r0, #0
 8007602:	f43f ad56 	beq.w	80070b2 <mbox1_execute+0x72>
 8007606:	f385 8811 	msr	BASEPRI, r5
 800760a:	e54f      	b.n	80070ac <mbox1_execute+0x6c>
 800760c:	2000083c 	.word	0x2000083c
 8007610:	0800a9dc 	.word	0x0800a9dc
	...

08007620 <mbox1_setup>:
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 8007620:	2205      	movs	r2, #5
 8007622:	4902      	ldr	r1, [pc, #8]	; (800762c <mbox1_setup+0xc>)
 8007624:	4802      	ldr	r0, [pc, #8]	; (8007630 <mbox1_setup+0x10>)
 8007626:	f7fb b81b 	b.w	8002660 <chMBObjectInit>
 800762a:	bf00      	nop
 800762c:	20001370 	.word	0x20001370
 8007630:	2000083c 	.word	0x2000083c
	...

08007640 <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8007640:	2043      	movs	r0, #67	; 0x43
 8007642:	f7fe b9cd 	b.w	80059e0 <test_emit_token>
 8007646:	bf00      	nop
	...

08007650 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8007650:	2042      	movs	r0, #66	; 0x42
 8007652:	f7fe b9c5 	b.w	80059e0 <test_emit_token>
 8007656:	bf00      	nop
	...

08007660 <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8007660:	2041      	movs	r0, #65	; 0x41
 8007662:	f7fe b9bd 	b.w	80059e0 <test_emit_token>
 8007666:	bf00      	nop
	...

08007670 <evt1_execute>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8007670:	b510      	push	{r4, lr}
 8007672:	4c1f      	ldr	r4, [pc, #124]	; (80076f0 <evt1_execute+0x80>)
 8007674:	b08a      	sub	sp, #40	; 0x28
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007676:	4620      	mov	r0, r4
 8007678:	4669      	mov	r1, sp
 800767a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800767e:	2201      	movs	r2, #1
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8007680:	6024      	str	r4, [r4, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007682:	f7fa fe05 	bl	8002290 <chEvtRegisterMaskWithFlags>
 8007686:	4620      	mov	r0, r4
 8007688:	a905      	add	r1, sp, #20
 800768a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800768e:	2202      	movs	r2, #2
 8007690:	f7fa fdfe 	bl	8002290 <chEvtRegisterMaskWithFlags>
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8007694:	6821      	ldr	r1, [r4, #0]
 8007696:	1b09      	subs	r1, r1, r4
 8007698:	bf18      	it	ne
 800769a:	2101      	movne	r1, #1
 800769c:	2001      	movs	r0, #1
 800769e:	f7fe f9af 	bl	8005a00 <_test_assert>
 80076a2:	b108      	cbz	r0, 80076a8 <evt1_execute+0x38>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 80076a4:	b00a      	add	sp, #40	; 0x28
 80076a6:	bd10      	pop	{r4, pc}
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 80076a8:	4669      	mov	r1, sp
 80076aa:	4620      	mov	r0, r4
 80076ac:	f7fa fe08 	bl	80022c0 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 80076b0:	6821      	ldr	r1, [r4, #0]
 80076b2:	1b09      	subs	r1, r1, r4
 80076b4:	bf18      	it	ne
 80076b6:	2101      	movne	r1, #1
 80076b8:	2002      	movs	r0, #2
 80076ba:	f7fe f9a1 	bl	8005a00 <_test_assert>
 80076be:	2800      	cmp	r0, #0
 80076c0:	d1f0      	bne.n	80076a4 <evt1_execute+0x34>
  chEvtUnregister(&es1, &el2);
 80076c2:	a905      	add	r1, sp, #20
 80076c4:	4620      	mov	r0, r4
 80076c6:	f7fa fdfb 	bl	80022c0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 80076ca:	6821      	ldr	r1, [r4, #0]
 80076cc:	1b09      	subs	r1, r1, r4
 80076ce:	fab1 f181 	clz	r1, r1
 80076d2:	2003      	movs	r0, #3
 80076d4:	0949      	lsrs	r1, r1, #5
 80076d6:	f7fe f993 	bl	8005a00 <_test_assert>
 80076da:	2800      	cmp	r0, #0
 80076dc:	d1e2      	bne.n	80076a4 <evt1_execute+0x34>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 80076de:	2107      	movs	r1, #7
 80076e0:	4804      	ldr	r0, [pc, #16]	; (80076f4 <evt1_execute+0x84>)
 80076e2:	f7fa fe75 	bl	80023d0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 80076e6:	4904      	ldr	r1, [pc, #16]	; (80076f8 <evt1_execute+0x88>)
 80076e8:	2004      	movs	r0, #4
 80076ea:	f7fe f9a1 	bl	8005a30 <_test_assert_sequence>
 80076ee:	e7d9      	b.n	80076a4 <evt1_execute+0x34>
 80076f0:	20000864 	.word	0x20000864
 80076f4:	0800ad40 	.word	0x0800ad40
 80076f8:	0800ab60 	.word	0x0800ab60
 80076fc:	00000000 	.word	0x00000000

08007700 <evt3_setup>:
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 8007700:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007704:	f7fa bdf4 	b.w	80022f0 <chEvtGetAndClearEvents>
	...

08007710 <evt2_setup>:
 8007710:	f7ff bff6 	b.w	8007700 <evt3_setup>
	...

08007720 <evt1_setup>:
 8007720:	f7ff bfee 	b.w	8007700 <evt3_setup>
	...

08007730 <evt2_execute>:
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8007730:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 8007734:	2007      	movs	r0, #7
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8007736:	b08d      	sub	sp, #52	; 0x34
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 8007738:	f7fa fdea 	bl	8002310 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 800773c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007740:	f7fa fe66 	bl	8002410 <chEvtWaitOne>
  test_assert(1, m == 1, "single event error");
 8007744:	f1a0 0101 	sub.w	r1, r0, #1
 8007748:	fab1 f181 	clz	r1, r1
 800774c:	0949      	lsrs	r1, r1, #5
 800774e:	2001      	movs	r0, #1
 8007750:	f7fe f956 	bl	8005a00 <_test_assert>
 8007754:	b110      	cbz	r0, 800775c <evt2_execute+0x2c>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 8007756:	b00d      	add	sp, #52	; 0x34
 8007758:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 800775c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007760:	f7fa fe56 	bl	8002410 <chEvtWaitOne>
  test_assert(2, m == 2, "single event error");
 8007764:	f1a0 0102 	sub.w	r1, r0, #2
 8007768:	fab1 f181 	clz	r1, r1
 800776c:	0949      	lsrs	r1, r1, #5
 800776e:	2002      	movs	r0, #2
 8007770:	f7fe f946 	bl	8005a00 <_test_assert>
 8007774:	2800      	cmp	r0, #0
 8007776:	d1ee      	bne.n	8007756 <evt2_execute+0x26>
  m = chEvtWaitOne(ALL_EVENTS);
 8007778:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800777c:	f7fa fe48 	bl	8002410 <chEvtWaitOne>
  test_assert(3, m == 4, "single event error");
 8007780:	f1a0 0104 	sub.w	r1, r0, #4
 8007784:	fab1 f181 	clz	r1, r1
 8007788:	0949      	lsrs	r1, r1, #5
 800778a:	2003      	movs	r0, #3
 800778c:	f7fe f938 	bl	8005a00 <_test_assert>
 8007790:	2800      	cmp	r0, #0
 8007792:	d1e0      	bne.n	8007756 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007794:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007798:	f7fa fdaa 	bl	80022f0 <chEvtGetAndClearEvents>
  test_assert(4, m == 0, "stuck event");
 800779c:	fab0 f180 	clz	r1, r0
 80077a0:	0949      	lsrs	r1, r1, #5
 80077a2:	2004      	movs	r0, #4
 80077a4:	f7fe f92c 	bl	8005a00 <_test_assert>
 80077a8:	4604      	mov	r4, r0
 80077aa:	2800      	cmp	r0, #0
 80077ac:	d1d3      	bne.n	8007756 <evt2_execute+0x26>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 80077ae:	f7fe f9af 	bl	8005b10 <test_wait_tick>
 80077b2:	f04f 0920 	mov.w	r9, #32
 80077b6:	f389 8811 	msr	BASEPRI, r9
 80077ba:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 80077be:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
 80077c2:	f384 8811 	msr	BASEPRI, r4
 80077c6:	4f76      	ldr	r7, [pc, #472]	; (80079a0 <evt2_execute+0x270>)
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80077c8:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 80079bc <evt2_execute+0x28c>
 80077cc:	69b9      	ldr	r1, [r7, #24]
 80077ce:	f8da 6000 	ldr.w	r6, [sl]
 80077d2:	688a      	ldr	r2, [r1, #8]
 80077d4:	4b73      	ldr	r3, [pc, #460]	; (80079a4 <evt2_execute+0x274>)
 80077d6:	9100      	str	r1, [sp, #0]
 80077d8:	3a01      	subs	r2, #1
 80077da:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80077de:	4630      	mov	r0, r6
 80077e0:	f7fa f80e 	bl	8001800 <chThdCreateStatic>
 80077e4:	4c70      	ldr	r4, [pc, #448]	; (80079a8 <evt2_execute+0x278>)
 80077e6:	6020      	str	r0, [r4, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 80077e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80077ec:	f7fa fe10 	bl	8002410 <chEvtWaitOne>
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 80077f0:	f205 2226 	addw	r2, r5, #550	; 0x226
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 80077f4:	4683      	mov	fp, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 80077f6:	f505 71fa 	add.w	r1, r5, #500	; 0x1f4
 80077fa:	2005      	movs	r0, #5
 80077fc:	f7fe f940 	bl	8005a80 <_test_assert_time_window>
 8007800:	2800      	cmp	r0, #0
 8007802:	d1a8      	bne.n	8007756 <evt2_execute+0x26>
  test_assert(6, m == 1, "single event error");
 8007804:	f1ab 0101 	sub.w	r1, fp, #1
 8007808:	fab1 f181 	clz	r1, r1
 800780c:	0949      	lsrs	r1, r1, #5
 800780e:	2006      	movs	r0, #6
 8007810:	f7fe f8f6 	bl	8005a00 <_test_assert>
 8007814:	2800      	cmp	r0, #0
 8007816:	d19e      	bne.n	8007756 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007818:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800781c:	f7fa fd68 	bl	80022f0 <chEvtGetAndClearEvents>
  test_assert(7, m == 0, "stuck event");
 8007820:	fab0 f180 	clz	r1, r0
 8007824:	0949      	lsrs	r1, r1, #5
 8007826:	2007      	movs	r0, #7
 8007828:	f7fe f8ea 	bl	8005a00 <_test_assert>
 800782c:	2800      	cmp	r0, #0
 800782e:	d192      	bne.n	8007756 <evt2_execute+0x26>
  test_wait_threads();
 8007830:	f7fe f956 	bl	8005ae0 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 8007834:	2005      	movs	r0, #5
 8007836:	f7fa fd6b 	bl	8002310 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 800783a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800783e:	f7fa fe07 	bl	8002450 <chEvtWaitAny>
  test_assert(8, m == 5, "unexpected pending bit");
 8007842:	1f45      	subs	r5, r0, #5
 8007844:	4269      	negs	r1, r5
 8007846:	4169      	adcs	r1, r5
 8007848:	2008      	movs	r0, #8
 800784a:	f7fe f8d9 	bl	8005a00 <_test_assert>
 800784e:	2800      	cmp	r0, #0
 8007850:	d181      	bne.n	8007756 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007852:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007856:	f7fa fd4b 	bl	80022f0 <chEvtGetAndClearEvents>
  test_assert(9, m == 0, "stuck event");
 800785a:	fab0 f180 	clz	r1, r0
 800785e:	0949      	lsrs	r1, r1, #5
 8007860:	2009      	movs	r0, #9
 8007862:	f7fe f8cd 	bl	8005a00 <_test_assert>
 8007866:	4683      	mov	fp, r0
 8007868:	2800      	cmp	r0, #0
 800786a:	f47f af74 	bne.w	8007756 <evt2_execute+0x26>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 800786e:	f7fe f94f 	bl	8005b10 <test_wait_tick>
 8007872:	f389 8811 	msr	BASEPRI, r9
 8007876:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
 800787a:	f38b 8811 	msr	BASEPRI, fp
 800787e:	69b9      	ldr	r1, [r7, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007880:	4b48      	ldr	r3, [pc, #288]	; (80079a4 <evt2_execute+0x274>)
 8007882:	688a      	ldr	r2, [r1, #8]
 8007884:	9100      	str	r1, [sp, #0]
 8007886:	3a01      	subs	r2, #1
 8007888:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800788c:	4630      	mov	r0, r6
 800788e:	f7f9 ffb7 	bl	8001800 <chThdCreateStatic>
 8007892:	6020      	str	r0, [r4, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 8007894:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007898:	f7fa fdda 	bl	8002450 <chEvtWaitAny>
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 800789c:	f205 2226 	addw	r2, r5, #550	; 0x226
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80078a0:	4606      	mov	r6, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80078a2:	f505 71fa 	add.w	r1, r5, #500	; 0x1f4
 80078a6:	200a      	movs	r0, #10
 80078a8:	f7fe f8ea 	bl	8005a80 <_test_assert_time_window>
 80078ac:	2800      	cmp	r0, #0
 80078ae:	f47f af52 	bne.w	8007756 <evt2_execute+0x26>
  test_assert(11, m == 1, "single event error");
 80078b2:	1e70      	subs	r0, r6, #1
 80078b4:	4241      	negs	r1, r0
 80078b6:	4141      	adcs	r1, r0
 80078b8:	200b      	movs	r0, #11
 80078ba:	f7fe f8a1 	bl	8005a00 <_test_assert>
 80078be:	2800      	cmp	r0, #0
 80078c0:	f47f af49 	bne.w	8007756 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80078c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80078c8:	f7fa fd12 	bl	80022f0 <chEvtGetAndClearEvents>
  test_assert(12, m == 0, "stuck event");
 80078cc:	fab0 f180 	clz	r1, r0
 80078d0:	0949      	lsrs	r1, r1, #5
 80078d2:	200c      	movs	r0, #12
 80078d4:	f7fe f894 	bl	8005a00 <_test_assert>
 80078d8:	4681      	mov	r9, r0
 80078da:	2800      	cmp	r0, #0
 80078dc:	f47f af3b 	bne.w	8007756 <evt2_execute+0x26>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80078e0:	4e32      	ldr	r6, [pc, #200]	; (80079ac <evt2_execute+0x27c>)
 80078e2:	4d33      	ldr	r5, [pc, #204]	; (80079b0 <evt2_execute+0x280>)
  test_wait_threads();
 80078e4:	f7fe f8fc 	bl	8005ae0 <test_wait_threads>
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 80078e8:	4630      	mov	r0, r6
 80078ea:	a902      	add	r1, sp, #8
 80078ec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80078f0:	2201      	movs	r2, #1
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80078f2:	6036      	str	r6, [r6, #0]
 80078f4:	602d      	str	r5, [r5, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 80078f6:	f7fa fccb 	bl	8002290 <chEvtRegisterMaskWithFlags>
 80078fa:	4628      	mov	r0, r5
 80078fc:	a907      	add	r1, sp, #28
 80078fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007902:	2204      	movs	r2, #4
 8007904:	f7fa fcc4 	bl	8002290 <chEvtRegisterMaskWithFlags>
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 8007908:	f7fe f902 	bl	8005b10 <test_wait_tick>
 800790c:	2320      	movs	r3, #32
 800790e:	f383 8811 	msr	BASEPRI, r3
 8007912:	f8d8 8024 	ldr.w	r8, [r8, #36]	; 0x24
 8007916:	f389 8811 	msr	BASEPRI, r9
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800791a:	69ba      	ldr	r2, [r7, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800791c:	4b25      	ldr	r3, [pc, #148]	; (80079b4 <evt2_execute+0x284>)
 800791e:	6892      	ldr	r2, [r2, #8]
 8007920:	f8da 0000 	ldr.w	r0, [sl]
 8007924:	9300      	str	r3, [sp, #0]
 8007926:	3a01      	subs	r2, #1
 8007928:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800792c:	4b22      	ldr	r3, [pc, #136]	; (80079b8 <evt2_execute+0x288>)
 800792e:	f7f9 ff67 	bl	8001800 <chThdCreateStatic>
 8007932:	6020      	str	r0, [r4, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 8007934:	2005      	movs	r0, #5
 8007936:	f7fa fdab 	bl	8002490 <chEvtWaitAll>
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 800793a:	f208 2226 	addw	r2, r8, #550	; 0x226
 800793e:	f508 71fa 	add.w	r1, r8, #500	; 0x1f4
 8007942:	200d      	movs	r0, #13
 8007944:	f7fe f89c 	bl	8005a80 <_test_assert_time_window>
 8007948:	2800      	cmp	r0, #0
 800794a:	f47f af04 	bne.w	8007756 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800794e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007952:	f7fa fccd 	bl	80022f0 <chEvtGetAndClearEvents>
  test_assert(14, m == 0, "stuck event");
 8007956:	fab0 f180 	clz	r1, r0
 800795a:	0949      	lsrs	r1, r1, #5
 800795c:	200e      	movs	r0, #14
 800795e:	f7fe f84f 	bl	8005a00 <_test_assert>
 8007962:	2800      	cmp	r0, #0
 8007964:	f47f aef7 	bne.w	8007756 <evt2_execute+0x26>
  test_wait_threads();
 8007968:	f7fe f8ba 	bl	8005ae0 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 800796c:	a902      	add	r1, sp, #8
 800796e:	4630      	mov	r0, r6
 8007970:	f7fa fca6 	bl	80022c0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 8007974:	a907      	add	r1, sp, #28
 8007976:	4628      	mov	r0, r5
 8007978:	f7fa fca2 	bl	80022c0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800797c:	6831      	ldr	r1, [r6, #0]
 800797e:	1b8a      	subs	r2, r1, r6
 8007980:	4251      	negs	r1, r2
 8007982:	4151      	adcs	r1, r2
 8007984:	200f      	movs	r0, #15
 8007986:	f7fe f83b 	bl	8005a00 <_test_assert>
 800798a:	2800      	cmp	r0, #0
 800798c:	f47f aee3 	bne.w	8007756 <evt2_execute+0x26>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8007990:	6829      	ldr	r1, [r5, #0]
 8007992:	1b4b      	subs	r3, r1, r5
 8007994:	4259      	negs	r1, r3
 8007996:	4159      	adcs	r1, r3
 8007998:	2010      	movs	r0, #16
 800799a:	f7fe f831 	bl	8005a00 <_test_assert>
 800799e:	e6da      	b.n	8007756 <evt2_execute+0x26>
 80079a0:	20000e78 	.word	0x20000e78
 80079a4:	080079f1 	.word	0x080079f1
 80079a8:	200019f8 	.word	0x200019f8
 80079ac:	20000864 	.word	0x20000864
 80079b0:	20000868 	.word	0x20000868
 80079b4:	0800a9d8 	.word	0x0800a9d8
 80079b8:	080079c1 	.word	0x080079c1
 80079bc:	0800a700 	.word	0x0800a700

080079c0 <thread2>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(thread2, p) {
 80079c0:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 80079c2:	2100      	movs	r1, #0
 80079c4:	4806      	ldr	r0, [pc, #24]	; (80079e0 <thread2+0x20>)
 80079c6:	f7fa fcf3 	bl	80023b0 <chEvtBroadcastFlags>

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 80079ca:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80079ce:	f7f9 ff87 	bl	80018e0 <chThdSleep>
 80079d2:	2100      	movs	r1, #0
 80079d4:	4803      	ldr	r0, [pc, #12]	; (80079e4 <thread2+0x24>)
  chEvtBroadcast(&es2);
}
 80079d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80079da:	f7fa bce9 	b.w	80023b0 <chEvtBroadcastFlags>
 80079de:	bf00      	nop
 80079e0:	20000864 	.word	0x20000864
 80079e4:	20000868 	.word	0x20000868
	...

080079f0 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static THD_FUNCTION(thread1, p) {
 80079f0:	b510      	push	{r4, lr}
 80079f2:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 80079f4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80079f8:	f7f9 ff72 	bl	80018e0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 80079fc:	4620      	mov	r0, r4
 80079fe:	2101      	movs	r1, #1
}
 8007a00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static THD_FUNCTION(thread1, p) {

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
 8007a04:	f7fa bcc4 	b.w	8002390 <chEvtSignal>
	...

08007a10 <evt3_execute>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8007a10:	b508      	push	{r3, lr}
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007a12:	2100      	movs	r1, #0
 8007a14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a18:	f7fa fd5a 	bl	80024d0 <chEvtWaitOneTimeout>
  test_assert(1, m == 0, "spurious event");
 8007a1c:	fab0 f180 	clz	r1, r0
 8007a20:	0949      	lsrs	r1, r1, #5
 8007a22:	2001      	movs	r0, #1
 8007a24:	f7fd ffec 	bl	8005a00 <_test_assert>
 8007a28:	b100      	cbz	r0, 8007a2c <evt3_execute+0x1c>
 8007a2a:	bd08      	pop	{r3, pc}
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007a2c:	4601      	mov	r1, r0
 8007a2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a32:	f7fa fd75 	bl	8002520 <chEvtWaitAnyTimeout>
  test_assert(2, m == 0, "spurious event");
 8007a36:	fab0 f180 	clz	r1, r0
 8007a3a:	0949      	lsrs	r1, r1, #5
 8007a3c:	2002      	movs	r0, #2
 8007a3e:	f7fd ffdf 	bl	8005a00 <_test_assert>
 8007a42:	2800      	cmp	r0, #0
 8007a44:	d1f1      	bne.n	8007a2a <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007a46:	4601      	mov	r1, r0
 8007a48:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a4c:	f7fa fd90 	bl	8002570 <chEvtWaitAllTimeout>
  test_assert(3, m == 0, "spurious event");
 8007a50:	fab0 f180 	clz	r1, r0
 8007a54:	0949      	lsrs	r1, r1, #5
 8007a56:	2003      	movs	r0, #3
 8007a58:	f7fd ffd2 	bl	8005a00 <_test_assert>
 8007a5c:	2800      	cmp	r0, #0
 8007a5e:	d1e4      	bne.n	8007a2a <evt3_execute+0x1a>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 8007a60:	210a      	movs	r1, #10
 8007a62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a66:	f7fa fd33 	bl	80024d0 <chEvtWaitOneTimeout>
  test_assert(4, m == 0, "spurious event");
 8007a6a:	fab0 f180 	clz	r1, r0
 8007a6e:	0949      	lsrs	r1, r1, #5
 8007a70:	2004      	movs	r0, #4
 8007a72:	f7fd ffc5 	bl	8005a00 <_test_assert>
 8007a76:	2800      	cmp	r0, #0
 8007a78:	d1d7      	bne.n	8007a2a <evt3_execute+0x1a>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 8007a7a:	210a      	movs	r1, #10
 8007a7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a80:	f7fa fd4e 	bl	8002520 <chEvtWaitAnyTimeout>
  test_assert(5, m == 0, "spurious event");
 8007a84:	fab0 f180 	clz	r1, r0
 8007a88:	0949      	lsrs	r1, r1, #5
 8007a8a:	2005      	movs	r0, #5
 8007a8c:	f7fd ffb8 	bl	8005a00 <_test_assert>
 8007a90:	2800      	cmp	r0, #0
 8007a92:	d1ca      	bne.n	8007a2a <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 8007a94:	210a      	movs	r1, #10
 8007a96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a9a:	f7fa fd69 	bl	8002570 <chEvtWaitAllTimeout>
  test_assert(6, m == 0, "spurious event");
 8007a9e:	fab0 f180 	clz	r1, r0
 8007aa2:	0949      	lsrs	r1, r1, #5
 8007aa4:	2006      	movs	r0, #6
}
 8007aa6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 8007aaa:	f7fd bfa9 	b.w	8005a00 <_test_assert>
 8007aae:	bf00      	nop

08007ab0 <heap1_execute>:
static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}

static void heap1_execute(void) {
 8007ab0:	b570      	push	{r4, r5, r6, lr}
 8007ab2:	b082      	sub	sp, #8
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 8007ab4:	f7fb f874 	bl	8002ba0 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8007ab8:	a901      	add	r1, sp, #4
 8007aba:	2000      	movs	r0, #0
 8007abc:	f7fb f938 	bl	8002d30 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8007ac0:	2110      	movs	r1, #16
 8007ac2:	2000      	movs	r0, #0
 8007ac4:	f7fb f89c 	bl	8002c00 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8007ac8:	1c01      	adds	r1, r0, #0
 8007aca:	4605      	mov	r5, r0
 8007acc:	bf18      	it	ne
 8007ace:	2101      	movne	r1, #1
 8007ad0:	2001      	movs	r0, #1
 8007ad2:	f7fd ff95 	bl	8005a00 <_test_assert>
 8007ad6:	b108      	cbz	r0, 8007adc <heap1_execute+0x2c>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8007ad8:	b002      	add	sp, #8
 8007ada:	bd70      	pop	{r4, r5, r6, pc}
 8007adc:	4604      	mov	r4, r0
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8007ade:	4628      	mov	r0, r5
 8007ae0:	f7fb f8d6 	bl	8002c90 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8007ae4:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8007ae8:	4620      	mov	r0, r4
 8007aea:	f7fb f889 	bl	8002c00 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8007aee:	fab0 f180 	clz	r1, r0
 8007af2:	0949      	lsrs	r1, r1, #5
 8007af4:	2002      	movs	r0, #2
 8007af6:	f7fd ff83 	bl	8005a00 <_test_assert>
 8007afa:	2800      	cmp	r0, #0
 8007afc:	d1ec      	bne.n	8007ad8 <heap1_execute+0x28>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8007afe:	a901      	add	r1, sp, #4
 8007b00:	487b      	ldr	r0, [pc, #492]	; (8007cf0 <heap1_execute+0x240>)
 8007b02:	f7fb f915 	bl	8002d30 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007b06:	2110      	movs	r1, #16
 8007b08:	4879      	ldr	r0, [pc, #484]	; (8007cf0 <heap1_execute+0x240>)
 8007b0a:	f7fb f879 	bl	8002c00 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007b0e:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007b10:	4606      	mov	r6, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007b12:	4877      	ldr	r0, [pc, #476]	; (8007cf0 <heap1_execute+0x240>)
 8007b14:	f7fb f874 	bl	8002c00 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007b18:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007b1a:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007b1c:	4874      	ldr	r0, [pc, #464]	; (8007cf0 <heap1_execute+0x240>)
 8007b1e:	f7fb f86f 	bl	8002c00 <chHeapAlloc>
 8007b22:	4604      	mov	r4, r0
  chHeapFree(p1);                               /* Does not merge.*/
 8007b24:	4630      	mov	r0, r6
 8007b26:	f7fb f8b3 	bl	8002c90 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8007b2a:	4628      	mov	r0, r5
 8007b2c:	f7fb f8b0 	bl	8002c90 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8007b30:	4620      	mov	r0, r4
 8007b32:	f7fb f8ad 	bl	8002c90 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007b36:	4669      	mov	r1, sp
 8007b38:	486d      	ldr	r0, [pc, #436]	; (8007cf0 <heap1_execute+0x240>)
 8007b3a:	f7fb f8f9 	bl	8002d30 <chHeapStatus>
 8007b3e:	f1a0 0101 	sub.w	r1, r0, #1
 8007b42:	fab1 f181 	clz	r1, r1
 8007b46:	0949      	lsrs	r1, r1, #5
 8007b48:	2003      	movs	r0, #3
 8007b4a:	f7fd ff59 	bl	8005a00 <_test_assert>
 8007b4e:	2800      	cmp	r0, #0
 8007b50:	d1c2      	bne.n	8007ad8 <heap1_execute+0x28>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007b52:	2110      	movs	r1, #16
 8007b54:	4866      	ldr	r0, [pc, #408]	; (8007cf0 <heap1_execute+0x240>)
 8007b56:	f7fb f853 	bl	8002c00 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007b5a:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007b5c:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007b5e:	4864      	ldr	r0, [pc, #400]	; (8007cf0 <heap1_execute+0x240>)
 8007b60:	f7fb f84e 	bl	8002c00 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007b64:	2110      	movs	r1, #16
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007b66:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007b68:	4861      	ldr	r0, [pc, #388]	; (8007cf0 <heap1_execute+0x240>)
 8007b6a:	f7fb f849 	bl	8002c00 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8007b6e:	f7fb f88f 	bl	8002c90 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8007b72:	4628      	mov	r0, r5
 8007b74:	f7fb f88c 	bl	8002c90 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8007b78:	4620      	mov	r0, r4
 8007b7a:	f7fb f889 	bl	8002c90 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007b7e:	4669      	mov	r1, sp
 8007b80:	485b      	ldr	r0, [pc, #364]	; (8007cf0 <heap1_execute+0x240>)
 8007b82:	f7fb f8d5 	bl	8002d30 <chHeapStatus>
 8007b86:	f1a0 0101 	sub.w	r1, r0, #1
 8007b8a:	fab1 f181 	clz	r1, r1
 8007b8e:	0949      	lsrs	r1, r1, #5
 8007b90:	2004      	movs	r0, #4
 8007b92:	f7fd ff35 	bl	8005a00 <_test_assert>
 8007b96:	2800      	cmp	r0, #0
 8007b98:	d19e      	bne.n	8007ad8 <heap1_execute+0x28>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8007b9a:	2111      	movs	r1, #17
 8007b9c:	4854      	ldr	r0, [pc, #336]	; (8007cf0 <heap1_execute+0x240>)
 8007b9e:	f7fb f82f 	bl	8002c00 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007ba2:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8007ba4:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007ba6:	4852      	ldr	r0, [pc, #328]	; (8007cf0 <heap1_execute+0x240>)
 8007ba8:	f7fb f82a 	bl	8002c00 <chHeapAlloc>
 8007bac:	4605      	mov	r5, r0
  chHeapFree(p1);
 8007bae:	4620      	mov	r0, r4
 8007bb0:	f7fb f86e 	bl	8002c90 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8007bb4:	4669      	mov	r1, sp
 8007bb6:	484e      	ldr	r0, [pc, #312]	; (8007cf0 <heap1_execute+0x240>)
 8007bb8:	f7fb f8ba 	bl	8002d30 <chHeapStatus>
 8007bbc:	f1a0 0102 	sub.w	r1, r0, #2
 8007bc0:	fab1 f181 	clz	r1, r1
 8007bc4:	0949      	lsrs	r1, r1, #5
 8007bc6:	2005      	movs	r0, #5
 8007bc8:	f7fd ff1a 	bl	8005a00 <_test_assert>
 8007bcc:	2800      	cmp	r0, #0
 8007bce:	d183      	bne.n	8007ad8 <heap1_execute+0x28>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007bd0:	2110      	movs	r1, #16
 8007bd2:	4847      	ldr	r0, [pc, #284]	; (8007cf0 <heap1_execute+0x240>)
 8007bd4:	f7fb f814 	bl	8002c00 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8007bd8:	4669      	mov	r1, sp
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007bda:	4604      	mov	r4, r0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8007bdc:	4844      	ldr	r0, [pc, #272]	; (8007cf0 <heap1_execute+0x240>)
 8007bde:	f7fb f8a7 	bl	8002d30 <chHeapStatus>
 8007be2:	2801      	cmp	r0, #1
 8007be4:	f000 8081 	beq.w	8007cea <heap1_execute+0x23a>
 8007be8:	4669      	mov	r1, sp
 8007bea:	4841      	ldr	r0, [pc, #260]	; (8007cf0 <heap1_execute+0x240>)
 8007bec:	f7fb f8a0 	bl	8002d30 <chHeapStatus>
 8007bf0:	f1a0 0102 	sub.w	r1, r0, #2
 8007bf4:	fab1 f181 	clz	r1, r1
 8007bf8:	0949      	lsrs	r1, r1, #5
 8007bfa:	2006      	movs	r0, #6
 8007bfc:	f7fd ff00 	bl	8005a00 <_test_assert>
 8007c00:	2800      	cmp	r0, #0
 8007c02:	f47f af69 	bne.w	8007ad8 <heap1_execute+0x28>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 8007c06:	4628      	mov	r0, r5
 8007c08:	f7fb f842 	bl	8002c90 <chHeapFree>
  chHeapFree(p1);
 8007c0c:	4620      	mov	r0, r4
 8007c0e:	f7fb f83f 	bl	8002c90 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007c12:	4669      	mov	r1, sp
 8007c14:	4836      	ldr	r0, [pc, #216]	; (8007cf0 <heap1_execute+0x240>)
 8007c16:	f7fb f88b 	bl	8002d30 <chHeapStatus>
 8007c1a:	1e46      	subs	r6, r0, #1
 8007c1c:	4271      	negs	r1, r6
 8007c1e:	4171      	adcs	r1, r6
 8007c20:	2007      	movs	r0, #7
 8007c22:	f7fd feed 	bl	8005a00 <_test_assert>
 8007c26:	2800      	cmp	r0, #0
 8007c28:	f47f af56 	bne.w	8007ad8 <heap1_execute+0x28>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007c2c:	2110      	movs	r1, #16
 8007c2e:	4830      	ldr	r0, [pc, #192]	; (8007cf0 <heap1_execute+0x240>)
 8007c30:	f7fa ffe6 	bl	8002c00 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007c34:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007c36:	4605      	mov	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007c38:	482d      	ldr	r0, [pc, #180]	; (8007cf0 <heap1_execute+0x240>)
 8007c3a:	f7fa ffe1 	bl	8002c00 <chHeapAlloc>
 8007c3e:	4604      	mov	r4, r0
  chHeapFree(p1);
 8007c40:	4628      	mov	r0, r5
 8007c42:	f7fb f825 	bl	8002c90 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8007c46:	4669      	mov	r1, sp
 8007c48:	4829      	ldr	r0, [pc, #164]	; (8007cf0 <heap1_execute+0x240>)
 8007c4a:	f7fb f871 	bl	8002d30 <chHeapStatus>
 8007c4e:	1e85      	subs	r5, r0, #2
 8007c50:	4269      	negs	r1, r5
 8007c52:	4169      	adcs	r1, r5
 8007c54:	2008      	movs	r0, #8
 8007c56:	f7fd fed3 	bl	8005a00 <_test_assert>
 8007c5a:	2800      	cmp	r0, #0
 8007c5c:	f47f af3c 	bne.w	8007ad8 <heap1_execute+0x28>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8007c60:	2120      	movs	r1, #32
 8007c62:	4823      	ldr	r0, [pc, #140]	; (8007cf0 <heap1_execute+0x240>)
 8007c64:	f7fa ffcc 	bl	8002c00 <chHeapAlloc>
  chHeapFree(p1);
 8007c68:	f7fb f812 	bl	8002c90 <chHeapFree>
  chHeapFree(p2);
 8007c6c:	4620      	mov	r0, r4
 8007c6e:	f7fb f80f 	bl	8002c90 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007c72:	4669      	mov	r1, sp
 8007c74:	481e      	ldr	r0, [pc, #120]	; (8007cf0 <heap1_execute+0x240>)
 8007c76:	f7fb f85b 	bl	8002d30 <chHeapStatus>
 8007c7a:	3801      	subs	r0, #1
 8007c7c:	4241      	negs	r1, r0
 8007c7e:	4141      	adcs	r1, r0
 8007c80:	2009      	movs	r0, #9
 8007c82:	f7fd febd 	bl	8005a00 <_test_assert>
 8007c86:	2800      	cmp	r0, #0
 8007c88:	f47f af26 	bne.w	8007ad8 <heap1_execute+0x28>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 8007c8c:	4669      	mov	r1, sp
 8007c8e:	4818      	ldr	r0, [pc, #96]	; (8007cf0 <heap1_execute+0x240>)
 8007c90:	f7fb f84e 	bl	8002d30 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8007c94:	9900      	ldr	r1, [sp, #0]
 8007c96:	4816      	ldr	r0, [pc, #88]	; (8007cf0 <heap1_execute+0x240>)
 8007c98:	f7fa ffb2 	bl	8002c00 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8007c9c:	4669      	mov	r1, sp
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 8007c9e:	4604      	mov	r4, r0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8007ca0:	4813      	ldr	r0, [pc, #76]	; (8007cf0 <heap1_execute+0x240>)
 8007ca2:	f7fb f845 	bl	8002d30 <chHeapStatus>
 8007ca6:	fab0 f180 	clz	r1, r0
 8007caa:	0949      	lsrs	r1, r1, #5
 8007cac:	200a      	movs	r0, #10
 8007cae:	f7fd fea7 	bl	8005a00 <_test_assert>
 8007cb2:	2800      	cmp	r0, #0
 8007cb4:	f47f af10 	bne.w	8007ad8 <heap1_execute+0x28>
  chHeapFree(p1);
 8007cb8:	4620      	mov	r0, r4
 8007cba:	f7fa ffe9 	bl	8002c90 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007cbe:	4669      	mov	r1, sp
 8007cc0:	480b      	ldr	r0, [pc, #44]	; (8007cf0 <heap1_execute+0x240>)
 8007cc2:	f7fb f835 	bl	8002d30 <chHeapStatus>
 8007cc6:	1e42      	subs	r2, r0, #1
 8007cc8:	4251      	negs	r1, r2
 8007cca:	4151      	adcs	r1, r2
 8007ccc:	200b      	movs	r0, #11
 8007cce:	f7fd fe97 	bl	8005a00 <_test_assert>
 8007cd2:	2800      	cmp	r0, #0
 8007cd4:	f47f af00 	bne.w	8007ad8 <heap1_execute+0x28>
  test_assert(12, n == sz, "size changed");
 8007cd8:	e89d 000a 	ldmia.w	sp, {r1, r3}
 8007cdc:	1acb      	subs	r3, r1, r3
 8007cde:	4259      	negs	r1, r3
 8007ce0:	4159      	adcs	r1, r3
 8007ce2:	200c      	movs	r0, #12
 8007ce4:	f7fd fe8c 	bl	8005a00 <_test_assert>
 8007ce8:	e6f6      	b.n	8007ad8 <heap1_execute+0x28>
 8007cea:	4601      	mov	r1, r0
 8007cec:	e785      	b.n	8007bfa <heap1_execute+0x14a>
 8007cee:	bf00      	nop
 8007cf0:	20001a28 	.word	0x20001a28
	...

08007d00 <heap1_setup>:
 * sequence.
 */

static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 8007d00:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 8007d04:	4901      	ldr	r1, [pc, #4]	; (8007d0c <heap1_setup+0xc>)
 8007d06:	4802      	ldr	r0, [pc, #8]	; (8007d10 <heap1_setup+0x10>)
 8007d08:	f7fa bf6a 	b.w	8002be0 <chHeapObjectInit>
 8007d0c:	20001370 	.word	0x20001370
 8007d10:	20001a28 	.word	0x20001a28
	...

08007d20 <null_provider>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 8007d20:	2000      	movs	r0, #0
 8007d22:	4770      	bx	lr
	...

08007d30 <pools1_setup>:

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8007d30:	2200      	movs	r2, #0
 8007d32:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8007d36:	4801      	ldr	r0, [pc, #4]	; (8007d3c <pools1_setup+0xc>)
 8007d38:	f7fb b822 	b.w	8002d80 <chPoolObjectInit>
 8007d3c:	2000086c 	.word	0x2000086c

08007d40 <pools1_execute>:
}

static void pools1_execute(void) {
 8007d40:	b538      	push	{r3, r4, r5, lr}
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 8007d42:	4b2b      	ldr	r3, [pc, #172]	; (8007df0 <pools1_execute+0xb0>)
 8007d44:	482b      	ldr	r0, [pc, #172]	; (8007df4 <pools1_execute+0xb4>)
 8007d46:	681d      	ldr	r5, [r3, #0]
 8007d48:	2205      	movs	r2, #5
 8007d4a:	4629      	mov	r1, r5
 8007d4c:	f7fb f820 	bl	8002d90 <chPoolLoadArray>
 8007d50:	2405      	movs	r4, #5

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 8007d52:	4828      	ldr	r0, [pc, #160]	; (8007df4 <pools1_execute+0xb4>)
 8007d54:	f7fb f834 	bl	8002dc0 <chPoolAlloc>
 8007d58:	1c01      	adds	r1, r0, #0
 8007d5a:	bf18      	it	ne
 8007d5c:	2101      	movne	r1, #1
 8007d5e:	2001      	movs	r0, #1
 8007d60:	f7fd fe4e 	bl	8005a00 <_test_assert>
 8007d64:	bb90      	cbnz	r0, 8007dcc <pools1_execute+0x8c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8007d66:	3c01      	subs	r4, #1
 8007d68:	d1f3      	bne.n	8007d52 <pools1_execute+0x12>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8007d6a:	4822      	ldr	r0, [pc, #136]	; (8007df4 <pools1_execute+0xb4>)
 8007d6c:	f7fb f828 	bl	8002dc0 <chPoolAlloc>
 8007d70:	fab0 f180 	clz	r1, r0
 8007d74:	0949      	lsrs	r1, r1, #5
 8007d76:	2002      	movs	r0, #2
 8007d78:	f7fd fe42 	bl	8005a00 <_test_assert>
 8007d7c:	bb30      	cbnz	r0, 8007dcc <pools1_execute+0x8c>
 8007d7e:	4c1c      	ldr	r4, [pc, #112]	; (8007df0 <pools1_execute+0xb0>)

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8007d80:	481c      	ldr	r0, [pc, #112]	; (8007df4 <pools1_execute+0xb4>)
  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8007d82:	4629      	mov	r1, r5
 8007d84:	f104 0510 	add.w	r5, r4, #16

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8007d88:	f7fb f832 	bl	8002df0 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 8007d8c:	42a5      	cmp	r5, r4
 8007d8e:	d006      	beq.n	8007d9e <pools1_execute+0x5e>
 8007d90:	f854 1f04 	ldr.w	r1, [r4, #4]!
    chPoolFree(&mp1, wa[i]);
 8007d94:	4817      	ldr	r0, [pc, #92]	; (8007df4 <pools1_execute+0xb4>)
 8007d96:	f7fb f82b 	bl	8002df0 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 8007d9a:	42a5      	cmp	r5, r4
 8007d9c:	d1f8      	bne.n	8007d90 <pools1_execute+0x50>
 8007d9e:	2405      	movs	r4, #5
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 8007da0:	4814      	ldr	r0, [pc, #80]	; (8007df4 <pools1_execute+0xb4>)
 8007da2:	f7fb f80d 	bl	8002dc0 <chPoolAlloc>
 8007da6:	1c01      	adds	r1, r0, #0
 8007da8:	bf18      	it	ne
 8007daa:	2101      	movne	r1, #1
 8007dac:	2003      	movs	r0, #3
 8007dae:	f7fd fe27 	bl	8005a00 <_test_assert>
 8007db2:	b958      	cbnz	r0, 8007dcc <pools1_execute+0x8c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 8007db4:	3c01      	subs	r4, #1
 8007db6:	d1f3      	bne.n	8007da0 <pools1_execute+0x60>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 8007db8:	480e      	ldr	r0, [pc, #56]	; (8007df4 <pools1_execute+0xb4>)
 8007dba:	f7fb f801 	bl	8002dc0 <chPoolAlloc>
 8007dbe:	fab0 f180 	clz	r1, r0
 8007dc2:	0949      	lsrs	r1, r1, #5
 8007dc4:	2004      	movs	r0, #4
 8007dc6:	f7fd fe1b 	bl	8005a00 <_test_assert>
 8007dca:	b100      	cbz	r0, 8007dce <pools1_execute+0x8e>
 8007dcc:	bd38      	pop	{r3, r4, r5, pc}

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 8007dce:	2110      	movs	r1, #16
 8007dd0:	4a09      	ldr	r2, [pc, #36]	; (8007df8 <pools1_execute+0xb8>)
 8007dd2:	4808      	ldr	r0, [pc, #32]	; (8007df4 <pools1_execute+0xb4>)
 8007dd4:	f7fa ffd4 	bl	8002d80 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8007dd8:	4806      	ldr	r0, [pc, #24]	; (8007df4 <pools1_execute+0xb4>)
 8007dda:	f7fa fff1 	bl	8002dc0 <chPoolAlloc>
 8007dde:	fab0 f180 	clz	r1, r0
 8007de2:	0949      	lsrs	r1, r1, #5
 8007de4:	2005      	movs	r0, #5
}
 8007de6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8007dea:	f7fd be09 	b.w	8005a00 <_test_assert>
 8007dee:	bf00      	nop
 8007df0:	0800a700 	.word	0x0800a700
 8007df4:	2000086c 	.word	0x2000086c
 8007df8:	08007d21 	.word	0x08007d21
 8007dfc:	00000000 	.word	0x00000000

08007e00 <dyn1_execute>:
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8007e00:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007e02:	4b34      	ldr	r3, [pc, #208]	; (8007ed4 <dyn1_execute+0xd4>)
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8007e04:	4834      	ldr	r0, [pc, #208]	; (8007ed8 <dyn1_execute+0xd8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007e06:	699b      	ldr	r3, [r3, #24]
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8007e08:	4c34      	ldr	r4, [pc, #208]	; (8007edc <dyn1_execute+0xdc>)
 8007e0a:	689d      	ldr	r5, [r3, #8]
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8007e0c:	b084      	sub	sp, #16
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8007e0e:	a903      	add	r1, sp, #12
 8007e10:	f7fa ff8e 	bl	8002d30 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8007e14:	4b32      	ldr	r3, [pc, #200]	; (8007ee0 <dyn1_execute+0xe0>)
 8007e16:	9300      	str	r3, [sp, #0]
 8007e18:	1e6a      	subs	r2, r5, #1
 8007e1a:	4b32      	ldr	r3, [pc, #200]	; (8007ee4 <dyn1_execute+0xe4>)
 8007e1c:	482e      	ldr	r0, [pc, #184]	; (8007ed8 <dyn1_execute+0xd8>)
 8007e1e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8007e22:	f7f9 fec5 	bl	8001bb0 <chThdCreateFromHeap>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8007e26:	4b30      	ldr	r3, [pc, #192]	; (8007ee8 <dyn1_execute+0xe8>)
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8007e28:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8007e2a:	1eaa      	subs	r2, r5, #2
 8007e2c:	9300      	str	r3, [sp, #0]
 8007e2e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8007e32:	4b2c      	ldr	r3, [pc, #176]	; (8007ee4 <dyn1_execute+0xe4>)
 8007e34:	4828      	ldr	r0, [pc, #160]	; (8007ed8 <dyn1_execute+0xd8>)
 8007e36:	f7f9 febb 	bl	8001bb0 <chThdCreateFromHeap>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8007e3a:	a902      	add	r1, sp, #8
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8007e3c:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8007e3e:	4826      	ldr	r0, [pc, #152]	; (8007ed8 <dyn1_execute+0xd8>)
 8007e40:	f7fa ff76 	bl	8002d30 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8007e44:	9902      	ldr	r1, [sp, #8]
 8007e46:	4824      	ldr	r0, [pc, #144]	; (8007ed8 <dyn1_execute+0xd8>)
 8007e48:	f7fa feda 	bl	8002c00 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 8007e4c:	4b27      	ldr	r3, [pc, #156]	; (8007eec <dyn1_execute+0xec>)
 8007e4e:	9300      	str	r3, [sp, #0]
 8007e50:	f44f 71a4 	mov.w	r1, #328	; 0x148
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 8007e54:	4606      	mov	r6, r0
  threads[2] = chThdCreateFromHeap(&heap1,
 8007e56:	1eea      	subs	r2, r5, #3
 8007e58:	4b22      	ldr	r3, [pc, #136]	; (8007ee4 <dyn1_execute+0xe4>)
 8007e5a:	481f      	ldr	r0, [pc, #124]	; (8007ed8 <dyn1_execute+0xd8>)
 8007e5c:	f7f9 fea8 	bl	8001bb0 <chThdCreateFromHeap>
 8007e60:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8007e62:	4630      	mov	r0, r6
 8007e64:	f7fa ff14 	bl	8002c90 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 8007e68:	6821      	ldr	r1, [r4, #0]
 8007e6a:	b121      	cbz	r1, 8007e76 <dyn1_execute+0x76>
 8007e6c:	6861      	ldr	r1, [r4, #4]
 8007e6e:	b111      	cbz	r1, 8007e76 <dyn1_execute+0x76>
 8007e70:	68a1      	ldr	r1, [r4, #8]
 8007e72:	b331      	cbz	r1, 8007ec2 <dyn1_execute+0xc2>
 8007e74:	2100      	movs	r1, #0
 8007e76:	2001      	movs	r0, #1
 8007e78:	f7fd fdc2 	bl	8005a00 <_test_assert>
 8007e7c:	b108      	cbz	r0, 8007e82 <dyn1_execute+0x82>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 8007e7e:	b004      	add	sp, #16
 8007e80:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8007e82:	f7fd fe2d 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8007e86:	491a      	ldr	r1, [pc, #104]	; (8007ef0 <dyn1_execute+0xf0>)
 8007e88:	2002      	movs	r0, #2
 8007e8a:	f7fd fdd1 	bl	8005a30 <_test_assert_sequence>
 8007e8e:	2800      	cmp	r0, #0
 8007e90:	d1f5      	bne.n	8007e7e <dyn1_execute+0x7e>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8007e92:	a902      	add	r1, sp, #8
 8007e94:	4810      	ldr	r0, [pc, #64]	; (8007ed8 <dyn1_execute+0xd8>)
 8007e96:	f7fa ff4b 	bl	8002d30 <chHeapStatus>
 8007e9a:	f1a0 0101 	sub.w	r1, r0, #1
 8007e9e:	fab1 f181 	clz	r1, r1
 8007ea2:	0949      	lsrs	r1, r1, #5
 8007ea4:	2003      	movs	r0, #3
 8007ea6:	f7fd fdab 	bl	8005a00 <_test_assert>
 8007eaa:	2800      	cmp	r0, #0
 8007eac:	d1e7      	bne.n	8007e7e <dyn1_execute+0x7e>
  test_assert(4, n == sz, "heap size changed");
 8007eae:	9902      	ldr	r1, [sp, #8]
 8007eb0:	9b03      	ldr	r3, [sp, #12]
 8007eb2:	1ac9      	subs	r1, r1, r3
 8007eb4:	fab1 f181 	clz	r1, r1
 8007eb8:	0949      	lsrs	r1, r1, #5
 8007eba:	2004      	movs	r0, #4
 8007ebc:	f7fd fda0 	bl	8005a00 <_test_assert>
 8007ec0:	e7dd      	b.n	8007e7e <dyn1_execute+0x7e>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 8007ec2:	68e3      	ldr	r3, [r4, #12]
 8007ec4:	2b00      	cmp	r3, #0
 8007ec6:	d1d6      	bne.n	8007e76 <dyn1_execute+0x76>
 8007ec8:	6921      	ldr	r1, [r4, #16]
 8007eca:	fab1 f181 	clz	r1, r1
 8007ece:	0949      	lsrs	r1, r1, #5
 8007ed0:	e7d1      	b.n	8007e76 <dyn1_execute+0x76>
 8007ed2:	bf00      	nop
 8007ed4:	20000e78 	.word	0x20000e78
 8007ed8:	20001a58 	.word	0x20001a58
 8007edc:	200019f8 	.word	0x200019f8
 8007ee0:	0800a9d8 	.word	0x0800a9d8
 8007ee4:	08007f01 	.word	0x08007f01
 8007ee8:	0800a9d4 	.word	0x0800a9d4
 8007eec:	0800a9d0 	.word	0x0800a9d0
 8007ef0:	0800ae20 	.word	0x0800ae20
	...

08007f00 <thread>:
 * one to fail.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8007f00:	7800      	ldrb	r0, [r0, #0]
 8007f02:	f7fd bd6d 	b.w	80059e0 <test_emit_token>
 8007f06:	bf00      	nop
	...

08007f10 <dyn3_setup>:
  return found;
}

static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 8007f10:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 8007f14:	4901      	ldr	r1, [pc, #4]	; (8007f1c <dyn3_setup+0xc>)
 8007f16:	4802      	ldr	r0, [pc, #8]	; (8007f20 <dyn3_setup+0x10>)
 8007f18:	f7fa be62 	b.w	8002be0 <chHeapObjectInit>
 8007f1c:	20001370 	.word	0x20001370
 8007f20:	20001a58 	.word	0x20001a58
	...

08007f30 <dyn1_setup>:
 8007f30:	f7ff bfee 	b.w	8007f10 <dyn3_setup>
	...

08007f40 <dyn2_execute>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007f40:	4b31      	ldr	r3, [pc, #196]	; (8008008 <dyn2_execute+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007f42:	699b      	ldr	r3, [r3, #24]
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 8007f44:	b570      	push	{r4, r5, r6, lr}
 8007f46:	4c31      	ldr	r4, [pc, #196]	; (800800c <dyn2_execute+0xcc>)
 8007f48:	689d      	ldr	r5, [r3, #8]
 8007f4a:	f104 0610 	add.w	r6, r4, #16
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);
 8007f4e:	f854 1b04 	ldr.w	r1, [r4], #4
 8007f52:	482f      	ldr	r0, [pc, #188]	; (8008010 <dyn2_execute+0xd0>)
 8007f54:	f7fa ff4c 	bl	8002df0 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8007f58:	42a6      	cmp	r6, r4
 8007f5a:	d1f8      	bne.n	8007f4e <dyn2_execute+0xe>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8007f5c:	4b2d      	ldr	r3, [pc, #180]	; (8008014 <dyn2_execute+0xd4>)
 8007f5e:	4a2e      	ldr	r2, [pc, #184]	; (8008018 <dyn2_execute+0xd8>)
 8007f60:	482b      	ldr	r0, [pc, #172]	; (8008010 <dyn2_execute+0xd0>)
 8007f62:	4c2e      	ldr	r4, [pc, #184]	; (800801c <dyn2_execute+0xdc>)
 8007f64:	1e69      	subs	r1, r5, #1
 8007f66:	f7f9 fe43 	bl	8001bf0 <chThdCreateFromMemoryPool>
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8007f6a:	4b2d      	ldr	r3, [pc, #180]	; (8008020 <dyn2_execute+0xe0>)
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8007f6c:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8007f6e:	4a2a      	ldr	r2, [pc, #168]	; (8008018 <dyn2_execute+0xd8>)
 8007f70:	4827      	ldr	r0, [pc, #156]	; (8008010 <dyn2_execute+0xd0>)
 8007f72:	1ea9      	subs	r1, r5, #2
 8007f74:	f7f9 fe3c 	bl	8001bf0 <chThdCreateFromMemoryPool>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8007f78:	4b2a      	ldr	r3, [pc, #168]	; (8008024 <dyn2_execute+0xe4>)
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8007f7a:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8007f7c:	4a26      	ldr	r2, [pc, #152]	; (8008018 <dyn2_execute+0xd8>)
 8007f7e:	4824      	ldr	r0, [pc, #144]	; (8008010 <dyn2_execute+0xd0>)
 8007f80:	1ee9      	subs	r1, r5, #3
 8007f82:	f7f9 fe35 	bl	8001bf0 <chThdCreateFromMemoryPool>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8007f86:	4b28      	ldr	r3, [pc, #160]	; (8008028 <dyn2_execute+0xe8>)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8007f88:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8007f8a:	4a23      	ldr	r2, [pc, #140]	; (8008018 <dyn2_execute+0xd8>)
 8007f8c:	4820      	ldr	r0, [pc, #128]	; (8008010 <dyn2_execute+0xd0>)
 8007f8e:	1f29      	subs	r1, r5, #4
 8007f90:	f7f9 fe2e 	bl	8001bf0 <chThdCreateFromMemoryPool>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8007f94:	1f69      	subs	r1, r5, #5

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8007f96:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8007f98:	4b24      	ldr	r3, [pc, #144]	; (800802c <dyn2_execute+0xec>)
 8007f9a:	4a1f      	ldr	r2, [pc, #124]	; (8008018 <dyn2_execute+0xd8>)
 8007f9c:	481c      	ldr	r0, [pc, #112]	; (8008010 <dyn2_execute+0xd0>)
 8007f9e:	f7f9 fe27 	bl	8001bf0 <chThdCreateFromMemoryPool>

  test_assert(1, (threads[0] != NULL) &&
 8007fa2:	6821      	ldr	r1, [r4, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8007fa4:	6120      	str	r0, [r4, #16]

  test_assert(1, (threads[0] != NULL) &&
 8007fa6:	b141      	cbz	r1, 8007fba <dyn2_execute+0x7a>
 8007fa8:	6861      	ldr	r1, [r4, #4]
 8007faa:	b131      	cbz	r1, 8007fba <dyn2_execute+0x7a>
 8007fac:	68a1      	ldr	r1, [r4, #8]
 8007fae:	b121      	cbz	r1, 8007fba <dyn2_execute+0x7a>
 8007fb0:	68e1      	ldr	r1, [r4, #12]
 8007fb2:	b111      	cbz	r1, 8007fba <dyn2_execute+0x7a>
 8007fb4:	fab0 f180 	clz	r1, r0
 8007fb8:	0949      	lsrs	r1, r1, #5
 8007fba:	2001      	movs	r0, #1
 8007fbc:	f7fd fd20 	bl	8005a00 <_test_assert>
 8007fc0:	b100      	cbz	r0, 8007fc4 <dyn2_execute+0x84>
 8007fc2:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8007fc4:	f7fd fd8c 	bl	8005ae0 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8007fc8:	4919      	ldr	r1, [pc, #100]	; (8008030 <dyn2_execute+0xf0>)
 8007fca:	2002      	movs	r0, #2
 8007fcc:	f7fd fd30 	bl	8005a30 <_test_assert_sequence>
 8007fd0:	2800      	cmp	r0, #0
 8007fd2:	d1f6      	bne.n	8007fc2 <dyn2_execute+0x82>
 8007fd4:	2404      	movs	r4, #4

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8007fd6:	480e      	ldr	r0, [pc, #56]	; (8008010 <dyn2_execute+0xd0>)
 8007fd8:	f7fa fef2 	bl	8002dc0 <chPoolAlloc>
 8007fdc:	1c01      	adds	r1, r0, #0
 8007fde:	bf18      	it	ne
 8007fe0:	2101      	movne	r1, #1
 8007fe2:	2003      	movs	r0, #3
 8007fe4:	f7fd fd0c 	bl	8005a00 <_test_assert>
 8007fe8:	2800      	cmp	r0, #0
 8007fea:	d1ea      	bne.n	8007fc2 <dyn2_execute+0x82>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8007fec:	3c01      	subs	r4, #1
 8007fee:	d1f2      	bne.n	8007fd6 <dyn2_execute+0x96>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8007ff0:	4807      	ldr	r0, [pc, #28]	; (8008010 <dyn2_execute+0xd0>)
 8007ff2:	f7fa fee5 	bl	8002dc0 <chPoolAlloc>
 8007ff6:	fab0 f180 	clz	r1, r0
 8007ffa:	0949      	lsrs	r1, r1, #5
 8007ffc:	2004      	movs	r0, #4
}
 8007ffe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8008002:	f7fd bcfd 	b.w	8005a00 <_test_assert>
 8008006:	bf00      	nop
 8008008:	20000e78 	.word	0x20000e78
 800800c:	0800a700 	.word	0x0800a700
 8008010:	20001a48 	.word	0x20001a48
 8008014:	0800a9d8 	.word	0x0800a9d8
 8008018:	08007f01 	.word	0x08007f01
 800801c:	200019f8 	.word	0x200019f8
 8008020:	0800a9d4 	.word	0x0800a9d4
 8008024:	0800a9d0 	.word	0x0800a9d0
 8008028:	0800b864 	.word	0x0800b864
 800802c:	0800a9e0 	.word	0x0800a9e0
 8008030:	0800ae24 	.word	0x0800ae24
	...

08008040 <dyn2_setup>:
 * one to fail.
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8008040:	2200      	movs	r2, #0
 8008042:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008046:	4801      	ldr	r0, [pc, #4]	; (800804c <dyn2_setup+0xc>)
 8008048:	f7fa be9a 	b.w	8002d80 <chPoolObjectInit>
 800804c:	20001a48 	.word	0x20001a48

08008050 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8008050:	b538      	push	{r3, r4, r5, lr}
 8008052:	4605      	mov	r5, r0
  thread_t *ftp;
  bool found = false;

  ftp = chRegFirstThread();
 8008054:	f7f9 fdf4 	bl	8001c40 <chRegFirstThread>
 * coverage.
 */

static bool regfind(thread_t *tp) {
  thread_t *ftp;
  bool found = false;
 8008058:	2400      	movs	r4, #0

  ftp = chRegFirstThread();
 800805a:	4603      	mov	r3, r0
  do {
    found |= ftp == tp;
    ftp = chRegNextThread(ftp);
 800805c:	4618      	mov	r0, r3
 800805e:	42ab      	cmp	r3, r5
 8008060:	bf08      	it	eq
 8008062:	f044 0401 	orreq.w	r4, r4, #1
 8008066:	f7f9 fdfb 	bl	8001c60 <chRegNextThread>
  } while (ftp != NULL);
 800806a:	4603      	mov	r3, r0
 800806c:	2800      	cmp	r0, #0
 800806e:	d1f5      	bne.n	800805c <regfind+0xc>
  return found;
}
 8008070:	4620      	mov	r0, r4
 8008072:	bd38      	pop	{r3, r4, r5, pc}
	...

08008080 <dyn3_execute>:
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 8008080:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008082:	4b48      	ldr	r3, [pc, #288]	; (80081a4 <dyn3_execute+0x124>)
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8008084:	4948      	ldr	r1, [pc, #288]	; (80081a8 <dyn3_execute+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008086:	699a      	ldr	r2, [r3, #24]
 8008088:	4848      	ldr	r0, [pc, #288]	; (80081ac <dyn3_execute+0x12c>)
 800808a:	6892      	ldr	r2, [r2, #8]
 800808c:	4b48      	ldr	r3, [pc, #288]	; (80081b0 <dyn3_execute+0x130>)
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 800808e:	b082      	sub	sp, #8
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8008090:	3a01      	subs	r2, #1
 8008092:	9100      	str	r1, [sp, #0]
 8008094:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008098:	f7f9 fd8a 	bl	8001bb0 <chThdCreateFromHeap>
 800809c:	4604      	mov	r4, r0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 800809e:	2001      	movs	r0, #1
 80080a0:	7fa1      	ldrb	r1, [r4, #30]
 80080a2:	1a09      	subs	r1, r1, r0
 80080a4:	fab1 f181 	clz	r1, r1
 80080a8:	0949      	lsrs	r1, r1, #5
 80080aa:	f7fd fca9 	bl	8005a00 <_test_assert>
 80080ae:	b108      	cbz	r0, 80080b4 <dyn3_execute+0x34>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
}
 80080b0:	b002      	add	sp, #8
 80080b2:	bd10      	pop	{r4, pc}
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
  chThdAddRef(tp);
 80080b4:	4620      	mov	r0, r4
 80080b6:	f7f9 fd43 	bl	8001b40 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 80080ba:	7fa1      	ldrb	r1, [r4, #30]
 80080bc:	2002      	movs	r0, #2
 80080be:	1a09      	subs	r1, r1, r0
 80080c0:	fab1 f181 	clz	r1, r1
 80080c4:	0949      	lsrs	r1, r1, #5
 80080c6:	f7fd fc9b 	bl	8005a00 <_test_assert>
 80080ca:	2800      	cmp	r0, #0
 80080cc:	d1f0      	bne.n	80080b0 <dyn3_execute+0x30>
  chThdRelease(tp);
 80080ce:	4620      	mov	r0, r4
 80080d0:	f7f9 fd46 	bl	8001b60 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 80080d4:	7fa1      	ldrb	r1, [r4, #30]
 80080d6:	f1a1 0101 	sub.w	r1, r1, #1
 80080da:	fab1 f181 	clz	r1, r1
 80080de:	2003      	movs	r0, #3
 80080e0:	0949      	lsrs	r1, r1, #5
 80080e2:	f7fd fc8d 	bl	8005a00 <_test_assert>
 80080e6:	2800      	cmp	r0, #0
 80080e8:	d1e2      	bne.n	80080b0 <dyn3_execute+0x30>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 80080ea:	4620      	mov	r0, r4
 80080ec:	f7ff ffb0 	bl	8008050 <regfind>
 80080f0:	4601      	mov	r1, r0
 80080f2:	2004      	movs	r0, #4
 80080f4:	f7fd fc84 	bl	8005a00 <_test_assert>
 80080f8:	2800      	cmp	r0, #0
 80080fa:	d1d9      	bne.n	80080b0 <dyn3_execute+0x30>
  test_assert(5, regfind(tp), "thread disappeared");
 80080fc:	4620      	mov	r0, r4
 80080fe:	f7ff ffa7 	bl	8008050 <regfind>
 8008102:	4601      	mov	r1, r0
 8008104:	2005      	movs	r0, #5
 8008106:	f7fd fc7b 	bl	8005a00 <_test_assert>
 800810a:	2800      	cmp	r0, #0
 800810c:	d1d0      	bne.n	80080b0 <dyn3_execute+0x30>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800810e:	4620      	mov	r0, r4
 8008110:	f7f9 fd26 	bl	8001b60 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 8008114:	7fa1      	ldrb	r1, [r4, #30]
 8008116:	fab1 f181 	clz	r1, r1
 800811a:	0949      	lsrs	r1, r1, #5
 800811c:	2006      	movs	r0, #6
 800811e:	f7fd fc6f 	bl	8005a00 <_test_assert>
 8008122:	2800      	cmp	r0, #0
 8008124:	d1c4      	bne.n	80080b0 <dyn3_execute+0x30>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 8008126:	7f21      	ldrb	r1, [r4, #28]
 8008128:	fab1 f181 	clz	r1, r1
 800812c:	0949      	lsrs	r1, r1, #5
 800812e:	2007      	movs	r0, #7
 8008130:	f7fd fc66 	bl	8005a00 <_test_assert>
 8008134:	2800      	cmp	r0, #0
 8008136:	d1bb      	bne.n	80080b0 <dyn3_execute+0x30>
  test_assert(8, regfind(tp), "thread disappeared");
 8008138:	4620      	mov	r0, r4
 800813a:	f7ff ff89 	bl	8008050 <regfind>
 800813e:	4601      	mov	r1, r0
 8008140:	2008      	movs	r0, #8
 8008142:	f7fd fc5d 	bl	8005a00 <_test_assert>
 8008146:	2800      	cmp	r0, #0
 8008148:	d1b2      	bne.n	80080b0 <dyn3_execute+0x30>
  test_assert(9, regfind(tp), "thread disappeared");
 800814a:	4620      	mov	r0, r4
 800814c:	f7ff ff80 	bl	8008050 <regfind>
 8008150:	4601      	mov	r1, r0
 8008152:	2009      	movs	r0, #9
 8008154:	f7fd fc54 	bl	8005a00 <_test_assert>
 8008158:	2800      	cmp	r0, #0
 800815a:	d1a9      	bne.n	80080b0 <dyn3_execute+0x30>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 800815c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8008160:	f7f9 fbbe 	bl	80018e0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8008164:	7f21      	ldrb	r1, [r4, #28]
 8008166:	f1a1 030f 	sub.w	r3, r1, #15
 800816a:	4259      	negs	r1, r3
 800816c:	4159      	adcs	r1, r3
 800816e:	200a      	movs	r0, #10
 8008170:	f7fd fc46 	bl	8005a00 <_test_assert>
 8008174:	2800      	cmp	r0, #0
 8008176:	d19b      	bne.n	80080b0 <dyn3_execute+0x30>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 8008178:	4620      	mov	r0, r4
 800817a:	f7ff ff69 	bl	8008050 <regfind>
 800817e:	4601      	mov	r1, r0
 8008180:	200b      	movs	r0, #11
 8008182:	f7fd fc3d 	bl	8005a00 <_test_assert>
 8008186:	2800      	cmp	r0, #0
 8008188:	d192      	bne.n	80080b0 <dyn3_execute+0x30>
  test_assert(12, !regfind(tp), "thread still in registry");
 800818a:	4620      	mov	r0, r4
 800818c:	f7ff ff60 	bl	8008050 <regfind>
 8008190:	f080 0101 	eor.w	r1, r0, #1
 8008194:	b2c9      	uxtb	r1, r1
 8008196:	200c      	movs	r0, #12
}
 8008198:	b002      	add	sp, #8
 800819a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
 800819e:	f7fd bc2f 	b.w	8005a00 <_test_assert>
 80081a2:	bf00      	nop
 80081a4:	20000e78 	.word	0x20000e78
 80081a8:	0800a9d8 	.word	0x0800a9d8
 80081ac:	20001a58 	.word	0x20001a58
 80081b0:	08007f01 	.word	0x08007f01
	...

080081c0 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 80081c0:	4770      	bx	lr
 80081c2:	bf00      	nop
	...

080081d0 <thread1>:
}

static THD_FUNCTION(thread1, p) {

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 80081d0:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80081d4:	4801      	ldr	r0, [pc, #4]	; (80081dc <thread1+0xc>)
 80081d6:	f7fa bb93 	b.w	8002900 <chIQGetTimeout>
 80081da:	bf00      	nop
 80081dc:	2000089c 	.word	0x2000089c

080081e0 <queues1_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 80081e0:	b500      	push	{lr}

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 80081e2:	4a06      	ldr	r2, [pc, #24]	; (80081fc <queues1_setup+0x1c>)
 80081e4:	4b06      	ldr	r3, [pc, #24]	; (8008200 <queues1_setup+0x20>)
 80081e6:	6811      	ldr	r1, [r2, #0]
 80081e8:	4806      	ldr	r0, [pc, #24]	; (8008204 <queues1_setup+0x24>)
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 80081ea:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 80081ec:	2200      	movs	r2, #0
 80081ee:	9200      	str	r2, [sp, #0]
 80081f0:	2204      	movs	r2, #4
 80081f2:	f7fa fb45 	bl	8002880 <chIQObjectInit>
}
 80081f6:	b003      	add	sp, #12
 80081f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80081fc:	0800a700 	.word	0x0800a700
 8008200:	080081c1 	.word	0x080081c1
 8008204:	2000089c 	.word	0x2000089c
	...

08008210 <thread2>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 8008210:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8008214:	2100      	movs	r1, #0
 8008216:	4801      	ldr	r0, [pc, #4]	; (800821c <thread2+0xc>)
 8008218:	f7fa bbfa 	b.w	8002a10 <chOQPutTimeout>
 800821c:	20000878 	.word	0x20000878

08008220 <queues2_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 8008220:	b500      	push	{lr}

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8008222:	4a06      	ldr	r2, [pc, #24]	; (800823c <queues2_setup+0x1c>)
 8008224:	4b06      	ldr	r3, [pc, #24]	; (8008240 <queues2_setup+0x20>)
 8008226:	6811      	ldr	r1, [r2, #0]
 8008228:	4806      	ldr	r0, [pc, #24]	; (8008244 <queues2_setup+0x24>)
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 800822a:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800822c:	2200      	movs	r2, #0
 800822e:	9200      	str	r2, [sp, #0]
 8008230:	2204      	movs	r2, #4
 8008232:	f7fa fbcd 	bl	80029d0 <chOQObjectInit>
}
 8008236:	b003      	add	sp, #12
 8008238:	f85d fb04 	ldr.w	pc, [sp], #4
 800823c:	0800a700 	.word	0x0800a700
 8008240:	080081c1 	.word	0x080081c1
 8008244:	20000878 	.word	0x20000878
	...

08008250 <queues1_execute>:

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
}

static void queues1_execute(void) {
 8008250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008254:	2420      	movs	r4, #32
 8008256:	b082      	sub	sp, #8
 8008258:	f384 8811 	msr	BASEPRI, r4
 800825c:	4b90      	ldr	r3, [pc, #576]	; (80084a0 <queues1_execute+0x250>)
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 800825e:	6899      	ldr	r1, [r3, #8]
 8008260:	fab1 f181 	clz	r1, r1
 8008264:	0949      	lsrs	r1, r1, #5
 8008266:	2001      	movs	r0, #1
 8008268:	f7fd fbca 	bl	8005a00 <_test_assert>
 800826c:	b9f0      	cbnz	r0, 80082ac <queues1_execute+0x5c>
 800826e:	4606      	mov	r6, r0
 8008270:	f380 8811 	msr	BASEPRI, r0
 8008274:	f384 8811 	msr	BASEPRI, r4
 8008278:	2441      	movs	r4, #65	; 0x41

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 800827a:	4d89      	ldr	r5, [pc, #548]	; (80084a0 <queues1_execute+0x250>)
 800827c:	4621      	mov	r1, r4
 800827e:	3401      	adds	r4, #1
 8008280:	4628      	mov	r0, r5
 8008282:	b2e4      	uxtb	r4, r4
 8008284:	f7fa fb1c 	bl	80028c0 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8008288:	2c45      	cmp	r4, #69	; 0x45
 800828a:	d1f6      	bne.n	800827a <queues1_execute+0x2a>
 800828c:	2300      	movs	r3, #0
 800828e:	f383 8811 	msr	BASEPRI, r3
 8008292:	2320      	movs	r3, #32
 8008294:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8008298:	696a      	ldr	r2, [r5, #20]
 800829a:	69ab      	ldr	r3, [r5, #24]
 800829c:	429a      	cmp	r2, r3
 800829e:	d03a      	beq.n	8008316 <queues1_execute+0xc6>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 80082a0:	4631      	mov	r1, r6
 80082a2:	2002      	movs	r0, #2
 80082a4:	f7fd fbac 	bl	8005a00 <_test_assert>
 80082a8:	4604      	mov	r4, r0
 80082aa:	b128      	cbz	r0, 80082b8 <queues1_execute+0x68>
 80082ac:	2300      	movs	r3, #0
 80082ae:	f383 8811 	msr	BASEPRI, r3
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 80082b2:	b002      	add	sp, #8
 80082b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80082b8:	f380 8811 	msr	BASEPRI, r0
 80082bc:	2320      	movs	r3, #32
 80082be:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 80082c2:	4877      	ldr	r0, [pc, #476]	; (80084a0 <queues1_execute+0x250>)
 80082c4:	4621      	mov	r1, r4
 80082c6:	f7fa fafb 	bl	80028c0 <chIQPutI>
 80082ca:	3004      	adds	r0, #4
 80082cc:	bf14      	ite	ne
 80082ce:	2100      	movne	r1, #0
 80082d0:	2101      	moveq	r1, #1
 80082d2:	2003      	movs	r0, #3
 80082d4:	f7fd fb94 	bl	8005a00 <_test_assert>
 80082d8:	b9c0      	cbnz	r0, 800830c <queues1_execute+0xbc>
 80082da:	f380 8811 	msr	BASEPRI, r0
 80082de:	2404      	movs	r4, #4
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 80082e0:	4d6f      	ldr	r5, [pc, #444]	; (80084a0 <queues1_execute+0x250>)
 80082e2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80082e6:	4628      	mov	r0, r5
 80082e8:	f7fa fb0a 	bl	8002900 <chIQGetTimeout>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 80082ec:	b2c0      	uxtb	r0, r0
 80082ee:	f7fd fb77 	bl	80059e0 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80082f2:	3c01      	subs	r4, #1
 80082f4:	d1f4      	bne.n	80082e0 <queues1_execute+0x90>
 80082f6:	2620      	movs	r6, #32
 80082f8:	f386 8811 	msr	BASEPRI, r6
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 80082fc:	68a9      	ldr	r1, [r5, #8]
 80082fe:	fab1 f181 	clz	r1, r1
 8008302:	0949      	lsrs	r1, r1, #5
 8008304:	2004      	movs	r0, #4
 8008306:	f7fd fb7b 	bl	8005a00 <_test_assert>
 800830a:	b148      	cbz	r0, 8008320 <queues1_execute+0xd0>
 800830c:	f384 8811 	msr	BASEPRI, r4
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8008310:	b002      	add	sp, #8
 8008312:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8008316:	68ae      	ldr	r6, [r5, #8]
 8008318:	3600      	adds	r6, #0
 800831a:	bf18      	it	ne
 800831c:	2601      	movne	r6, #1
 800831e:	e7bf      	b.n	80082a0 <queues1_execute+0x50>
 8008320:	f384 8811 	msr	BASEPRI, r4

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");
 8008324:	495f      	ldr	r1, [pc, #380]	; (80084a4 <queues1_execute+0x254>)
 8008326:	2005      	movs	r0, #5
 8008328:	f7fd fb82 	bl	8005a30 <_test_assert_sequence>
 800832c:	2800      	cmp	r0, #0
 800832e:	d1c0      	bne.n	80082b2 <queues1_execute+0x62>
 8008330:	f386 8811 	msr	BASEPRI, r6
 8008334:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8008336:	4d5a      	ldr	r5, [pc, #360]	; (80084a0 <queues1_execute+0x250>)
 8008338:	4621      	mov	r1, r4
 800833a:	3401      	adds	r4, #1
 800833c:	4628      	mov	r0, r5
 800833e:	b2e4      	uxtb	r4, r4
 8008340:	f7fa fabe 	bl	80028c0 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8008344:	2c45      	cmp	r4, #69	; 0x45
 8008346:	d1f6      	bne.n	8008336 <queues1_execute+0xe6>
 8008348:	2300      	movs	r3, #0
 800834a:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800834e:	4e56      	ldr	r6, [pc, #344]	; (80084a8 <queues1_execute+0x258>)
 8008350:	2208      	movs	r2, #8
 8008352:	6871      	ldr	r1, [r6, #4]
 8008354:	4628      	mov	r0, r5
 8008356:	f7fa fafb 	bl	8002950 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800835a:	f1a0 0104 	sub.w	r1, r0, #4
 800835e:	fab1 f181 	clz	r1, r1
 8008362:	0949      	lsrs	r1, r1, #5
 8008364:	2006      	movs	r0, #6
 8008366:	f7fd fb4b 	bl	8005a00 <_test_assert>
 800836a:	4604      	mov	r4, r0
 800836c:	2800      	cmp	r0, #0
 800836e:	d1a0      	bne.n	80082b2 <queues1_execute+0x62>
 8008370:	2720      	movs	r7, #32
 8008372:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 8008376:	68a9      	ldr	r1, [r5, #8]
 8008378:	fab1 f181 	clz	r1, r1
 800837c:	0949      	lsrs	r1, r1, #5
 800837e:	2007      	movs	r0, #7
 8008380:	f7fd fb3e 	bl	8005a00 <_test_assert>
 8008384:	2800      	cmp	r0, #0
 8008386:	d1c1      	bne.n	800830c <queues1_execute+0xbc>
 8008388:	f380 8811 	msr	BASEPRI, r0
 800838c:	f387 8811 	msr	BASEPRI, r7
 8008390:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8008392:	4d43      	ldr	r5, [pc, #268]	; (80084a0 <queues1_execute+0x250>)
 8008394:	4621      	mov	r1, r4
 8008396:	3401      	adds	r4, #1
 8008398:	4628      	mov	r0, r5
 800839a:	b2e4      	uxtb	r4, r4
 800839c:	f7fa fa90 	bl	80028c0 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80083a0:	2c45      	cmp	r4, #69	; 0x45
 80083a2:	d1f6      	bne.n	8008392 <queues1_execute+0x142>
 80083a4:	2300      	movs	r3, #0
 80083a6:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80083aa:	6874      	ldr	r4, [r6, #4]
 80083ac:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 80084a8 <queues1_execute+0x258>
 80083b0:	4621      	mov	r1, r4
 80083b2:	4628      	mov	r0, r5
 80083b4:	2202      	movs	r2, #2
 80083b6:	f7fa facb 	bl	8002950 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80083ba:	f1a0 0102 	sub.w	r1, r0, #2
 80083be:	fab1 f181 	clz	r1, r1
 80083c2:	0949      	lsrs	r1, r1, #5
 80083c4:	2008      	movs	r0, #8
 80083c6:	f7fd fb1b 	bl	8005a00 <_test_assert>
 80083ca:	2800      	cmp	r0, #0
 80083cc:	f47f af71 	bne.w	80082b2 <queues1_execute+0x62>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80083d0:	4603      	mov	r3, r0
 80083d2:	4621      	mov	r1, r4
 80083d4:	2202      	movs	r2, #2
 80083d6:	4628      	mov	r0, r5
 80083d8:	f7fa faba 	bl	8002950 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80083dc:	f1a0 0102 	sub.w	r1, r0, #2
 80083e0:	fab1 f181 	clz	r1, r1
 80083e4:	0949      	lsrs	r1, r1, #5
 80083e6:	2009      	movs	r0, #9
 80083e8:	f7fd fb0a 	bl	8005a00 <_test_assert>
 80083ec:	4606      	mov	r6, r0
 80083ee:	2800      	cmp	r0, #0
 80083f0:	f47f af5f 	bne.w	80082b2 <queues1_execute+0x62>
 80083f4:	2720      	movs	r7, #32
 80083f6:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 80083fa:	68a9      	ldr	r1, [r5, #8]
 80083fc:	fab1 f181 	clz	r1, r1
 8008400:	0949      	lsrs	r1, r1, #5
 8008402:	200a      	movs	r0, #10
 8008404:	f7fd fafc 	bl	8005a00 <_test_assert>
 8008408:	4604      	mov	r4, r0
 800840a:	b110      	cbz	r0, 8008412 <queues1_execute+0x1c2>
 800840c:	f386 8811 	msr	BASEPRI, r6
 8008410:	e74f      	b.n	80082b2 <queues1_execute+0x62>
 8008412:	f380 8811 	msr	BASEPRI, r0
 8008416:	f387 8811 	msr	BASEPRI, r7

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 800841a:	4601      	mov	r1, r0
 800841c:	4628      	mov	r0, r5
 800841e:	f7fa fa4f 	bl	80028c0 <chIQPutI>
  chIQResetI(&iq);
 8008422:	4628      	mov	r0, r5
 8008424:	f7fa fa3c 	bl	80028a0 <chIQResetI>
 8008428:	f384 8811 	msr	BASEPRI, r4
 800842c:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 8008430:	68a9      	ldr	r1, [r5, #8]
 8008432:	fab1 f181 	clz	r1, r1
 8008436:	0949      	lsrs	r1, r1, #5
 8008438:	200b      	movs	r0, #11
 800843a:	f7fd fae1 	bl	8005a00 <_test_assert>
 800843e:	4606      	mov	r6, r0
 8008440:	2800      	cmp	r0, #0
 8008442:	f47f af63 	bne.w	800830c <queues1_execute+0xbc>
 8008446:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800844a:	4b18      	ldr	r3, [pc, #96]	; (80084ac <queues1_execute+0x25c>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 800844c:	f8d8 0000 	ldr.w	r0, [r8]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008450:	699a      	ldr	r2, [r3, #24]
 8008452:	4b17      	ldr	r3, [pc, #92]	; (80084b0 <queues1_execute+0x260>)
 8008454:	6892      	ldr	r2, [r2, #8]
 8008456:	9600      	str	r6, [sp, #0]
 8008458:	3201      	adds	r2, #1
 800845a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800845e:	f7f9 f9cf 	bl	8001800 <chThdCreateStatic>
 8008462:	4b14      	ldr	r3, [pc, #80]	; (80084b4 <queues1_execute+0x264>)
 8008464:	6018      	str	r0, [r3, #0]
 8008466:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 800846a:	68a9      	ldr	r1, [r5, #8]
 800846c:	fab1 f181 	clz	r1, r1
 8008470:	0949      	lsrs	r1, r1, #5
 8008472:	200c      	movs	r0, #12
 8008474:	f7fd fac4 	bl	8005a00 <_test_assert>
 8008478:	2800      	cmp	r0, #0
 800847a:	d1c7      	bne.n	800840c <queues1_execute+0x1bc>
 800847c:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 8008480:	f7fd fb2e 	bl	8005ae0 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8008484:	4628      	mov	r0, r5
 8008486:	210a      	movs	r1, #10
 8008488:	f7fa fa3a 	bl	8002900 <chIQGetTimeout>
 800848c:	1c43      	adds	r3, r0, #1
 800848e:	4259      	negs	r1, r3
 8008490:	4159      	adcs	r1, r3
 8008492:	200d      	movs	r0, #13
}
 8008494:	b002      	add	sp, #8
 8008496:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800849a:	f7fd bab1 	b.w	8005a00 <_test_assert>
 800849e:	bf00      	nop
 80084a0:	2000089c 	.word	0x2000089c
 80084a4:	0800ae24 	.word	0x0800ae24
 80084a8:	0800a700 	.word	0x0800a700
 80084ac:	20000e78 	.word	0x20000e78
 80084b0:	080081d1 	.word	0x080081d1
 80084b4:	200019f8 	.word	0x200019f8
	...

080084c0 <queues2_execute>:

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
}

static void queues2_execute(void) {
 80084c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80084c4:	2320      	movs	r3, #32
 80084c6:	b083      	sub	sp, #12
 80084c8:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80084cc:	4b85      	ldr	r3, [pc, #532]	; (80086e4 <queues2_execute+0x224>)
 80084ce:	6999      	ldr	r1, [r3, #24]
 80084d0:	695a      	ldr	r2, [r3, #20]
 80084d2:	4291      	cmp	r1, r2
 80084d4:	d05d      	beq.n	8008592 <queues2_execute+0xd2>
 80084d6:	2100      	movs	r1, #0
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 80084d8:	2001      	movs	r0, #1
 80084da:	f7fd fa91 	bl	8005a00 <_test_assert>
 80084de:	bbb8      	cbnz	r0, 8008550 <queues2_execute+0x90>
 80084e0:	f380 8811 	msr	BASEPRI, r0
 80084e4:	2441      	movs	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 80084e6:	4d7f      	ldr	r5, [pc, #508]	; (80086e4 <queues2_execute+0x224>)
 80084e8:	4621      	mov	r1, r4
 80084ea:	3401      	adds	r4, #1
 80084ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80084f0:	4628      	mov	r0, r5
 80084f2:	b2e4      	uxtb	r4, r4
 80084f4:	f7fa fa8c 	bl	8002a10 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80084f8:	2c45      	cmp	r4, #69	; 0x45
 80084fa:	d1f4      	bne.n	80084e6 <queues2_execute+0x26>
 80084fc:	2620      	movs	r6, #32
 80084fe:	f386 8811 	msr	BASEPRI, r6
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 8008502:	68a9      	ldr	r1, [r5, #8]
 8008504:	fab1 f181 	clz	r1, r1
 8008508:	0949      	lsrs	r1, r1, #5
 800850a:	2002      	movs	r0, #2
 800850c:	f7fd fa78 	bl	8005a00 <_test_assert>
 8008510:	4607      	mov	r7, r0
 8008512:	b9e8      	cbnz	r0, 8008550 <queues2_execute+0x90>
 8008514:	f380 8811 	msr	BASEPRI, r0
 8008518:	2404      	movs	r4, #4
 800851a:	4681      	mov	r9, r0
 800851c:	f04f 0820 	mov.w	r8, #32
 8008520:	f386 8811 	msr	BASEPRI, r6
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 8008524:	4d6f      	ldr	r5, [pc, #444]	; (80086e4 <queues2_execute+0x224>)
 8008526:	4628      	mov	r0, r5
 8008528:	f7fa fa9a 	bl	8002a60 <chOQGetI>
 800852c:	f389 8811 	msr	BASEPRI, r9
    chSysUnlock();
    test_emit_token(c);
 8008530:	b2c0      	uxtb	r0, r0
 8008532:	f7fd fa55 	bl	80059e0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 8008536:	3c01      	subs	r4, #1
 8008538:	d1f0      	bne.n	800851c <queues2_execute+0x5c>
 800853a:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800853e:	696a      	ldr	r2, [r5, #20]
 8008540:	69ab      	ldr	r3, [r5, #24]
 8008542:	429a      	cmp	r2, r3
 8008544:	d02a      	beq.n	800859c <queues2_execute+0xdc>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 8008546:	4639      	mov	r1, r7
 8008548:	2003      	movs	r0, #3
 800854a:	f7fd fa59 	bl	8005a00 <_test_assert>
 800854e:	b128      	cbz	r0, 800855c <queues2_execute+0x9c>
 8008550:	2300      	movs	r3, #0
 8008552:	f383 8811 	msr	BASEPRI, r3
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8008556:	b003      	add	sp, #12
 8008558:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800855c:	f380 8811 	msr	BASEPRI, r0
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
 8008560:	4961      	ldr	r1, [pc, #388]	; (80086e8 <queues2_execute+0x228>)
 8008562:	2004      	movs	r0, #4
 8008564:	f7fd fa64 	bl	8005a30 <_test_assert_sequence>
 8008568:	4604      	mov	r4, r0
 800856a:	2800      	cmp	r0, #0
 800856c:	d1f3      	bne.n	8008556 <queues2_execute+0x96>
 800856e:	2620      	movs	r6, #32
 8008570:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8008574:	4d5b      	ldr	r5, [pc, #364]	; (80086e4 <queues2_execute+0x224>)
 8008576:	4628      	mov	r0, r5
 8008578:	f7fa fa72 	bl	8002a60 <chOQGetI>
 800857c:	3003      	adds	r0, #3
 800857e:	bf14      	ite	ne
 8008580:	2100      	movne	r1, #0
 8008582:	2101      	moveq	r1, #1
 8008584:	2005      	movs	r0, #5
 8008586:	f7fd fa3b 	bl	8005a00 <_test_assert>
 800858a:	b160      	cbz	r0, 80085a6 <queues2_execute+0xe6>
 800858c:	f384 8811 	msr	BASEPRI, r4
 8008590:	e7e1      	b.n	8008556 <queues2_execute+0x96>
 8008592:	6899      	ldr	r1, [r3, #8]
 8008594:	3100      	adds	r1, #0
 8008596:	bf18      	it	ne
 8008598:	2101      	movne	r1, #1
 800859a:	e79d      	b.n	80084d8 <queues2_execute+0x18>
 800859c:	68af      	ldr	r7, [r5, #8]
 800859e:	3700      	adds	r7, #0
 80085a0:	bf18      	it	ne
 80085a2:	2701      	movne	r7, #1
 80085a4:	e7cf      	b.n	8008546 <queues2_execute+0x86>
 80085a6:	f380 8811 	msr	BASEPRI, r0

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 80085aa:	4f50      	ldr	r7, [pc, #320]	; (80086ec <queues2_execute+0x22c>)
 80085ac:	687c      	ldr	r4, [r7, #4]
 80085ae:	4603      	mov	r3, r0
 80085b0:	4621      	mov	r1, r4
 80085b2:	2208      	movs	r2, #8
 80085b4:	4628      	mov	r0, r5
 80085b6:	f7fa fa73 	bl	8002aa0 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 80085ba:	f1a0 0104 	sub.w	r1, r0, #4
 80085be:	fab1 f181 	clz	r1, r1
 80085c2:	0949      	lsrs	r1, r1, #5
 80085c4:	2006      	movs	r0, #6
 80085c6:	f7fd fa1b 	bl	8005a00 <_test_assert>
 80085ca:	4680      	mov	r8, r0
 80085cc:	2800      	cmp	r0, #0
 80085ce:	d1c2      	bne.n	8008556 <queues2_execute+0x96>
 80085d0:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 80085d4:	68a9      	ldr	r1, [r5, #8]
 80085d6:	fab1 f181 	clz	r1, r1
 80085da:	0949      	lsrs	r1, r1, #5
 80085dc:	2007      	movs	r0, #7
 80085de:	f7fd fa0f 	bl	8005a00 <_test_assert>
 80085e2:	4681      	mov	r9, r0
 80085e4:	b110      	cbz	r0, 80085ec <queues2_execute+0x12c>
 80085e6:	f388 8811 	msr	BASEPRI, r8
 80085ea:	e7b4      	b.n	8008556 <queues2_execute+0x96>
 80085ec:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80085f0:	4b3f      	ldr	r3, [pc, #252]	; (80086f0 <queues2_execute+0x230>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80085f2:	6838      	ldr	r0, [r7, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80085f4:	699a      	ldr	r2, [r3, #24]
 80085f6:	4b3f      	ldr	r3, [pc, #252]	; (80086f4 <queues2_execute+0x234>)
 80085f8:	6892      	ldr	r2, [r2, #8]
 80085fa:	f8cd 9000 	str.w	r9, [sp]
 80085fe:	3201      	adds	r2, #1
 8008600:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008604:	f7f9 f8fc 	bl	8001800 <chThdCreateStatic>
 8008608:	4b3b      	ldr	r3, [pc, #236]	; (80086f8 <queues2_execute+0x238>)
 800860a:	6018      	str	r0, [r3, #0]
 800860c:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 8008610:	68e9      	ldr	r1, [r5, #12]
 8008612:	692b      	ldr	r3, [r5, #16]
 8008614:	68aa      	ldr	r2, [r5, #8]
 8008616:	1a5b      	subs	r3, r3, r1
 8008618:	1a99      	subs	r1, r3, r2
 800861a:	f1a1 0104 	sub.w	r1, r1, #4
 800861e:	fab1 f181 	clz	r1, r1
 8008622:	0949      	lsrs	r1, r1, #5
 8008624:	2008      	movs	r0, #8
 8008626:	f7fd f9eb 	bl	8005a00 <_test_assert>
 800862a:	4607      	mov	r7, r0
 800862c:	b110      	cbz	r0, 8008634 <queues2_execute+0x174>
 800862e:	f389 8811 	msr	BASEPRI, r9
 8008632:	e790      	b.n	8008556 <queues2_execute+0x96>
 8008634:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 8008638:	f7fd fa52 	bl	8005ae0 <test_wait_threads>
 800863c:	f386 8811 	msr	BASEPRI, r6

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
 8008640:	4628      	mov	r0, r5
 8008642:	f7fa f9d5 	bl	80029f0 <chOQResetI>
 8008646:	f387 8811 	msr	BASEPRI, r7
 800864a:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 800864e:	f105 0108 	add.w	r1, r5, #8
 8008652:	c90e      	ldmia	r1, {r1, r2, r3}
 8008654:	1a9b      	subs	r3, r3, r2
 8008656:	1a59      	subs	r1, r3, r1
 8008658:	fab1 f181 	clz	r1, r1
 800865c:	0949      	lsrs	r1, r1, #5
 800865e:	2009      	movs	r0, #9
 8008660:	f7fd f9ce 	bl	8005a00 <_test_assert>
 8008664:	4603      	mov	r3, r0
 8008666:	b110      	cbz	r0, 800866e <queues2_execute+0x1ae>
 8008668:	f387 8811 	msr	BASEPRI, r7
 800866c:	e773      	b.n	8008556 <queues2_execute+0x96>
 800866e:	f380 8811 	msr	BASEPRI, r0

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8008672:	2202      	movs	r2, #2
 8008674:	4621      	mov	r1, r4
 8008676:	4628      	mov	r0, r5
 8008678:	f7fa fa12 	bl	8002aa0 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800867c:	3802      	subs	r0, #2
 800867e:	4241      	negs	r1, r0
 8008680:	4141      	adcs	r1, r0
 8008682:	200a      	movs	r0, #10
 8008684:	f7fd f9bc 	bl	8005a00 <_test_assert>
 8008688:	4603      	mov	r3, r0
 800868a:	2800      	cmp	r0, #0
 800868c:	f47f af63 	bne.w	8008556 <queues2_execute+0x96>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8008690:	4621      	mov	r1, r4
 8008692:	2202      	movs	r2, #2
 8008694:	4628      	mov	r0, r5
 8008696:	f7fa fa03 	bl	8002aa0 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800869a:	1e82      	subs	r2, r0, #2
 800869c:	4251      	negs	r1, r2
 800869e:	4151      	adcs	r1, r2
 80086a0:	200b      	movs	r0, #11
 80086a2:	f7fd f9ad 	bl	8005a00 <_test_assert>
 80086a6:	2800      	cmp	r0, #0
 80086a8:	f47f af55 	bne.w	8008556 <queues2_execute+0x96>
 80086ac:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 80086b0:	68a9      	ldr	r1, [r5, #8]
 80086b2:	fab1 f181 	clz	r1, r1
 80086b6:	0949      	lsrs	r1, r1, #5
 80086b8:	200c      	movs	r0, #12
 80086ba:	f7fd f9a1 	bl	8005a00 <_test_assert>
 80086be:	2800      	cmp	r0, #0
 80086c0:	f47f af46 	bne.w	8008550 <queues2_execute+0x90>
 80086c4:	2100      	movs	r1, #0
 80086c6:	f381 8811 	msr	BASEPRI, r1

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 80086ca:	220a      	movs	r2, #10
 80086cc:	4805      	ldr	r0, [pc, #20]	; (80086e4 <queues2_execute+0x224>)
 80086ce:	f7fa f99f 	bl	8002a10 <chOQPutTimeout>
 80086d2:	1c43      	adds	r3, r0, #1
 80086d4:	4259      	negs	r1, r3
 80086d6:	4159      	adcs	r1, r3
 80086d8:	200d      	movs	r0, #13
}
 80086da:	b003      	add	sp, #12
 80086dc:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 80086e0:	f7fd b98e 	b.w	8005a00 <_test_assert>
 80086e4:	20000878 	.word	0x20000878
 80086e8:	0800ae24 	.word	0x0800ae24
 80086ec:	0800a700 	.word	0x0800a700
 80086f0:	20000e78 	.word	0x20000e78
 80086f4:	08008211 	.word	0x08008211
 80086f8:	200019f8 	.word	0x200019f8
 80086fc:	00000000 	.word	0x00000000

08008700 <sys2_execute>:
 8008700:	2320      	movs	r3, #32
 8008702:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8008706:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8008708:	b672      	cpsid	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800870a:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800870e:	b662      	cpsie	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008710:	2300      	movs	r3, #0
 8008712:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8008716:	b662      	cpsie	i
 8008718:	4770      	bx	lr
 800871a:	bf00      	nop
 800871c:	0000      	movs	r0, r0
	...

08008720 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 8008720:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008722:	2320      	movs	r3, #32
 8008724:	f383 8811 	msr	BASEPRI, r3
 8008728:	2400      	movs	r4, #0
 800872a:	f384 8811 	msr	BASEPRI, r4
 800872e:	f383 8811 	msr	BASEPRI, r3
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 8008732:	f7f8 fe25 	bl	8001380 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 8008736:	f7f8 fe33 	bl	80013a0 <chSysRestoreStatusX>
 800873a:	f384 8811 	msr	BASEPRI, r4
 800873e:	bd10      	pop	{r4, pc}

08008740 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 8008740:	b538      	push	{r3, r4, r5, lr}
 8008742:	2420      	movs	r4, #32
 8008744:	f384 8811 	msr	BASEPRI, r4
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8008748:	2001      	movs	r0, #1
 800874a:	f7f8 fd79 	bl	8001240 <chSysIntegrityCheckI>
 800874e:	2300      	movs	r3, #0
 8008750:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
 8008754:	f080 0101 	eor.w	r1, r0, #1
 8008758:	b2c9      	uxtb	r1, r1
 800875a:	2001      	movs	r0, #1
 800875c:	f7fd f950 	bl	8005a00 <_test_assert>
 8008760:	b100      	cbz	r0, 8008764 <sys3_execute+0x24>
 8008762:	bd38      	pop	{r3, r4, r5, pc}
 8008764:	4605      	mov	r5, r0
 8008766:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 800876a:	2002      	movs	r0, #2
 800876c:	f7f8 fd68 	bl	8001240 <chSysIntegrityCheckI>
 8008770:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
 8008774:	f080 0101 	eor.w	r1, r0, #1
 8008778:	b2c9      	uxtb	r1, r1
 800877a:	2002      	movs	r0, #2
 800877c:	f7fd f940 	bl	8005a00 <_test_assert>
 8008780:	4605      	mov	r5, r0
 8008782:	2800      	cmp	r0, #0
 8008784:	d1ed      	bne.n	8008762 <sys3_execute+0x22>
 8008786:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 800878a:	2004      	movs	r0, #4
 800878c:	f7f8 fd58 	bl	8001240 <chSysIntegrityCheckI>
 8008790:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
 8008794:	f080 0101 	eor.w	r1, r0, #1
 8008798:	b2c9      	uxtb	r1, r1
 800879a:	2003      	movs	r0, #3
 800879c:	f7fd f930 	bl	8005a00 <_test_assert>
 80087a0:	4605      	mov	r5, r0
 80087a2:	2800      	cmp	r0, #0
 80087a4:	d1dd      	bne.n	8008762 <sys3_execute+0x22>
 80087a6:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80087aa:	2008      	movs	r0, #8
 80087ac:	f7f8 fd48 	bl	8001240 <chSysIntegrityCheckI>
 80087b0:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 80087b4:	f080 0101 	eor.w	r1, r0, #1
 80087b8:	b2c9      	uxtb	r1, r1
 80087ba:	2004      	movs	r0, #4
}
 80087bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  test_assert(3, result == false, "registry list check failed");

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 80087c0:	f7fd b91e 	b.w	8005a00 <_test_assert>
	...

080087d0 <sys1_execute>:
  sts = chSysGetStatusAndLockX();
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}

static void sys1_execute(void) {
 80087d0:	b510      	push	{r4, lr}
 80087d2:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 80087d4:	f7f8 fdd4 	bl	8001380 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 80087d8:	f7f8 fde2 	bl	80013a0 <chSysRestoreStatusX>
 80087dc:	2420      	movs	r4, #32
 80087de:	f384 8811 	msr	BASEPRI, r4

  /* Reentrant case.*/
  chSysLock();
  sts = chSysGetStatusAndLockX();
 80087e2:	f7f8 fdcd 	bl	8001380 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 80087e6:	f7f8 fddb 	bl	80013a0 <chSysRestoreStatusX>
 80087ea:	2300      	movs	r3, #0
 80087ec:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 80087f0:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 80087f4:	b90b      	cbnz	r3, 80087fa <sys1_execute+0x2a>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80087f6:	f384 8811 	msr	BASEPRI, r4
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 80087fa:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 80087fe:	b913      	cbnz	r3, 8008806 <sys1_execute+0x36>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008800:	2320      	movs	r3, #32
 8008802:	f383 8811 	msr	BASEPRI, r3
 8008806:	2300      	movs	r3, #0
 8008808:	f383 8811 	msr	BASEPRI, r3
 800880c:	2220      	movs	r2, #32
 800880e:	f382 8811 	msr	BASEPRI, r2
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 8008812:	f3ef 8212 	mrs	r2, BASEPRI_MAX
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8008816:	b10a      	cbz	r2, 800881c <sys1_execute+0x4c>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008818:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 800881c:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 8008820:	b113      	cbz	r3, 8008828 <sys1_execute+0x58>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008822:	2300      	movs	r3, #0
 8008824:	f383 8811 	msr	BASEPRI, r3
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 8008828:	2300      	movs	r3, #0
 800882a:	9304      	str	r3, [sp, #16]
 800882c:	2320      	movs	r3, #32
 800882e:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8008832:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8008834:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8008836:	b113      	cbz	r3, 800883e <sys1_execute+0x6e>
    chVTDoResetI(vtp);
 8008838:	4620      	mov	r0, r4
 800883a:	f7f8 fe21 	bl	8001480 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800883e:	4620      	mov	r0, r4
 8008840:	2300      	movs	r3, #0
 8008842:	4a0c      	ldr	r2, [pc, #48]	; (8008874 <sys1_execute+0xa4>)
 8008844:	2101      	movs	r1, #1
 8008846:	f7f8 fddb 	bl	8001400 <chVTDoSetI>
 800884a:	2400      	movs	r4, #0
 800884c:	f384 8811 	msr	BASEPRI, r4
  chSysUnconditionalUnlock();

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
  chVTSet(&vt, 1, vtcb, NULL);
  chThdSleep(10);
 8008850:	200a      	movs	r0, #10
 8008852:	f7f9 f845 	bl	80018e0 <chThdSleep>
 8008856:	2320      	movs	r3, #32
 8008858:	f383 8811 	msr	BASEPRI, r3
 800885c:	9904      	ldr	r1, [sp, #16]
 800885e:	f384 8811 	msr	BASEPRI, r4

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8008862:	fab1 f181 	clz	r1, r1
 8008866:	0949      	lsrs	r1, r1, #5
 8008868:	2001      	movs	r0, #1
 800886a:	f7fd f8c9 	bl	8005a00 <_test_assert>
}
 800886e:	b006      	add	sp, #24
 8008870:	bd10      	pop	{r4, pc}
 8008872:	bf00      	nop
 8008874:	08008721 	.word	0x08008721
	...

08008880 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8008880:	4770      	bx	lr
 8008882:	bf00      	nop
	...

08008890 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8008890:	b510      	push	{r4, lr}

  test_print("--- System: ");
 8008892:	482f      	ldr	r0, [pc, #188]	; (8008950 <bmk13_execute+0xc0>)
  test_printn(sizeof(ch_system_t));
  test_println(" bytes");
 8008894:	4c2f      	ldr	r4, [pc, #188]	; (8008954 <bmk13_execute+0xc4>)
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {

  test_print("--- System: ");
 8008896:	f7fd f86b 	bl	8005970 <test_print>
  test_printn(sizeof(ch_system_t));
 800889a:	f44f 70a8 	mov.w	r0, #336	; 0x150
 800889e:	f7fd f837 	bl	8005910 <test_printn>
  test_println(" bytes");
 80088a2:	4620      	mov	r0, r4
 80088a4:	f7fd f87c 	bl	80059a0 <test_println>
  test_print("--- Thread: ");
 80088a8:	482b      	ldr	r0, [pc, #172]	; (8008958 <bmk13_execute+0xc8>)
 80088aa:	f7fd f861 	bl	8005970 <test_print>
  test_printn(sizeof(thread_t));
 80088ae:	2044      	movs	r0, #68	; 0x44
 80088b0:	f7fd f82e 	bl	8005910 <test_printn>
  test_println(" bytes");
 80088b4:	4620      	mov	r0, r4
 80088b6:	f7fd f873 	bl	80059a0 <test_println>
  test_print("--- Timer : ");
 80088ba:	4828      	ldr	r0, [pc, #160]	; (800895c <bmk13_execute+0xcc>)
 80088bc:	f7fd f858 	bl	8005970 <test_print>
  test_printn(sizeof(virtual_timer_t));
 80088c0:	2014      	movs	r0, #20
 80088c2:	f7fd f825 	bl	8005910 <test_printn>
  test_println(" bytes");
 80088c6:	4620      	mov	r0, r4
 80088c8:	f7fd f86a 	bl	80059a0 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 80088cc:	4824      	ldr	r0, [pc, #144]	; (8008960 <bmk13_execute+0xd0>)
 80088ce:	f7fd f84f 	bl	8005970 <test_print>
  test_printn(sizeof(semaphore_t));
 80088d2:	200c      	movs	r0, #12
 80088d4:	f7fd f81c 	bl	8005910 <test_printn>
  test_println(" bytes");
 80088d8:	4620      	mov	r0, r4
 80088da:	f7fd f861 	bl	80059a0 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 80088de:	4821      	ldr	r0, [pc, #132]	; (8008964 <bmk13_execute+0xd4>)
 80088e0:	f7fd f846 	bl	8005970 <test_print>
  test_printn(sizeof(event_source_t));
 80088e4:	2004      	movs	r0, #4
 80088e6:	f7fd f813 	bl	8005910 <test_printn>
  test_println(" bytes");
 80088ea:	4620      	mov	r0, r4
 80088ec:	f7fd f858 	bl	80059a0 <test_println>
  test_print("--- EventL: ");
 80088f0:	481d      	ldr	r0, [pc, #116]	; (8008968 <bmk13_execute+0xd8>)
 80088f2:	f7fd f83d 	bl	8005970 <test_print>
  test_printn(sizeof(event_listener_t));
 80088f6:	2014      	movs	r0, #20
 80088f8:	f7fd f80a 	bl	8005910 <test_printn>
  test_println(" bytes");
 80088fc:	4620      	mov	r0, r4
 80088fe:	f7fd f84f 	bl	80059a0 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8008902:	481a      	ldr	r0, [pc, #104]	; (800896c <bmk13_execute+0xdc>)
 8008904:	f7fd f834 	bl	8005970 <test_print>
  test_printn(sizeof(mutex_t));
 8008908:	2010      	movs	r0, #16
 800890a:	f7fd f801 	bl	8005910 <test_printn>
  test_println(" bytes");
 800890e:	4620      	mov	r0, r4
 8008910:	f7fd f846 	bl	80059a0 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8008914:	4816      	ldr	r0, [pc, #88]	; (8008970 <bmk13_execute+0xe0>)
 8008916:	f7fd f82b 	bl	8005970 <test_print>
  test_printn(sizeof(condition_variable_t));
 800891a:	2008      	movs	r0, #8
 800891c:	f7fc fff8 	bl	8005910 <test_printn>
  test_println(" bytes");
 8008920:	4620      	mov	r0, r4
 8008922:	f7fd f83d 	bl	80059a0 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8008926:	4813      	ldr	r0, [pc, #76]	; (8008974 <bmk13_execute+0xe4>)
 8008928:	f7fd f822 	bl	8005970 <test_print>
  test_printn(sizeof(io_queue_t));
 800892c:	2024      	movs	r0, #36	; 0x24
 800892e:	f7fc ffef 	bl	8005910 <test_printn>
  test_println(" bytes");
 8008932:	4620      	mov	r0, r4
 8008934:	f7fd f834 	bl	80059a0 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8008938:	480f      	ldr	r0, [pc, #60]	; (8008978 <bmk13_execute+0xe8>)
 800893a:	f7fd f819 	bl	8005970 <test_print>
  test_printn(sizeof(mailbox_t));
 800893e:	2028      	movs	r0, #40	; 0x28
 8008940:	f7fc ffe6 	bl	8005910 <test_printn>
  test_println(" bytes");
 8008944:	4620      	mov	r0, r4
#endif
}
 8008946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_println(" bytes");
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
  test_printn(sizeof(mailbox_t));
  test_println(" bytes");
 800894a:	f7fd b829 	b.w	80059a0 <test_println>
 800894e:	bf00      	nop
 8008950:	0800b060 	.word	0x0800b060
 8008954:	0800b070 	.word	0x0800b070
 8008958:	0800b078 	.word	0x0800b078
 800895c:	0800b088 	.word	0x0800b088
 8008960:	0800b098 	.word	0x0800b098
 8008964:	0800b0a8 	.word	0x0800b0a8
 8008968:	0800b0b8 	.word	0x0800b0b8
 800896c:	0800b0c8 	.word	0x0800b0c8
 8008970:	0800b0d8 	.word	0x0800b0d8
 8008974:	0800b0e8 	.word	0x0800b0e8
 8008978:	0800b0f8 	.word	0x0800b0f8
 800897c:	00000000 	.word	0x00000000

08008980 <thread2>:

  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8008980:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8008982:	f7f9 fe3d 	bl	8002600 <chMsgWait>
 8008986:	6b04      	ldr	r4, [r0, #48]	; 0x30
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
 8008988:	4621      	mov	r1, r4
 800898a:	f7f9 fe59 	bl	8002640 <chMsgRelease>
  } while (msg);
 800898e:	2c00      	cmp	r4, #0
 8008990:	d1f7      	bne.n	8008982 <thread2+0x2>
}
 8008992:	bd10      	pop	{r4, pc}
	...

080089a0 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80089a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80089a4:	4b14      	ldr	r3, [pc, #80]	; (80089f8 <bmk6_execute+0x58>)

  uint32_t n = 0;
  void *wap = wa[0];
 80089a6:	4a15      	ldr	r2, [pc, #84]	; (80089fc <bmk6_execute+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80089a8:	699b      	ldr	r3, [r3, #24]
 80089aa:	f8d2 8000 	ldr.w	r8, [r2]
  tprio_t prio = chThdGetPriorityX() + 1;
 80089ae:	689d      	ldr	r5, [r3, #8]
 80089b0:	4f13      	ldr	r7, [pc, #76]	; (8008a00 <bmk6_execute+0x60>)
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80089b2:	b082      	sub	sp, #8

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
 80089b4:	f7fd f8ac 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 80089b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80089bc:	f7fd f8b8 	bl	8005b30 <test_start_timer>
 * a second of continuous operations.
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
 80089c0:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 80089c2:	3501      	adds	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 80089c4:	4626      	mov	r6, r4
 80089c6:	4b0f      	ldr	r3, [pc, #60]	; (8008a04 <bmk6_execute+0x64>)
 80089c8:	9600      	str	r6, [sp, #0]
 80089ca:	462a      	mov	r2, r5
 80089cc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80089d0:	4640      	mov	r0, r8
 80089d2:	f7f8 ff15 	bl	8001800 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80089d6:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 80089d8:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80089da:	2b00      	cmp	r3, #0
 80089dc:	d0f3      	beq.n	80089c6 <bmk6_execute+0x26>
  test_print("--- Score : ");
 80089de:	480a      	ldr	r0, [pc, #40]	; (8008a08 <bmk6_execute+0x68>)
 80089e0:	f7fc ffc6 	bl	8005970 <test_print>
  test_printn(n);
 80089e4:	4620      	mov	r0, r4
 80089e6:	f7fc ff93 	bl	8005910 <test_printn>
  test_println(" threads/S");
 80089ea:	4808      	ldr	r0, [pc, #32]	; (8008a0c <bmk6_execute+0x6c>)
}
 80089ec:	b002      	add	sp, #8
 80089ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 80089f2:	f7fc bfd5 	b.w	80059a0 <test_println>
 80089f6:	bf00      	nop
 80089f8:	20000e78 	.word	0x20000e78
 80089fc:	0800a700 	.word	0x0800a700
 8008a00:	200019dd 	.word	0x200019dd
 8008a04:	08008c11 	.word	0x08008c11
 8008a08:	0800b108 	.word	0x0800b108
 8008a0c:	0800b118 	.word	0x0800b118

08008a10 <msg_loop_test>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8008a10:	b570      	push	{r4, r5, r6, lr}
 8008a12:	4605      	mov	r5, r0

  uint32_t n = 0;
  test_wait_tick();
 8008a14:	f7fd f87c 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 8008a18:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008a1c:	f7fd f888 	bl	8005b30 <test_start_timer>
 8008a20:	4e07      	ldr	r6, [pc, #28]	; (8008a40 <msg_loop_test+0x30>)
#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {

  uint32_t n = 0;
 8008a22:	2400      	movs	r4, #0
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
 8008a24:	2101      	movs	r1, #1
 8008a26:	4628      	mov	r0, r5
 8008a28:	f7f9 fdca 	bl	80025c0 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008a2c:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 8008a2e:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008a30:	2b00      	cmp	r3, #0
 8008a32:	d0f7      	beq.n	8008a24 <msg_loop_test+0x14>
  (void)chMsgSend(tp, 0);
 8008a34:	4628      	mov	r0, r5
 8008a36:	2100      	movs	r1, #0
 8008a38:	f7f9 fdc2 	bl	80025c0 <chMsgSend>
  return n;
}
 8008a3c:	4620      	mov	r0, r4
 8008a3e:	bd70      	pop	{r4, r5, r6, pc}
 8008a40:	200019dd 	.word	0x200019dd
	...

08008a50 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8008a50:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008a52:	4b13      	ldr	r3, [pc, #76]	; (8008aa0 <bmk1_execute+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8008a54:	4a13      	ldr	r2, [pc, #76]	; (8008aa4 <bmk1_execute+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008a56:	699b      	ldr	r3, [r3, #24]
 8008a58:	6810      	ldr	r0, [r2, #0]
 8008a5a:	689a      	ldr	r2, [r3, #8]
 8008a5c:	4b12      	ldr	r3, [pc, #72]	; (8008aa8 <bmk1_execute+0x58>)
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8008a5e:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8008a60:	2100      	movs	r1, #0
 8008a62:	3a01      	subs	r2, #1
 8008a64:	9100      	str	r1, [sp, #0]
 8008a66:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008a6a:	f7f8 fec9 	bl	8001800 <chThdCreateStatic>
 8008a6e:	4b0f      	ldr	r3, [pc, #60]	; (8008aac <bmk1_execute+0x5c>)
 8008a70:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8008a72:	f7ff ffcd 	bl	8008a10 <msg_loop_test>
 8008a76:	4604      	mov	r4, r0
  test_wait_threads();
 8008a78:	f7fd f832 	bl	8005ae0 <test_wait_threads>
  test_print("--- Score : ");
 8008a7c:	480c      	ldr	r0, [pc, #48]	; (8008ab0 <bmk1_execute+0x60>)
 8008a7e:	f7fc ff77 	bl	8005970 <test_print>
  test_printn(n);
 8008a82:	4620      	mov	r0, r4
 8008a84:	f7fc ff44 	bl	8005910 <test_printn>
  test_print(" msgs/S, ");
 8008a88:	480a      	ldr	r0, [pc, #40]	; (8008ab4 <bmk1_execute+0x64>)
 8008a8a:	f7fc ff71 	bl	8005970 <test_print>
  test_printn(n << 1);
 8008a8e:	0060      	lsls	r0, r4, #1
 8008a90:	f7fc ff3e 	bl	8005910 <test_printn>
  test_println(" ctxswc/S");
 8008a94:	4808      	ldr	r0, [pc, #32]	; (8008ab8 <bmk1_execute+0x68>)
}
 8008a96:	b002      	add	sp, #8
 8008a98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8008a9c:	f7fc bf80 	b.w	80059a0 <test_println>
 8008aa0:	20000e78 	.word	0x20000e78
 8008aa4:	0800a700 	.word	0x0800a700
 8008aa8:	08008981 	.word	0x08008981
 8008aac:	200019f8 	.word	0x200019f8
 8008ab0:	0800b108 	.word	0x0800b108
 8008ab4:	0800b124 	.word	0x0800b124
 8008ab8:	0800b130 	.word	0x0800b130
 8008abc:	00000000 	.word	0x00000000

08008ac0 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8008ac0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008ac2:	4b13      	ldr	r3, [pc, #76]	; (8008b10 <bmk2_execute+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008ac4:	4a13      	ldr	r2, [pc, #76]	; (8008b14 <bmk2_execute+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008ac6:	699b      	ldr	r3, [r3, #24]
 8008ac8:	6810      	ldr	r0, [r2, #0]
 8008aca:	689a      	ldr	r2, [r3, #8]
 8008acc:	4b12      	ldr	r3, [pc, #72]	; (8008b18 <bmk2_execute+0x58>)
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8008ace:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008ad0:	2100      	movs	r1, #0
 8008ad2:	3201      	adds	r2, #1
 8008ad4:	9100      	str	r1, [sp, #0]
 8008ad6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008ada:	f7f8 fe91 	bl	8001800 <chThdCreateStatic>
 8008ade:	4b0f      	ldr	r3, [pc, #60]	; (8008b1c <bmk2_execute+0x5c>)
 8008ae0:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8008ae2:	f7ff ff95 	bl	8008a10 <msg_loop_test>
 8008ae6:	4604      	mov	r4, r0
  test_wait_threads();
 8008ae8:	f7fc fffa 	bl	8005ae0 <test_wait_threads>
  test_print("--- Score : ");
 8008aec:	480c      	ldr	r0, [pc, #48]	; (8008b20 <bmk2_execute+0x60>)
 8008aee:	f7fc ff3f 	bl	8005970 <test_print>
  test_printn(n);
 8008af2:	4620      	mov	r0, r4
 8008af4:	f7fc ff0c 	bl	8005910 <test_printn>
  test_print(" msgs/S, ");
 8008af8:	480a      	ldr	r0, [pc, #40]	; (8008b24 <bmk2_execute+0x64>)
 8008afa:	f7fc ff39 	bl	8005970 <test_print>
  test_printn(n << 1);
 8008afe:	0060      	lsls	r0, r4, #1
 8008b00:	f7fc ff06 	bl	8005910 <test_printn>
  test_println(" ctxswc/S");
 8008b04:	4808      	ldr	r0, [pc, #32]	; (8008b28 <bmk2_execute+0x68>)
}
 8008b06:	b002      	add	sp, #8
 8008b08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8008b0c:	f7fc bf48 	b.w	80059a0 <test_println>
 8008b10:	20000e78 	.word	0x20000e78
 8008b14:	0800a700 	.word	0x0800a700
 8008b18:	08008981 	.word	0x08008981
 8008b1c:	200019f8 	.word	0x200019f8
 8008b20:	0800b108 	.word	0x0800b108
 8008b24:	0800b124 	.word	0x0800b124
 8008b28:	0800b130 	.word	0x0800b130
 8008b2c:	00000000 	.word	0x00000000

08008b30 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8008b30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008b34:	4f2c      	ldr	r7, [pc, #176]	; (8008be8 <bmk3_execute+0xb8>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008b36:	4e2d      	ldr	r6, [pc, #180]	; (8008bec <bmk3_execute+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008b38:	69bb      	ldr	r3, [r7, #24]
 8008b3a:	6830      	ldr	r0, [r6, #0]
 8008b3c:	689a      	ldr	r2, [r3, #8]
 8008b3e:	4b2c      	ldr	r3, [pc, #176]	; (8008bf0 <bmk3_execute+0xc0>)
 8008b40:	4c2c      	ldr	r4, [pc, #176]	; (8008bf4 <bmk3_execute+0xc4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008b42:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8008c04 <bmk3_execute+0xd4>
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8008b46:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008b48:	2500      	movs	r5, #0
 8008b4a:	3201      	adds	r2, #1
 8008b4c:	9500      	str	r5, [sp, #0]
 8008b4e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008b52:	f7f8 fe55 	bl	8001800 <chThdCreateStatic>
 8008b56:	69ba      	ldr	r2, [r7, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008b58:	6873      	ldr	r3, [r6, #4]
 8008b5a:	6892      	ldr	r2, [r2, #8]
 */

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008b5c:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008b5e:	3a02      	subs	r2, #2
 8008b60:	9500      	str	r5, [sp, #0]
 8008b62:	4618      	mov	r0, r3
 8008b64:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008b68:	4643      	mov	r3, r8
 8008b6a:	f7f8 fe49 	bl	8001800 <chThdCreateStatic>
 8008b6e:	69ba      	ldr	r2, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8008b70:	68b3      	ldr	r3, [r6, #8]
 8008b72:	6892      	ldr	r2, [r2, #8]

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008b74:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8008b76:	3a03      	subs	r2, #3
 8008b78:	9500      	str	r5, [sp, #0]
 8008b7a:	4618      	mov	r0, r3
 8008b7c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008b80:	4643      	mov	r3, r8
 8008b82:	f7f8 fe3d 	bl	8001800 <chThdCreateStatic>
 8008b86:	69ba      	ldr	r2, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8008b88:	68f3      	ldr	r3, [r6, #12]
 8008b8a:	6892      	ldr	r2, [r2, #8]
static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8008b8c:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8008b8e:	3a04      	subs	r2, #4
 8008b90:	9500      	str	r5, [sp, #0]
 8008b92:	4618      	mov	r0, r3
 8008b94:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008b98:	4643      	mov	r3, r8
 8008b9a:	f7f8 fe31 	bl	8001800 <chThdCreateStatic>
 8008b9e:	69ba      	ldr	r2, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8008ba0:	6933      	ldr	r3, [r6, #16]
 8008ba2:	6892      	ldr	r2, [r2, #8]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8008ba4:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8008ba6:	3a05      	subs	r2, #5
 8008ba8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008bac:	4618      	mov	r0, r3
 8008bae:	9500      	str	r5, [sp, #0]
 8008bb0:	4643      	mov	r3, r8
 8008bb2:	f7f8 fe25 	bl	8001800 <chThdCreateStatic>
 8008bb6:	6120      	str	r0, [r4, #16]
  n = msg_loop_test(threads[0]);
 8008bb8:	6820      	ldr	r0, [r4, #0]
 8008bba:	f7ff ff29 	bl	8008a10 <msg_loop_test>
 8008bbe:	4604      	mov	r4, r0
  test_wait_threads();
 8008bc0:	f7fc ff8e 	bl	8005ae0 <test_wait_threads>
  test_print("--- Score : ");
 8008bc4:	480c      	ldr	r0, [pc, #48]	; (8008bf8 <bmk3_execute+0xc8>)
 8008bc6:	f7fc fed3 	bl	8005970 <test_print>
  test_printn(n);
 8008bca:	4620      	mov	r0, r4
 8008bcc:	f7fc fea0 	bl	8005910 <test_printn>
  test_print(" msgs/S, ");
 8008bd0:	480a      	ldr	r0, [pc, #40]	; (8008bfc <bmk3_execute+0xcc>)
 8008bd2:	f7fc fecd 	bl	8005970 <test_print>
  test_printn(n << 1);
 8008bd6:	0060      	lsls	r0, r4, #1
 8008bd8:	f7fc fe9a 	bl	8005910 <test_printn>
  test_println(" ctxswc/S");
 8008bdc:	4808      	ldr	r0, [pc, #32]	; (8008c00 <bmk3_execute+0xd0>)
}
 8008bde:	b002      	add	sp, #8
 8008be0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8008be4:	f7fc bedc 	b.w	80059a0 <test_println>
 8008be8:	20000e78 	.word	0x20000e78
 8008bec:	0800a700 	.word	0x0800a700
 8008bf0:	08008981 	.word	0x08008981
 8008bf4:	200019f8 	.word	0x200019f8
 8008bf8:	0800b108 	.word	0x0800b108
 8008bfc:	0800b124 	.word	0x0800b124
 8008c00:	0800b130 	.word	0x0800b130
 8008c04:	08008c11 	.word	0x08008c11
	...

08008c10 <thread1>:
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {

  chThdExit((msg_t)p);
 8008c10:	f7f8 bebe 	b.w	8001990 <chThdExit>
	...

08008c20 <bmk4_execute>:
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8008c20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008c24:	4b26      	ldr	r3, [pc, #152]	; (8008cc0 <bmk4_execute+0xa0>)
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008c26:	4a27      	ldr	r2, [pc, #156]	; (8008cc4 <bmk4_execute+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008c28:	699b      	ldr	r3, [r3, #24]
 8008c2a:	6810      	ldr	r0, [r2, #0]
 8008c2c:	689a      	ldr	r2, [r3, #8]
 8008c2e:	4b26      	ldr	r3, [pc, #152]	; (8008cc8 <bmk4_execute+0xa8>)
 8008c30:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8008cd8 <bmk4_execute+0xb8>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8008c34:	b082      	sub	sp, #8
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008c36:	2500      	movs	r5, #0
 8008c38:	3201      	adds	r2, #1
 8008c3a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008c3e:	9500      	str	r5, [sp, #0]
 8008c40:	f7f8 fdde 	bl	8001800 <chThdCreateStatic>
 8008c44:	4b21      	ldr	r3, [pc, #132]	; (8008ccc <bmk4_execute+0xac>)
 8008c46:	4604      	mov	r4, r0
 8008c48:	6018      	str	r0, [r3, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 8008c4a:	f7fc ff61 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 8008c4e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008c52:	f7fc ff6d 	bl	8005b30 <test_start_timer>
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8008c56:	46aa      	mov	sl, r5
 8008c58:	f04f 0820 	mov.w	r8, #32
 8008c5c:	2720      	movs	r7, #32
 8008c5e:	f388 8811 	msr	BASEPRI, r8
 8008c62:	2100      	movs	r1, #0
 8008c64:	4620      	mov	r0, r4
 8008c66:	f7f8 fce3 	bl	8001630 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8008c6a:	4620      	mov	r0, r4
 8008c6c:	2100      	movs	r1, #0
 8008c6e:	f7f8 fcdf 	bl	8001630 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8008c72:	4620      	mov	r0, r4
 8008c74:	2100      	movs	r1, #0
 8008c76:	f7f8 fcdb 	bl	8001630 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8008c7a:	4620      	mov	r0, r4
 8008c7c:	2100      	movs	r1, #0
 8008c7e:	f7f8 fcd7 	bl	8001630 <chSchWakeupS>
 8008c82:	2600      	movs	r6, #0
 8008c84:	f38a 8811 	msr	BASEPRI, sl
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008c88:	f899 3000 	ldrb.w	r3, [r9]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8008c8c:	3504      	adds	r5, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008c8e:	2b00      	cmp	r3, #0
 8008c90:	d0e4      	beq.n	8008c5c <bmk4_execute+0x3c>
 8008c92:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 8008c96:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008c9a:	4620      	mov	r0, r4
 8008c9c:	f7f8 fcc8 	bl	8001630 <chSchWakeupS>
 8008ca0:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();

  test_wait_threads();
 8008ca4:	f7fc ff1c 	bl	8005ae0 <test_wait_threads>
  test_print("--- Score : ");
 8008ca8:	4809      	ldr	r0, [pc, #36]	; (8008cd0 <bmk4_execute+0xb0>)
 8008caa:	f7fc fe61 	bl	8005970 <test_print>
  test_printn(n * 2);
 8008cae:	0068      	lsls	r0, r5, #1
 8008cb0:	f7fc fe2e 	bl	8005910 <test_printn>
  test_println(" ctxswc/S");
 8008cb4:	4807      	ldr	r0, [pc, #28]	; (8008cd4 <bmk4_execute+0xb4>)
}
 8008cb6:	b002      	add	sp, #8
 8008cb8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  chSysUnlock();

  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" ctxswc/S");
 8008cbc:	f7fc be70 	b.w	80059a0 <test_println>
 8008cc0:	20000e78 	.word	0x20000e78
 8008cc4:	0800a700 	.word	0x0800a700
 8008cc8:	08008ce1 	.word	0x08008ce1
 8008ccc:	200019f8 	.word	0x200019f8
 8008cd0:	0800b108 	.word	0x0800b108
 8008cd4:	0800b130 	.word	0x0800b130
 8008cd8:	200019dd 	.word	0x200019dd
 8008cdc:	00000000 	.word	0x00000000

08008ce0 <thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008ce0:	4a07      	ldr	r2, [pc, #28]	; (8008d00 <thread4+0x20>)
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8008ce2:	b510      	push	{r4, lr}
 8008ce4:	2320      	movs	r3, #32
 8008ce6:	6994      	ldr	r4, [r2, #24]
 8008ce8:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8008cec:	2003      	movs	r0, #3
 8008cee:	f7f8 fc5f 	bl	80015b0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 8008cf2:	6a23      	ldr	r3, [r4, #32]
 8008cf4:	2b00      	cmp	r3, #0
 8008cf6:	d0f9      	beq.n	8008cec <thread4+0xc>
 8008cf8:	2300      	movs	r3, #0
 8008cfa:	f383 8811 	msr	BASEPRI, r3
 8008cfe:	bd10      	pop	{r4, pc}
 8008d00:	20000e78 	.word	0x20000e78
	...

08008d10 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8008d10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008d14:	4b15      	ldr	r3, [pc, #84]	; (8008d6c <bmk5_execute+0x5c>)

  uint32_t n = 0;
  void *wap = wa[0];
 8008d16:	4a16      	ldr	r2, [pc, #88]	; (8008d70 <bmk5_execute+0x60>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008d18:	699b      	ldr	r3, [r3, #24]
 8008d1a:	f8d2 8000 	ldr.w	r8, [r2]
  tprio_t prio = chThdGetPriorityX() - 1;
 8008d1e:	689d      	ldr	r5, [r3, #8]
 8008d20:	4f14      	ldr	r7, [pc, #80]	; (8008d74 <bmk5_execute+0x64>)
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8008d22:	b082      	sub	sp, #8

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
 8008d24:	f7fc fef4 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 8008d28:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008d2c:	f7fc ff00 	bl	8005b30 <test_start_timer>
 * a second of continuous operations.
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
 8008d30:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8008d32:	3d01      	subs	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8008d34:	4626      	mov	r6, r4
 8008d36:	4b10      	ldr	r3, [pc, #64]	; (8008d78 <bmk5_execute+0x68>)
 8008d38:	9600      	str	r6, [sp, #0]
 8008d3a:	462a      	mov	r2, r5
 8008d3c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008d40:	4640      	mov	r0, r8
 8008d42:	f7f8 fd5d 	bl	8001800 <chThdCreateStatic>
 8008d46:	f7f8 fe2b 	bl	80019a0 <chThdWait>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008d4a:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8008d4c:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d0f1      	beq.n	8008d36 <bmk5_execute+0x26>
  test_print("--- Score : ");
 8008d52:	480a      	ldr	r0, [pc, #40]	; (8008d7c <bmk5_execute+0x6c>)
 8008d54:	f7fc fe0c 	bl	8005970 <test_print>
  test_printn(n);
 8008d58:	4620      	mov	r0, r4
 8008d5a:	f7fc fdd9 	bl	8005910 <test_printn>
  test_println(" threads/S");
 8008d5e:	4808      	ldr	r0, [pc, #32]	; (8008d80 <bmk5_execute+0x70>)
}
 8008d60:	b002      	add	sp, #8
 8008d62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8008d66:	f7fc be1b 	b.w	80059a0 <test_println>
 8008d6a:	bf00      	nop
 8008d6c:	20000e78 	.word	0x20000e78
 8008d70:	0800a700 	.word	0x0800a700
 8008d74:	200019dd 	.word	0x200019dd
 8008d78:	08008c11 	.word	0x08008c11
 8008d7c:	0800b108 	.word	0x0800b108
 8008d80:	0800b118 	.word	0x0800b118
	...

08008d90 <bmk7_execute>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8008d90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008d94:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8008e98 <bmk7_execute+0x108>
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8008d98:	4f37      	ldr	r7, [pc, #220]	; (8008e78 <bmk7_execute+0xe8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008d9a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8008d9e:	6838      	ldr	r0, [r7, #0]
 8008da0:	689a      	ldr	r2, [r3, #8]
 8008da2:	4b36      	ldr	r3, [pc, #216]	; (8008e7c <bmk7_execute+0xec>)
 8008da4:	4e36      	ldr	r6, [pc, #216]	; (8008e80 <bmk7_execute+0xf0>)
 8008da6:	4d37      	ldr	r5, [pc, #220]	; (8008e84 <bmk7_execute+0xf4>)
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8008da8:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8008daa:	2400      	movs	r4, #0
 8008dac:	3205      	adds	r2, #5
 8008dae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008db2:	9400      	str	r4, [sp, #0]
 8008db4:	f7f8 fd24 	bl	8001800 <chThdCreateStatic>
 8008db8:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8008dbc:	687b      	ldr	r3, [r7, #4]
 8008dbe:	6892      	ldr	r2, [r2, #8]
}

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8008dc0:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8008dc2:	3204      	adds	r2, #4
 8008dc4:	4618      	mov	r0, r3
 8008dc6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008dca:	4b2c      	ldr	r3, [pc, #176]	; (8008e7c <bmk7_execute+0xec>)
 8008dcc:	9400      	str	r4, [sp, #0]
 8008dce:	f7f8 fd17 	bl	8001800 <chThdCreateStatic>
 8008dd2:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8008dd6:	68bb      	ldr	r3, [r7, #8]
 8008dd8:	6892      	ldr	r2, [r2, #8]

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8008dda:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8008ddc:	3203      	adds	r2, #3
 8008dde:	4618      	mov	r0, r3
 8008de0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008de4:	4b25      	ldr	r3, [pc, #148]	; (8008e7c <bmk7_execute+0xec>)
 8008de6:	9400      	str	r4, [sp, #0]
 8008de8:	f7f8 fd0a 	bl	8001800 <chThdCreateStatic>
 8008dec:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8008df0:	68fb      	ldr	r3, [r7, #12]
 8008df2:	6892      	ldr	r2, [r2, #8]
static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8008df4:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8008df6:	3202      	adds	r2, #2
 8008df8:	4618      	mov	r0, r3
 8008dfa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008dfe:	4b1f      	ldr	r3, [pc, #124]	; (8008e7c <bmk7_execute+0xec>)
 8008e00:	9400      	str	r4, [sp, #0]
 8008e02:	f7f8 fcfd 	bl	8001800 <chThdCreateStatic>
 8008e06:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8008e0a:	693b      	ldr	r3, [r7, #16]
 8008e0c:	6892      	ldr	r2, [r2, #8]
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8008e0e:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8008e10:	3201      	adds	r2, #1
 8008e12:	4618      	mov	r0, r3
 8008e14:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008e18:	4b18      	ldr	r3, [pc, #96]	; (8008e7c <bmk7_execute+0xec>)
 8008e1a:	9400      	str	r4, [sp, #0]
 8008e1c:	f7f8 fcf0 	bl	8001800 <chThdCreateStatic>
 8008e20:	6130      	str	r0, [r6, #16]

  n = 0;
  test_wait_tick();
 8008e22:	f7fc fe75 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 8008e26:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008e2a:	f7fc fe81 	bl	8005b30 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 8008e2e:	2100      	movs	r1, #0
 8008e30:	4815      	ldr	r0, [pc, #84]	; (8008e88 <bmk7_execute+0xf8>)
 8008e32:	f7f8 ff4d 	bl	8001cd0 <chSemReset>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008e36:	782b      	ldrb	r3, [r5, #0]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 8008e38:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008e3a:	2b00      	cmp	r3, #0
 8008e3c:	d0f7      	beq.n	8008e2e <bmk7_execute+0x9e>
  test_terminate_threads();
 8008e3e:	f7fc fe3f 	bl	8005ac0 <test_terminate_threads>
  chSemReset(&sem1, 0);
 8008e42:	2100      	movs	r1, #0
 8008e44:	4810      	ldr	r0, [pc, #64]	; (8008e88 <bmk7_execute+0xf8>)
 8008e46:	f7f8 ff43 	bl	8001cd0 <chSemReset>
  test_wait_threads();
 8008e4a:	f7fc fe49 	bl	8005ae0 <test_wait_threads>

  test_print("--- Score : ");
 8008e4e:	480f      	ldr	r0, [pc, #60]	; (8008e8c <bmk7_execute+0xfc>)
 8008e50:	f7fc fd8e 	bl	8005970 <test_print>
  test_printn(n);
 8008e54:	4620      	mov	r0, r4
 8008e56:	f7fc fd5b 	bl	8005910 <test_printn>
  test_print(" reschedules/S, ");
 8008e5a:	480d      	ldr	r0, [pc, #52]	; (8008e90 <bmk7_execute+0x100>)
 8008e5c:	f7fc fd88 	bl	8005970 <test_print>
  test_printn(n * 6);
 8008e60:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 8008e64:	0040      	lsls	r0, r0, #1
 8008e66:	f7fc fd53 	bl	8005910 <test_printn>
  test_println(" ctxswc/S");
 8008e6a:	480a      	ldr	r0, [pc, #40]	; (8008e94 <bmk7_execute+0x104>)
}
 8008e6c:	b002      	add	sp, #8
 8008e6e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  test_print("--- Score : ");
  test_printn(n);
  test_print(" reschedules/S, ");
  test_printn(n * 6);
  test_println(" ctxswc/S");
 8008e72:	f7fc bd95 	b.w	80059a0 <test_println>
 8008e76:	bf00      	nop
 8008e78:	0800a700 	.word	0x0800a700
 8008e7c:	08008ea1 	.word	0x08008ea1
 8008e80:	200019f8 	.word	0x200019f8
 8008e84:	200019dd 	.word	0x200019dd
 8008e88:	20001ac0 	.word	0x20001ac0
 8008e8c:	0800b108 	.word	0x0800b108
 8008e90:	0800b13c 	.word	0x0800b13c
 8008e94:	0800b130 	.word	0x0800b130
 8008e98:	20000e78 	.word	0x20000e78
 8008e9c:	00000000 	.word	0x00000000

08008ea0 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8008ea0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008ea2:	4c06      	ldr	r4, [pc, #24]	; (8008ebc <thread3+0x1c>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8008ea4:	69a3      	ldr	r3, [r4, #24]

  (void)p;
  while (!chThdShouldTerminateX())
 8008ea6:	7f5b      	ldrb	r3, [r3, #29]
 8008ea8:	075a      	lsls	r2, r3, #29
 8008eaa:	d406      	bmi.n	8008eba <thread3+0x1a>
    chSemWait(&sem1);
 8008eac:	4804      	ldr	r0, [pc, #16]	; (8008ec0 <thread3+0x20>)
 8008eae:	f7f8 ff1f 	bl	8001cf0 <chSemWait>
 8008eb2:	69a3      	ldr	r3, [r4, #24]
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8008eb4:	7f5b      	ldrb	r3, [r3, #29]
 8008eb6:	075b      	lsls	r3, r3, #29
 8008eb8:	d5f8      	bpl.n	8008eac <thread3+0xc>
 8008eba:	bd10      	pop	{r4, pc}
 8008ebc:	20000e78 	.word	0x20000e78
 8008ec0:	20001ac0 	.word	0x20001ac0
	...

08008ed0 <bmk7_setup>:
    chSemWait(&sem1);
}

static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
 8008ed0:	2100      	movs	r1, #0
 8008ed2:	4801      	ldr	r0, [pc, #4]	; (8008ed8 <bmk7_setup+0x8>)
 8008ed4:	f7f8 bedc 	b.w	8001c90 <chSemObjectInit>
 8008ed8:	20001ac0 	.word	0x20001ac0
 8008edc:	00000000 	.word	0x00000000

08008ee0 <bmk11_setup>:
 * a second of continuous operations.
 */

static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
 8008ee0:	2101      	movs	r1, #1
 8008ee2:	4801      	ldr	r0, [pc, #4]	; (8008ee8 <bmk11_setup+0x8>)
 8008ee4:	f7f8 bed4 	b.w	8001c90 <chSemObjectInit>
 8008ee8:	20001ac0 	.word	0x20001ac0
 8008eec:	00000000 	.word	0x00000000

08008ef0 <bmk8_execute>:
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8008ef0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008ef4:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 8008ef6:	ac04      	add	r4, sp, #16
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008ef8:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8008fc8 <bmk8_execute+0xd8>
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008efc:	4f2d      	ldr	r7, [pc, #180]	; (8008fb4 <bmk8_execute+0xc4>)
 8008efe:	4e2e      	ldr	r6, [pc, #184]	; (8008fb8 <bmk8_execute+0xc8>)
 8008f00:	4d2e      	ldr	r5, [pc, #184]	; (8008fbc <bmk8_execute+0xcc>)
}

static void bmk8_execute(void) {
  uint32_t n;

  n = 0;
 8008f02:	2300      	movs	r3, #0
 8008f04:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_wait_tick();
 8008f08:	f7fc fe02 	bl	8005b10 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008f0c:	f8d8 3018 	ldr.w	r3, [r8, #24]

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f10:	6838      	ldr	r0, [r7, #0]
 8008f12:	689a      	ldr	r2, [r3, #8]
 8008f14:	9400      	str	r4, [sp, #0]
 8008f16:	4633      	mov	r3, r6
 8008f18:	3a01      	subs	r2, #1
 8008f1a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008f1e:	f7f8 fc6f 	bl	8001800 <chThdCreateStatic>
 8008f22:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f26:	687b      	ldr	r3, [r7, #4]
 8008f28:	6892      	ldr	r2, [r2, #8]
  uint32_t n;

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f2a:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f2c:	3a01      	subs	r2, #1
 8008f2e:	9400      	str	r4, [sp, #0]
 8008f30:	4618      	mov	r0, r3
 8008f32:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008f36:	4633      	mov	r3, r6
 8008f38:	f7f8 fc62 	bl	8001800 <chThdCreateStatic>
 8008f3c:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f40:	68bb      	ldr	r3, [r7, #8]
 8008f42:	6892      	ldr	r2, [r2, #8]

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f44:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f46:	3a01      	subs	r2, #1
 8008f48:	9400      	str	r4, [sp, #0]
 8008f4a:	4618      	mov	r0, r3
 8008f4c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008f50:	4633      	mov	r3, r6
 8008f52:	f7f8 fc55 	bl	8001800 <chThdCreateStatic>
 8008f56:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f5a:	68fb      	ldr	r3, [r7, #12]
 8008f5c:	6892      	ldr	r2, [r2, #8]
  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f5e:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f60:	3a01      	subs	r2, #1
 8008f62:	9400      	str	r4, [sp, #0]
 8008f64:	4618      	mov	r0, r3
 8008f66:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008f6a:	4633      	mov	r3, r6
 8008f6c:	f7f8 fc48 	bl	8001800 <chThdCreateStatic>
 8008f70:	f8d8 2018 	ldr.w	r2, [r8, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f74:	693b      	ldr	r3, [r7, #16]
 8008f76:	6892      	ldr	r2, [r2, #8]
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f78:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8008f7a:	3a01      	subs	r2, #1
 8008f7c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008f80:	9400      	str	r4, [sp, #0]
 8008f82:	4618      	mov	r0, r3
 8008f84:	4633      	mov	r3, r6
 8008f86:	f7f8 fc3b 	bl	8001800 <chThdCreateStatic>
 8008f8a:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 8008f8c:	f242 7010 	movw	r0, #10000	; 0x2710
 8008f90:	f7f8 fca6 	bl	80018e0 <chThdSleep>
  test_terminate_threads();
 8008f94:	f7fc fd94 	bl	8005ac0 <test_terminate_threads>
  test_wait_threads();
 8008f98:	f7fc fda2 	bl	8005ae0 <test_wait_threads>

  test_print("--- Score : ");
 8008f9c:	4808      	ldr	r0, [pc, #32]	; (8008fc0 <bmk8_execute+0xd0>)
 8008f9e:	f7fc fce7 	bl	8005970 <test_print>
  test_printn(n);
 8008fa2:	9803      	ldr	r0, [sp, #12]
 8008fa4:	f7fc fcb4 	bl	8005910 <test_printn>
  test_println(" ctxswc/S");
 8008fa8:	4806      	ldr	r0, [pc, #24]	; (8008fc4 <bmk8_execute+0xd4>)
 8008faa:	f7fc fcf9 	bl	80059a0 <test_println>
}
 8008fae:	b004      	add	sp, #16
 8008fb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008fb4:	0800a700 	.word	0x0800a700
 8008fb8:	08008fd1 	.word	0x08008fd1
 8008fbc:	200019f8 	.word	0x200019f8
 8008fc0:	0800b108 	.word	0x0800b108
 8008fc4:	0800b130 	.word	0x0800b130
 8008fc8:	20000e78 	.word	0x20000e78
 8008fcc:	00000000 	.word	0x00000000

08008fd0 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8008fd0:	b538      	push	{r3, r4, r5, lr}
 8008fd2:	4d09      	ldr	r5, [pc, #36]	; (8008ff8 <thread8+0x28>)
 8008fd4:	4604      	mov	r4, r0

  do {
    chThdYield();
 8008fd6:	f7f8 fca3 	bl	8001920 <chThdYield>
    chThdYield();
 8008fda:	f7f8 fca1 	bl	8001920 <chThdYield>
    chThdYield();
 8008fde:	f7f8 fc9f 	bl	8001920 <chThdYield>
    chThdYield();
 8008fe2:	f7f8 fc9d 	bl	8001920 <chThdYield>
    (*(uint32_t *)p) += 4;
 8008fe6:	6823      	ldr	r3, [r4, #0]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8008fe8:	69aa      	ldr	r2, [r5, #24]
 8008fea:	3304      	adds	r3, #4
 8008fec:	6023      	str	r3, [r4, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8008fee:	7f53      	ldrb	r3, [r2, #29]
 8008ff0:	075b      	lsls	r3, r3, #29
 8008ff2:	d5f0      	bpl.n	8008fd6 <thread8+0x6>
}
 8008ff4:	bd38      	pop	{r3, r4, r5, pc}
 8008ff6:	bf00      	nop
 8008ff8:	20000e78 	.word	0x20000e78
 8008ffc:	00000000 	.word	0x00000000

08009000 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8009000:	b570      	push	{r4, r5, r6, lr}
 8009002:	b082      	sub	sp, #8
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8009004:	2400      	movs	r4, #0
 8009006:	4623      	mov	r3, r4
 8009008:	2210      	movs	r2, #16
 800900a:	4923      	ldr	r1, [pc, #140]	; (8009098 <bmk9_execute+0x98>)
 800900c:	4823      	ldr	r0, [pc, #140]	; (800909c <bmk9_execute+0x9c>)
 800900e:	9400      	str	r4, [sp, #0]
 8009010:	f7f9 fc36 	bl	8002880 <chIQObjectInit>
  n = 0;
  test_wait_tick();
 8009014:	f7fc fd7c 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 8009018:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800901c:	f7fc fd88 	bl	8005b30 <test_start_timer>
 8009020:	4e1f      	ldr	r6, [pc, #124]	; (80090a0 <bmk9_execute+0xa0>)
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 8009022:	4625      	mov	r5, r4
 8009024:	2320      	movs	r3, #32
 8009026:	f383 8811 	msr	BASEPRI, r3
 800902a:	2100      	movs	r1, #0
 800902c:	481b      	ldr	r0, [pc, #108]	; (800909c <bmk9_execute+0x9c>)
 800902e:	f7f9 fc47 	bl	80028c0 <chIQPutI>
    chIQPutI(&iq, 1);
 8009032:	2101      	movs	r1, #1
 8009034:	4819      	ldr	r0, [pc, #100]	; (800909c <bmk9_execute+0x9c>)
 8009036:	f7f9 fc43 	bl	80028c0 <chIQPutI>
    chIQPutI(&iq, 2);
 800903a:	2102      	movs	r1, #2
 800903c:	4817      	ldr	r0, [pc, #92]	; (800909c <bmk9_execute+0x9c>)
 800903e:	f7f9 fc3f 	bl	80028c0 <chIQPutI>
    chIQPutI(&iq, 3);
 8009042:	2103      	movs	r1, #3
 8009044:	4815      	ldr	r0, [pc, #84]	; (800909c <bmk9_execute+0x9c>)
 8009046:	f7f9 fc3b 	bl	80028c0 <chIQPutI>
 800904a:	f385 8811 	msr	BASEPRI, r5
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800904e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009052:	4812      	ldr	r0, [pc, #72]	; (800909c <bmk9_execute+0x9c>)
 8009054:	f7f9 fc54 	bl	8002900 <chIQGetTimeout>
 8009058:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800905c:	480f      	ldr	r0, [pc, #60]	; (800909c <bmk9_execute+0x9c>)
 800905e:	f7f9 fc4f 	bl	8002900 <chIQGetTimeout>
 8009062:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009066:	480d      	ldr	r0, [pc, #52]	; (800909c <bmk9_execute+0x9c>)
 8009068:	f7f9 fc4a 	bl	8002900 <chIQGetTimeout>
 800906c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009070:	480a      	ldr	r0, [pc, #40]	; (800909c <bmk9_execute+0x9c>)
 8009072:	f7f9 fc45 	bl	8002900 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009076:	7833      	ldrb	r3, [r6, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 8009078:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800907a:	2b00      	cmp	r3, #0
 800907c:	d0d2      	beq.n	8009024 <bmk9_execute+0x24>
  test_print("--- Score : ");
 800907e:	4809      	ldr	r0, [pc, #36]	; (80090a4 <bmk9_execute+0xa4>)
 8009080:	f7fc fc76 	bl	8005970 <test_print>
  test_printn(n * 4);
 8009084:	00a0      	lsls	r0, r4, #2
 8009086:	f7fc fc43 	bl	8005910 <test_printn>
  test_println(" bytes/S");
 800908a:	4807      	ldr	r0, [pc, #28]	; (80090a8 <bmk9_execute+0xa8>)
}
 800908c:	b002      	add	sp, #8
 800908e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" bytes/S");
 8009092:	f7fc bc85 	b.w	80059a0 <test_println>
 8009096:	bf00      	nop
 8009098:	20001a88 	.word	0x20001a88
 800909c:	20001acc 	.word	0x20001acc
 80090a0:	200019dd 	.word	0x200019dd
 80090a4:	0800b108 	.word	0x0800b108
 80090a8:	0800b150 	.word	0x0800b150
 80090ac:	00000000 	.word	0x00000000

080090b0 <bmk10_execute>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 80090b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 80090b2:	f7fc fd2d 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 80090b6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80090ba:	f7fc fd39 	bl	8005b30 <test_start_timer>

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 80090be:	2400      	movs	r4, #0
 80090c0:	4f14      	ldr	r7, [pc, #80]	; (8009114 <bmk10_execute+0x64>)

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 80090c2:	4626      	mov	r6, r4
 80090c4:	2520      	movs	r5, #32
 80090c6:	f385 8811 	msr	BASEPRI, r5
 80090ca:	2300      	movs	r3, #0
 80090cc:	4a12      	ldr	r2, [pc, #72]	; (8009118 <bmk10_execute+0x68>)
 80090ce:	4813      	ldr	r0, [pc, #76]	; (800911c <bmk10_execute+0x6c>)
 80090d0:	2101      	movs	r1, #1
 80090d2:	f7f8 f995 	bl	8001400 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 80090d6:	2300      	movs	r3, #0
 80090d8:	4a0f      	ldr	r2, [pc, #60]	; (8009118 <bmk10_execute+0x68>)
 80090da:	4811      	ldr	r0, [pc, #68]	; (8009120 <bmk10_execute+0x70>)
 80090dc:	f242 7110 	movw	r1, #10000	; 0x2710
 80090e0:	f7f8 f98e 	bl	8001400 <chVTDoSetI>
    chVTDoResetI(&vt1);
 80090e4:	480d      	ldr	r0, [pc, #52]	; (800911c <bmk10_execute+0x6c>)
 80090e6:	f7f8 f9cb 	bl	8001480 <chVTDoResetI>
    chVTDoResetI(&vt2);
 80090ea:	480d      	ldr	r0, [pc, #52]	; (8009120 <bmk10_execute+0x70>)
 80090ec:	f7f8 f9c8 	bl	8001480 <chVTDoResetI>
 80090f0:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80090f4:	783b      	ldrb	r3, [r7, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 80090f6:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80090f8:	2b00      	cmp	r3, #0
 80090fa:	d0e4      	beq.n	80090c6 <bmk10_execute+0x16>
  test_print("--- Score : ");
 80090fc:	4809      	ldr	r0, [pc, #36]	; (8009124 <bmk10_execute+0x74>)
 80090fe:	f7fc fc37 	bl	8005970 <test_print>
  test_printn(n * 2);
 8009102:	0060      	lsls	r0, r4, #1
 8009104:	f7fc fc04 	bl	8005910 <test_printn>
  test_println(" timers/S");
 8009108:	4807      	ldr	r0, [pc, #28]	; (8009128 <bmk10_execute+0x78>)
}
 800910a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" timers/S");
 800910e:	f7fc bc47 	b.w	80059a0 <test_println>
 8009112:	bf00      	nop
 8009114:	200019dd 	.word	0x200019dd
 8009118:	08008881 	.word	0x08008881
 800911c:	20001a98 	.word	0x20001a98
 8009120:	20001aac 	.word	0x20001aac
 8009124:	0800b108 	.word	0x0800b108
 8009128:	0800b15c 	.word	0x0800b15c
 800912c:	00000000 	.word	0x00000000

08009130 <bmk11_execute>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 8009130:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 8009132:	f7fc fced 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 8009136:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800913a:	f7fc fcf9 	bl	8005b30 <test_start_timer>
 800913e:	4d14      	ldr	r5, [pc, #80]	; (8009190 <bmk11_execute+0x60>)

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
  uint32_t n = 0;
 8009140:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemWait(&sem1);
 8009142:	4814      	ldr	r0, [pc, #80]	; (8009194 <bmk11_execute+0x64>)
 8009144:	f7f8 fdd4 	bl	8001cf0 <chSemWait>
    chSemSignal(&sem1);
 8009148:	4812      	ldr	r0, [pc, #72]	; (8009194 <bmk11_execute+0x64>)
 800914a:	f7f8 fe41 	bl	8001dd0 <chSemSignal>
    chSemWait(&sem1);
 800914e:	4811      	ldr	r0, [pc, #68]	; (8009194 <bmk11_execute+0x64>)
 8009150:	f7f8 fdce 	bl	8001cf0 <chSemWait>
    chSemSignal(&sem1);
 8009154:	480f      	ldr	r0, [pc, #60]	; (8009194 <bmk11_execute+0x64>)
 8009156:	f7f8 fe3b 	bl	8001dd0 <chSemSignal>
    chSemWait(&sem1);
 800915a:	480e      	ldr	r0, [pc, #56]	; (8009194 <bmk11_execute+0x64>)
 800915c:	f7f8 fdc8 	bl	8001cf0 <chSemWait>
    chSemSignal(&sem1);
 8009160:	480c      	ldr	r0, [pc, #48]	; (8009194 <bmk11_execute+0x64>)
 8009162:	f7f8 fe35 	bl	8001dd0 <chSemSignal>
    chSemWait(&sem1);
 8009166:	480b      	ldr	r0, [pc, #44]	; (8009194 <bmk11_execute+0x64>)
 8009168:	f7f8 fdc2 	bl	8001cf0 <chSemWait>
    chSemSignal(&sem1);
 800916c:	4809      	ldr	r0, [pc, #36]	; (8009194 <bmk11_execute+0x64>)
 800916e:	f7f8 fe2f 	bl	8001dd0 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009172:	782b      	ldrb	r3, [r5, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 8009174:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009176:	2b00      	cmp	r3, #0
 8009178:	d0e3      	beq.n	8009142 <bmk11_execute+0x12>
  test_print("--- Score : ");
 800917a:	4807      	ldr	r0, [pc, #28]	; (8009198 <bmk11_execute+0x68>)
 800917c:	f7fc fbf8 	bl	8005970 <test_print>
  test_printn(n * 4);
 8009180:	00a0      	lsls	r0, r4, #2
 8009182:	f7fc fbc5 	bl	8005910 <test_printn>
  test_println(" wait+signal/S");
 8009186:	4805      	ldr	r0, [pc, #20]	; (800919c <bmk11_execute+0x6c>)
}
 8009188:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" wait+signal/S");
 800918c:	f7fc bc08 	b.w	80059a0 <test_println>
 8009190:	200019dd 	.word	0x200019dd
 8009194:	20001ac0 	.word	0x20001ac0
 8009198:	0800b108 	.word	0x0800b108
 800919c:	0800b168 	.word	0x0800b168

080091a0 <bmk12_execute>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 80091a0:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 80091a2:	f7fc fcb5 	bl	8005b10 <test_wait_tick>
  test_start_timer(1000);
 80091a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80091aa:	f7fc fcc1 	bl	8005b30 <test_start_timer>
 80091ae:	4d14      	ldr	r5, [pc, #80]	; (8009200 <bmk12_execute+0x60>)

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
  uint32_t n = 0;
 80091b0:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chMtxLock(&mtx1);
 80091b2:	4814      	ldr	r0, [pc, #80]	; (8009204 <bmk12_execute+0x64>)
 80091b4:	f7f8 fefc 	bl	8001fb0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80091b8:	4812      	ldr	r0, [pc, #72]	; (8009204 <bmk12_execute+0x64>)
 80091ba:	f7f8 ff21 	bl	8002000 <chMtxUnlock>
    chMtxLock(&mtx1);
 80091be:	4811      	ldr	r0, [pc, #68]	; (8009204 <bmk12_execute+0x64>)
 80091c0:	f7f8 fef6 	bl	8001fb0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80091c4:	480f      	ldr	r0, [pc, #60]	; (8009204 <bmk12_execute+0x64>)
 80091c6:	f7f8 ff1b 	bl	8002000 <chMtxUnlock>
    chMtxLock(&mtx1);
 80091ca:	480e      	ldr	r0, [pc, #56]	; (8009204 <bmk12_execute+0x64>)
 80091cc:	f7f8 fef0 	bl	8001fb0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80091d0:	480c      	ldr	r0, [pc, #48]	; (8009204 <bmk12_execute+0x64>)
 80091d2:	f7f8 ff15 	bl	8002000 <chMtxUnlock>
    chMtxLock(&mtx1);
 80091d6:	480b      	ldr	r0, [pc, #44]	; (8009204 <bmk12_execute+0x64>)
 80091d8:	f7f8 feea 	bl	8001fb0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80091dc:	4809      	ldr	r0, [pc, #36]	; (8009204 <bmk12_execute+0x64>)
 80091de:	f7f8 ff0f 	bl	8002000 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80091e2:	782b      	ldrb	r3, [r5, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 80091e4:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80091e6:	2b00      	cmp	r3, #0
 80091e8:	d0e3      	beq.n	80091b2 <bmk12_execute+0x12>
  test_print("--- Score : ");
 80091ea:	4807      	ldr	r0, [pc, #28]	; (8009208 <bmk12_execute+0x68>)
 80091ec:	f7fc fbc0 	bl	8005970 <test_print>
  test_printn(n * 4);
 80091f0:	00a0      	lsls	r0, r4, #2
 80091f2:	f7fc fb8d 	bl	8005910 <test_printn>
  test_println(" lock+unlock/S");
 80091f6:	4805      	ldr	r0, [pc, #20]	; (800920c <bmk12_execute+0x6c>)
}
 80091f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" lock+unlock/S");
 80091fc:	f7fc bbd0 	b.w	80059a0 <test_println>
 8009200:	200019dd 	.word	0x200019dd
 8009204:	20001a78 	.word	0x20001a78
 8009208:	0800b108 	.word	0x0800b108
 800920c:	0800b178 	.word	0x0800b178

08009210 <bmk12_setup>:
 * a second of continuous operations.
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
 8009210:	4801      	ldr	r0, [pc, #4]	; (8009218 <bmk12_setup+0x8>)
 8009212:	f7f8 be5d 	b.w	8001ed0 <chMtxObjectInit>
 8009216:	bf00      	nop
 8009218:	20001a78 	.word	0x20001a78
 800921c:	00000000 	.word	0x00000000

08009220 <lis302dlReadRegister>:
 *
 * @param[in] spip      pointer to the SPI initerface
 * @param[in] reg       register number
 * @return              The register value.
 */
uint8_t lis302dlReadRegister(SPIDriver *spip, uint8_t reg) {
 8009220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  spiSelect(spip);
  txbuf[0] = 0x80 | reg;
 8009222:	4c0b      	ldr	r4, [pc, #44]	; (8009250 <lis302dlReadRegister+0x30>)
  txbuf[1] = 0xff;
  spiExchange(spip, 2, txbuf, rxbuf);
 8009224:	4e0b      	ldr	r6, [pc, #44]	; (8009254 <lis302dlReadRegister+0x34>)
 *
 * @param[in] spip      pointer to the SPI initerface
 * @param[in] reg       register number
 * @return              The register value.
 */
uint8_t lis302dlReadRegister(SPIDriver *spip, uint8_t reg) {
 8009226:	460d      	mov	r5, r1
 8009228:	4607      	mov	r7, r0

  spiSelect(spip);
 800922a:	f7fa f951 	bl	80034d0 <spiSelect>
  txbuf[0] = 0x80 | reg;
 800922e:	f065 017f 	orn	r1, r5, #127	; 0x7f
  txbuf[1] = 0xff;
  spiExchange(spip, 2, txbuf, rxbuf);
 8009232:	4622      	mov	r2, r4
 8009234:	4638      	mov	r0, r7
 8009236:	4633      	mov	r3, r6
 * @return              The register value.
 */
uint8_t lis302dlReadRegister(SPIDriver *spip, uint8_t reg) {

  spiSelect(spip);
  txbuf[0] = 0x80 | reg;
 8009238:	7021      	strb	r1, [r4, #0]
  txbuf[1] = 0xff;
 800923a:	25ff      	movs	r5, #255	; 0xff
  spiExchange(spip, 2, txbuf, rxbuf);
 800923c:	2102      	movs	r1, #2
 */
uint8_t lis302dlReadRegister(SPIDriver *spip, uint8_t reg) {

  spiSelect(spip);
  txbuf[0] = 0x80 | reg;
  txbuf[1] = 0xff;
 800923e:	7065      	strb	r5, [r4, #1]
  spiExchange(spip, 2, txbuf, rxbuf);
 8009240:	f7fa f966 	bl	8003510 <spiExchange>
  spiUnselect(spip);
 8009244:	4638      	mov	r0, r7
 8009246:	f7fa f953 	bl	80034f0 <spiUnselect>
  return rxbuf[1];
}
 800924a:	7870      	ldrb	r0, [r6, #1]
 800924c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800924e:	bf00      	nop
 8009250:	20001af4 	.word	0x20001af4
 8009254:	20001af0 	.word	0x20001af0
	...

08009260 <lis302dlWriteRegister>:
 *
 * @param[in] spip      pointer to the SPI initerface
 * @param[in] reg       register number
 * @param[in] value     the value to be written
 */
void lis302dlWriteRegister(SPIDriver *spip, uint8_t reg, uint8_t value) {
 8009260:	f1a1 0320 	sub.w	r3, r1, #32
 8009264:	b2db      	uxtb	r3, r3
 8009266:	2b1f      	cmp	r3, #31
 8009268:	d807      	bhi.n	800927a <lis302dlWriteRegister+0x1a>
 800926a:	b570      	push	{r4, r5, r6, lr}
 800926c:	2501      	movs	r5, #1
 800926e:	4c0c      	ldr	r4, [pc, #48]	; (80092a0 <lis302dlWriteRegister+0x40>)
 8009270:	fa05 f303 	lsl.w	r3, r5, r3
 8009274:	401c      	ands	r4, r3
 8009276:	b90c      	cbnz	r4, 800927c <lis302dlWriteRegister+0x1c>
 8009278:	bd70      	pop	{r4, r5, r6, pc}
 800927a:	4770      	bx	lr
 800927c:	4606      	mov	r6, r0
 800927e:	4615      	mov	r5, r2
 8009280:	460c      	mov	r4, r1
  case LIS302DL_CLICK_THSY_X:
  case LIS302DL_CLICK_THSZ:
  case LIS302DL_CLICK_TIMELIMIT:
  case LIS302DL_CLICK_LATENCY:
  case LIS302DL_CLICK_WINDOW:
    spiSelect(spip);
 8009282:	f7fa f925 	bl	80034d0 <spiSelect>
    txbuf[0] = reg;
 8009286:	4b07      	ldr	r3, [pc, #28]	; (80092a4 <lis302dlWriteRegister+0x44>)
    txbuf[1] = value;
    spiSend(spip, 2, txbuf);
 8009288:	4630      	mov	r0, r6
 800928a:	2102      	movs	r1, #2
 800928c:	461a      	mov	r2, r3
  case LIS302DL_CLICK_THSZ:
  case LIS302DL_CLICK_TIMELIMIT:
  case LIS302DL_CLICK_LATENCY:
  case LIS302DL_CLICK_WINDOW:
    spiSelect(spip);
    txbuf[0] = reg;
 800928e:	701c      	strb	r4, [r3, #0]
    txbuf[1] = value;
 8009290:	705d      	strb	r5, [r3, #1]
    spiSend(spip, 2, txbuf);
 8009292:	f7fa f955 	bl	8003540 <spiSend>
    spiUnselect(spip);
 8009296:	4630      	mov	r0, r6
  }
}
 8009298:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  case LIS302DL_CLICK_WINDOW:
    spiSelect(spip);
    txbuf[0] = reg;
    txbuf[1] = value;
    spiSend(spip, 2, txbuf);
    spiUnselect(spip);
 800929c:	f7fa b928 	b.w	80034f0 <spiUnselect>
 80092a0:	f9dd0007 	.word	0xf9dd0007
 80092a4:	20001af4 	.word	0x20001af4
	...

080092b0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80092b0:	b40e      	push	{r1, r2, r3}
 80092b2:	b500      	push	{lr}
 80092b4:	b082      	sub	sp, #8
 80092b6:	aa03      	add	r2, sp, #12
 80092b8:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80092bc:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80092be:	f000 fa07 	bl	80096d0 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80092c2:	b002      	add	sp, #8
 80092c4:	f85d eb04 	ldr.w	lr, [sp], #4
 80092c8:	b003      	add	sp, #12
 80092ca:	4770      	bx	lr
 80092cc:	0000      	movs	r0, r0
	...

080092d0 <cmd_systime>:
}

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 80092d0:	2900      	cmp	r1, #0
 80092d2:	dd03      	ble.n	80092dc <cmd_systime+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80092d4:	4a07      	ldr	r2, [pc, #28]	; (80092f4 <cmd_systime+0x24>)
 80092d6:	4908      	ldr	r1, [pc, #32]	; (80092f8 <cmd_systime+0x28>)
 80092d8:	f7ff bfea 	b.w	80092b0 <chprintf>
 80092dc:	2320      	movs	r3, #32
 80092de:	f383 8811 	msr	BASEPRI, r3
 80092e2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80092e6:	2300      	movs	r3, #0
 80092e8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80092ea:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 80092ee:	4903      	ldr	r1, [pc, #12]	; (80092fc <cmd_systime+0x2c>)
 80092f0:	f7ff bfde 	b.w	80092b0 <chprintf>
 80092f4:	0800b390 	.word	0x0800b390
 80092f8:	0800b398 	.word	0x0800b398
 80092fc:	0800b3a4 	.word	0x0800b3a4

08009300 <cmd_info>:
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8009300:	2900      	cmp	r1, #0
 8009302:	dd03      	ble.n	800930c <cmd_info+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8009304:	4a19      	ldr	r2, [pc, #100]	; (800936c <cmd_info+0x6c>)
 8009306:	491a      	ldr	r1, [pc, #104]	; (8009370 <cmd_info+0x70>)
 8009308:	f7ff bfd2 	b.w	80092b0 <chprintf>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 800930c:	b510      	push	{r4, lr}
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 800930e:	4a19      	ldr	r2, [pc, #100]	; (8009374 <cmd_info+0x74>)
 8009310:	4919      	ldr	r1, [pc, #100]	; (8009378 <cmd_info+0x78>)
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009312:	b082      	sub	sp, #8
 8009314:	4604      	mov	r4, r0
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8009316:	f7ff ffcb 	bl	80092b0 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 800931a:	4a18      	ldr	r2, [pc, #96]	; (800937c <cmd_info+0x7c>)
 800931c:	4918      	ldr	r1, [pc, #96]	; (8009380 <cmd_info+0x80>)
 800931e:	4620      	mov	r0, r4
 8009320:	f7ff ffc6 	bl	80092b0 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 8009324:	4a17      	ldr	r2, [pc, #92]	; (8009384 <cmd_info+0x84>)
 8009326:	4918      	ldr	r1, [pc, #96]	; (8009388 <cmd_info+0x88>)
 8009328:	4620      	mov	r0, r4
 800932a:	f7ff ffc1 	bl	80092b0 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 800932e:	4a17      	ldr	r2, [pc, #92]	; (800938c <cmd_info+0x8c>)
 8009330:	4917      	ldr	r1, [pc, #92]	; (8009390 <cmd_info+0x90>)
 8009332:	4620      	mov	r0, r4
 8009334:	f7ff ffbc 	bl	80092b0 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8009338:	4a16      	ldr	r2, [pc, #88]	; (8009394 <cmd_info+0x94>)
 800933a:	4917      	ldr	r1, [pc, #92]	; (8009398 <cmd_info+0x98>)
 800933c:	4620      	mov	r0, r4
 800933e:	f7ff ffb7 	bl	80092b0 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 8009342:	4a16      	ldr	r2, [pc, #88]	; (800939c <cmd_info+0x9c>)
 8009344:	4916      	ldr	r1, [pc, #88]	; (80093a0 <cmd_info+0xa0>)
 8009346:	4620      	mov	r0, r4
 8009348:	f7ff ffb2 	bl	80092b0 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 800934c:	4a15      	ldr	r2, [pc, #84]	; (80093a4 <cmd_info+0xa4>)
 800934e:	4916      	ldr	r1, [pc, #88]	; (80093a8 <cmd_info+0xa8>)
 8009350:	4620      	mov	r0, r4
 8009352:	f7ff ffad 	bl	80092b0 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8009356:	4b15      	ldr	r3, [pc, #84]	; (80093ac <cmd_info+0xac>)
 8009358:	9300      	str	r3, [sp, #0]
 800935a:	4620      	mov	r0, r4
 800935c:	4b14      	ldr	r3, [pc, #80]	; (80093b0 <cmd_info+0xb0>)
 800935e:	4a15      	ldr	r2, [pc, #84]	; (80093b4 <cmd_info+0xb4>)
 8009360:	4915      	ldr	r1, [pc, #84]	; (80093b8 <cmd_info+0xb8>)
 8009362:	f7ff ffa5 	bl	80092b0 <chprintf>
#endif
#endif
}
 8009366:	b002      	add	sp, #8
 8009368:	bd10      	pop	{r4, pc}
 800936a:	bf00      	nop
 800936c:	0800b3ac 	.word	0x0800b3ac
 8009370:	0800b398 	.word	0x0800b398
 8009374:	0800a884 	.word	0x0800a884
 8009378:	0800b3b4 	.word	0x0800b3b4
 800937c:	0800a8a4 	.word	0x0800a8a4
 8009380:	0800b3c8 	.word	0x0800b3c8
 8009384:	0800a8ec 	.word	0x0800a8ec
 8009388:	0800b3dc 	.word	0x0800b3dc
 800938c:	0800a8f8 	.word	0x0800a8f8
 8009390:	0800b3f0 	.word	0x0800b3f0
 8009394:	0800a904 	.word	0x0800a904
 8009398:	0800b404 	.word	0x0800b404
 800939c:	0800a91c 	.word	0x0800a91c
 80093a0:	0800b418 	.word	0x0800b418
 80093a4:	0800a948 	.word	0x0800a948
 80093a8:	0800b42c 	.word	0x0800b42c
 80093ac:	0800b468 	.word	0x0800b468
 80093b0:	0800b440 	.word	0x0800b440
 80093b4:	0800b444 	.word	0x0800b444
 80093b8:	0800b450 	.word	0x0800b450
 80093bc:	00000000 	.word	0x00000000

080093c0 <_strtok.constprop.2>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 80093c0:	b538      	push	{r3, r4, r5, lr}
 80093c2:	460d      	mov	r5, r1
  char *token;
  if (str)
 80093c4:	b198      	cbz	r0, 80093ee <_strtok.constprop.2+0x2e>
 80093c6:	4604      	mov	r4, r0
    *saveptr = str;
 80093c8:	6028      	str	r0, [r5, #0]
  token = *saveptr;

  if (!token)
    return NULL;

  token += strspn(token, delim);
 80093ca:	490c      	ldr	r1, [pc, #48]	; (80093fc <_strtok.constprop.2+0x3c>)
 80093cc:	4620      	mov	r0, r4
 80093ce:	f000 ffa7 	bl	800a320 <strspn>
 80093d2:	4404      	add	r4, r0
  *saveptr = strpbrk(token, delim);
 80093d4:	4620      	mov	r0, r4
 80093d6:	4909      	ldr	r1, [pc, #36]	; (80093fc <_strtok.constprop.2+0x3c>)
 80093d8:	f000 ff7a 	bl	800a2d0 <strpbrk>
  if (*saveptr)
 80093dc:	b160      	cbz	r0, 80093f8 <_strtok.constprop.2+0x38>
    *(*saveptr)++ = '\0';
 80093de:	1c42      	adds	r2, r0, #1
 80093e0:	2300      	movs	r3, #0
 80093e2:	602a      	str	r2, [r5, #0]
 80093e4:	7003      	strb	r3, [r0, #0]

  return *token ? token : NULL;
 80093e6:	7823      	ldrb	r3, [r4, #0]
 80093e8:	b123      	cbz	r3, 80093f4 <_strtok.constprop.2+0x34>
 80093ea:	4620      	mov	r0, r4
}
 80093ec:	bd38      	pop	{r3, r4, r5, pc}

static char *_strtok(char *str, const char *delim, char **saveptr) {
  char *token;
  if (str)
    *saveptr = str;
  token = *saveptr;
 80093ee:	680c      	ldr	r4, [r1, #0]

  if (!token)
 80093f0:	2c00      	cmp	r4, #0
 80093f2:	d1ea      	bne.n	80093ca <_strtok.constprop.2+0xa>
    return NULL;
 80093f4:	2000      	movs	r0, #0
 80093f6:	bd38      	pop	{r3, r4, r5, pc}

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
 80093f8:	6028      	str	r0, [r5, #0]
 80093fa:	e7f4      	b.n	80093e6 <_strtok.constprop.2+0x26>
 80093fc:	0800b474 	.word	0x0800b474

08009400 <shellInit>:
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8009400:	4b01      	ldr	r3, [pc, #4]	; (8009408 <shellInit+0x8>)
 8009402:	601b      	str	r3, [r3, #0]
 8009404:	4770      	bx	lr
 8009406:	bf00      	nop
 8009408:	20001af8 	.word	0x20001af8
 800940c:	00000000 	.word	0x00000000

08009410 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8009410:	b500      	push	{lr}
 8009412:	b083      	sub	sp, #12

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8009414:	4b03      	ldr	r3, [pc, #12]	; (8009424 <shellCreate+0x14>)
 8009416:	9000      	str	r0, [sp, #0]
 8009418:	2000      	movs	r0, #0
 800941a:	f7f8 fbc9 	bl	8001bb0 <chThdCreateFromHeap>
}
 800941e:	b003      	add	sp, #12
 8009420:	f85d fb04 	ldr.w	pc, [sp], #4
 8009424:	080094d1 	.word	0x080094d1
	...

08009430 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8009430:	b5f0      	push	{r4, r5, r6, r7, lr}
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8009432:	3a01      	subs	r2, #1
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8009434:	b083      	sub	sp, #12
 8009436:	460e      	mov	r6, r1
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8009438:	188f      	adds	r7, r1, r2
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 800943a:	4604      	mov	r4, r0
 800943c:	460d      	mov	r5, r1
  char *p = line;

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 800943e:	6823      	ldr	r3, [r4, #0]
 8009440:	2201      	movs	r2, #1
 8009442:	685b      	ldr	r3, [r3, #4]
 8009444:	f10d 0107 	add.w	r1, sp, #7
 8009448:	4620      	mov	r0, r4
 800944a:	4798      	blx	r3
 800944c:	b348      	cbz	r0, 80094a2 <shellGetLine+0x72>
      return true;
    if (c == 4) {
 800944e:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8009452:	2904      	cmp	r1, #4
 8009454:	d028      	beq.n	80094a8 <shellGetLine+0x78>
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
 8009456:	2908      	cmp	r1, #8
 8009458:	d010      	beq.n	800947c <shellGetLine+0x4c>
 800945a:	297f      	cmp	r1, #127	; 0x7f
 800945c:	d00e      	beq.n	800947c <shellGetLine+0x4c>
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 800945e:	290d      	cmp	r1, #13
 8009460:	d029      	beq.n	80094b6 <shellGetLine+0x86>
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 8009462:	291f      	cmp	r1, #31
 8009464:	d9eb      	bls.n	800943e <shellGetLine+0xe>
      continue;
    if (p < line + size - 1) {
 8009466:	42bd      	cmp	r5, r7
 8009468:	d2e9      	bcs.n	800943e <shellGetLine+0xe>
      chSequentialStreamPut(chp, c);
 800946a:	6823      	ldr	r3, [r4, #0]
 800946c:	4620      	mov	r0, r4
 800946e:	689b      	ldr	r3, [r3, #8]
 8009470:	4798      	blx	r3
      *p++ = (char)c;
 8009472:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009476:	702b      	strb	r3, [r5, #0]
 8009478:	3501      	adds	r5, #1
 800947a:	e7e0      	b.n	800943e <shellGetLine+0xe>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 800947c:	42b5      	cmp	r5, r6
        chSequentialStreamPut(chp, c);
 800947e:	4620      	mov	r0, r4
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8009480:	d0dd      	beq.n	800943e <shellGetLine+0xe>
        chSequentialStreamPut(chp, c);
 8009482:	6823      	ldr	r3, [r4, #0]
 8009484:	689b      	ldr	r3, [r3, #8]
 8009486:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8009488:	6823      	ldr	r3, [r4, #0]
 800948a:	2120      	movs	r1, #32
 800948c:	689b      	ldr	r3, [r3, #8]
 800948e:	4620      	mov	r0, r4
 8009490:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 8009492:	6823      	ldr	r3, [r4, #0]
 8009494:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8009498:	689b      	ldr	r3, [r3, #8]
 800949a:	4620      	mov	r0, r4
        p--;
 800949c:	3d01      	subs	r5, #1
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
 800949e:	4798      	blx	r3
 80094a0:	e7cd      	b.n	800943e <shellGetLine+0xe>

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
 80094a2:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 80094a4:	b003      	add	sp, #12
 80094a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
    if (c == 4) {
      chprintf(chp, "^D");
 80094a8:	4620      	mov	r0, r4
 80094aa:	4907      	ldr	r1, [pc, #28]	; (80094c8 <shellGetLine+0x98>)
 80094ac:	f7ff ff00 	bl	80092b0 <chprintf>
      return true;
 80094b0:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 80094b2:	b003      	add	sp, #12
 80094b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
 80094b6:	4620      	mov	r0, r4
 80094b8:	4904      	ldr	r1, [pc, #16]	; (80094cc <shellGetLine+0x9c>)
 80094ba:	f7ff fef9 	bl	80092b0 <chprintf>
      *p = 0;
 80094be:	2000      	movs	r0, #0
 80094c0:	7028      	strb	r0, [r5, #0]
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 80094c2:	b003      	add	sp, #12
 80094c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80094c6:	bf00      	nop
 80094c8:	0800b478 	.word	0x0800b478
 80094cc:	0800b840 	.word	0x0800b840

080094d0 <shell_thread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 80094d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 80094d4:	4b5a      	ldr	r3, [pc, #360]	; (8009640 <shell_thread+0x170>)
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 80094d6:	6806      	ldr	r6, [r0, #0]
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 80094d8:	699b      	ldr	r3, [r3, #24]
 80094da:	4a5a      	ldr	r2, [pc, #360]	; (8009644 <shell_thread+0x174>)
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 80094dc:	f8d0 8004 	ldr.w	r8, [r0, #4]
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 80094e0:	4959      	ldr	r1, [pc, #356]	; (8009648 <shell_thread+0x178>)
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 80094e2:	619a      	str	r2, [r3, #24]
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 80094e4:	b096      	sub	sp, #88	; 0x58
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 80094e6:	4630      	mov	r0, r6
 80094e8:	f7ff fee2 	bl	80092b0 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 80094ec:	4957      	ldr	r1, [pc, #348]	; (800964c <shell_thread+0x17c>)
 80094ee:	4630      	mov	r0, r6
 80094f0:	f7ff fede 	bl	80092b0 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 80094f4:	2240      	movs	r2, #64	; 0x40
 80094f6:	a906      	add	r1, sp, #24
 80094f8:	4630      	mov	r0, r6
 80094fa:	f7ff ff99 	bl	8009430 <shellGetLine>
 80094fe:	4604      	mov	r4, r0
 8009500:	bb78      	cbnz	r0, 8009562 <shell_thread+0x92>
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8009502:	4669      	mov	r1, sp
 8009504:	a806      	add	r0, sp, #24
 8009506:	f7ff ff5b 	bl	80093c0 <_strtok.constprop.2>
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 800950a:	4669      	mov	r1, sp
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 800950c:	4607      	mov	r7, r0
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 800950e:	2000      	movs	r0, #0
 8009510:	ad01      	add	r5, sp, #4
 8009512:	f7ff ff55 	bl	80093c0 <_strtok.constprop.2>
 8009516:	b150      	cbz	r0, 800952e <shell_thread+0x5e>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8009518:	2c04      	cmp	r4, #4
 800951a:	d01b      	beq.n	8009554 <shell_thread+0x84>
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 800951c:	f845 0b04 	str.w	r0, [r5], #4
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8009520:	4669      	mov	r1, sp
 8009522:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8009524:	3401      	adds	r4, #1
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8009526:	f7ff ff4b 	bl	80093c0 <_strtok.constprop.2>
 800952a:	2800      	cmp	r0, #0
 800952c:	d1f4      	bne.n	8009518 <shell_thread+0x48>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 800952e:	ab16      	add	r3, sp, #88	; 0x58
 8009530:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8009534:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8009538:	2f00      	cmp	r7, #0
 800953a:	d0d7      	beq.n	80094ec <shell_thread+0x1c>
      if (strcasecmp(cmd, "exit") == 0) {
 800953c:	4944      	ldr	r1, [pc, #272]	; (8009650 <shell_thread+0x180>)
 800953e:	4638      	mov	r0, r7
 8009540:	f000 fe9e 	bl	800a280 <strcasecmp>
 8009544:	b9f0      	cbnz	r0, 8009584 <shell_thread+0xb4>
        if (n > 0) {
 8009546:	b184      	cbz	r4, 800956a <shell_thread+0x9a>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8009548:	4a41      	ldr	r2, [pc, #260]	; (8009650 <shell_thread+0x180>)
 800954a:	4942      	ldr	r1, [pc, #264]	; (8009654 <shell_thread+0x184>)
 800954c:	4630      	mov	r0, r6
 800954e:	f7ff feaf 	bl	80092b0 <chprintf>
    args[n] = NULL;
    if (cmd != NULL) {
      if (strcasecmp(cmd, "exit") == 0) {
        if (n > 0) {
          usage(chp, "exit");
          continue;
 8009552:	e7cb      	b.n	80094ec <shell_thread+0x1c>
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
 8009554:	4940      	ldr	r1, [pc, #256]	; (8009658 <shell_thread+0x188>)
 8009556:	4630      	mov	r0, r6
 8009558:	f7ff feaa 	bl	80092b0 <chprintf>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 800955c:	2300      	movs	r3, #0
 800955e:	9305      	str	r3, [sp, #20]
 8009560:	e7c4      	b.n	80094ec <shell_thread+0x1c>
  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (true) {
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
 8009562:	4630      	mov	r0, r6
 8009564:	493d      	ldr	r1, [pc, #244]	; (800965c <shell_thread+0x18c>)
 8009566:	f7ff fea3 	bl	80092b0 <chprintf>
 800956a:	2320      	movs	r3, #32
 800956c:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8009570:	2100      	movs	r1, #0
 8009572:	483b      	ldr	r0, [pc, #236]	; (8009660 <shell_thread+0x190>)
 8009574:	f7f8 fef4 	bl	8002360 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8009578:	2000      	movs	r0, #0
 800957a:	f7f8 f9e9 	bl	8001950 <chThdExitS>
        chprintf(chp, " ?\r\n");
      }
    }
  }
  shellExit(MSG_OK);
}
 800957e:	b016      	add	sp, #88	; 0x58
 8009580:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
 8009584:	4937      	ldr	r1, [pc, #220]	; (8009664 <shell_thread+0x194>)
 8009586:	4638      	mov	r0, r7
 8009588:	f000 fe7a 	bl	800a280 <strcasecmp>
 800958c:	b930      	cbnz	r0, 800959c <shell_thread+0xcc>
        if (n > 0) {
 800958e:	b1bc      	cbz	r4, 80095c0 <shell_thread+0xf0>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8009590:	4a34      	ldr	r2, [pc, #208]	; (8009664 <shell_thread+0x194>)
 8009592:	4930      	ldr	r1, [pc, #192]	; (8009654 <shell_thread+0x184>)
 8009594:	4630      	mov	r0, r6
 8009596:	f7ff fe8b 	bl	80092b0 <chprintf>
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
 800959a:	e7a7      	b.n	80094ec <shell_thread+0x1c>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 800959c:	4d32      	ldr	r5, [pc, #200]	; (8009668 <shell_thread+0x198>)
 800959e:	6828      	ldr	r0, [r5, #0]
 80095a0:	b918      	cbnz	r0, 80095aa <shell_thread+0xda>
 80095a2:	e031      	b.n	8009608 <shell_thread+0x138>
 80095a4:	f855 0f08 	ldr.w	r0, [r5, #8]!
 80095a8:	b370      	cbz	r0, 8009608 <shell_thread+0x138>
    if (strcasecmp(scp->sc_name, name) == 0) {
 80095aa:	4639      	mov	r1, r7
 80095ac:	f000 fe68 	bl	800a280 <strcasecmp>
 80095b0:	2800      	cmp	r0, #0
 80095b2:	d1f7      	bne.n	80095a4 <shell_thread+0xd4>
      scp->sc_function(chp, argc, argv);
 80095b4:	686b      	ldr	r3, [r5, #4]
 80095b6:	aa01      	add	r2, sp, #4
 80095b8:	4621      	mov	r1, r4
 80095ba:	4630      	mov	r0, r6
 80095bc:	4798      	blx	r3
 80095be:	e795      	b.n	80094ec <shell_thread+0x1c>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80095c0:	4d29      	ldr	r5, [pc, #164]	; (8009668 <shell_thread+0x198>)
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 80095c2:	492a      	ldr	r1, [pc, #168]	; (800966c <shell_thread+0x19c>)
 80095c4:	4630      	mov	r0, r6
 80095c6:	f7ff fe73 	bl	80092b0 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80095ca:	682a      	ldr	r2, [r5, #0]
 80095cc:	462c      	mov	r4, r5
 80095ce:	b13a      	cbz	r2, 80095e0 <shell_thread+0x110>
    chprintf(chp, "%s ", scp->sc_name);
 80095d0:	4927      	ldr	r1, [pc, #156]	; (8009670 <shell_thread+0x1a0>)
 80095d2:	4630      	mov	r0, r6
 80095d4:	f7ff fe6c 	bl	80092b0 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80095d8:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80095dc:	2a00      	cmp	r2, #0
 80095de:	d1f7      	bne.n	80095d0 <shell_thread+0x100>
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
 80095e0:	f1b8 0f00 	cmp.w	r8, #0
 80095e4:	d00b      	beq.n	80095fe <shell_thread+0x12e>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80095e6:	f8d8 2000 	ldr.w	r2, [r8]
 80095ea:	b142      	cbz	r2, 80095fe <shell_thread+0x12e>
 80095ec:	4644      	mov	r4, r8
    chprintf(chp, "%s ", scp->sc_name);
 80095ee:	4920      	ldr	r1, [pc, #128]	; (8009670 <shell_thread+0x1a0>)
 80095f0:	4630      	mov	r0, r6
 80095f2:	f7ff fe5d 	bl	80092b0 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80095f6:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80095fa:	2a00      	cmp	r2, #0
 80095fc:	d1f7      	bne.n	80095ee <shell_thread+0x11e>
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
 80095fe:	491d      	ldr	r1, [pc, #116]	; (8009674 <shell_thread+0x1a4>)
 8009600:	4630      	mov	r0, r6
 8009602:	f7ff fe55 	bl	80092b0 <chprintf>
 8009606:	e771      	b.n	80094ec <shell_thread+0x1c>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8009608:	f1b8 0f00 	cmp.w	r8, #0
 800960c:	d00d      	beq.n	800962a <shell_thread+0x15a>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 800960e:	f8d8 0000 	ldr.w	r0, [r8]
 8009612:	b150      	cbz	r0, 800962a <shell_thread+0x15a>
 8009614:	4645      	mov	r5, r8
 8009616:	e002      	b.n	800961e <shell_thread+0x14e>
 8009618:	f855 0f08 	ldr.w	r0, [r5, #8]!
 800961c:	b128      	cbz	r0, 800962a <shell_thread+0x15a>
    if (strcasecmp(scp->sc_name, name) == 0) {
 800961e:	4639      	mov	r1, r7
 8009620:	f000 fe2e 	bl	800a280 <strcasecmp>
 8009624:	2800      	cmp	r0, #0
 8009626:	d1f7      	bne.n	8009618 <shell_thread+0x148>
 8009628:	e7c4      	b.n	80095b4 <shell_thread+0xe4>
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 800962a:	463a      	mov	r2, r7
 800962c:	4912      	ldr	r1, [pc, #72]	; (8009678 <shell_thread+0x1a8>)
 800962e:	4630      	mov	r0, r6
 8009630:	f7ff fe3e 	bl	80092b0 <chprintf>
        chprintf(chp, " ?\r\n");
 8009634:	4911      	ldr	r1, [pc, #68]	; (800967c <shell_thread+0x1ac>)
 8009636:	4630      	mov	r0, r6
 8009638:	f7ff fe3a 	bl	80092b0 <chprintf>
 800963c:	e756      	b.n	80094ec <shell_thread+0x1c>
 800963e:	bf00      	nop
 8009640:	20000e78 	.word	0x20000e78
 8009644:	0800b47c 	.word	0x0800b47c
 8009648:	0800b484 	.word	0x0800b484
 800964c:	0800b49c 	.word	0x0800b49c
 8009650:	0800b4c8 	.word	0x0800b4c8
 8009654:	0800b398 	.word	0x0800b398
 8009658:	0800b4b0 	.word	0x0800b4b0
 800965c:	0800b4a4 	.word	0x0800b4a4
 8009660:	20001af8 	.word	0x20001af8
 8009664:	0800b4d0 	.word	0x0800b4d0
 8009668:	200008c0 	.word	0x200008c0
 800966c:	0800b4d8 	.word	0x0800b4d8
 8009670:	0800b4f0 	.word	0x0800b4f0
 8009674:	0800b840 	.word	0x0800b840
 8009678:	0800b4f4 	.word	0x0800b4f4
 800967c:	0800b4f8 	.word	0x0800b4f8

08009680 <ch_ltoa>:
  while (--i);

  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8009680:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8009682:	f100 070b 	add.w	r7, r0, #11
 8009686:	463c      	mov	r4, r7
 8009688:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 800968a:	fbb1 f6f2 	udiv	r6, r1, r2
 800968e:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8009692:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8009696:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8009698:	bfc8      	it	gt
 800969a:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 800969e:	b2db      	uxtb	r3, r3
 80096a0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 80096a4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 80096a8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 80096aa:	2d00      	cmp	r5, #0
 80096ac:	d1ed      	bne.n	800968a <ch_ltoa+0xa>
 80096ae:	1b3a      	subs	r2, r7, r4
 80096b0:	4402      	add	r2, r0
 80096b2:	e001      	b.n	80096b8 <ch_ltoa+0x38>
 80096b4:	f814 3f01 	ldrb.w	r3, [r4, #1]!

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 80096b8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 80096bc:	4290      	cmp	r0, r2
 80096be:	d1f9      	bne.n	80096b4 <ch_ltoa+0x34>
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
}
 80096c0:	bcf0      	pop	{r4, r5, r6, r7}
 80096c2:	4770      	bx	lr
	...

080096d0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80096d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80096d4:	b091      	sub	sp, #68	; 0x44
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80096d6:	2300      	movs	r3, #0
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80096d8:	4606      	mov	r6, r0
 80096da:	468b      	mov	fp, r1
 80096dc:	4692      	mov	sl, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80096de:	9300      	str	r3, [sp, #0]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 80096e0:	f89b 1000 	ldrb.w	r1, [fp]
 80096e4:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 80096e8:	b179      	cbz	r1, 800970a <chvprintf+0x3a>
      return n;
    if (c != '%') {
 80096ea:	2925      	cmp	r1, #37	; 0x25
 80096ec:	d011      	beq.n	8009712 <chvprintf+0x42>
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 80096ee:	9c00      	ldr	r4, [sp, #0]
  while (TRUE) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 80096f0:	6832      	ldr	r2, [r6, #0]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 80096f2:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 80096f4:	6892      	ldr	r2, [r2, #8]
 80096f6:	4630      	mov	r0, r6
      n++;
 80096f8:	3401      	adds	r4, #1
 80096fa:	9400      	str	r4, [sp, #0]
  while (TRUE) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 80096fc:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 80096fe:	f89b 1000 	ldrb.w	r1, [fp]
 8009702:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8009706:	2900      	cmp	r1, #0
 8009708:	d1ef      	bne.n	80096ea <chvprintf+0x1a>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800970a:	9800      	ldr	r0, [sp, #0]
 800970c:	b011      	add	sp, #68	; 0x44
 800970e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8009712:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8009716:	2a2d      	cmp	r2, #45	; 0x2d
 8009718:	bf03      	ittte	eq
 800971a:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 800971e:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 8009722:	2101      	moveq	r1, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8009724:	2100      	movne	r1, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8009726:	2a30      	cmp	r2, #48	; 0x30
 8009728:	bf08      	it	eq
 800972a:	785a      	ldrbeq	r2, [r3, #1]
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 800972c:	9101      	str	r1, [sp, #4]
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
 800972e:	bf06      	itte	eq
 8009730:	3301      	addeq	r3, #1
      filler = '0';
 8009732:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8009734:	2720      	movne	r7, #32
 8009736:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8009738:	2400      	movs	r4, #0
 800973a:	e008      	b.n	800974e <chvprintf+0x7e>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 800973c:	f89a 3000 	ldrb.w	r3, [sl]
 8009740:	f10a 0a04 	add.w	sl, sl, #4
 8009744:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 8009748:	eb03 0440 	add.w	r4, r3, r0, lsl #1
 800974c:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 800974e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8009752:	b2db      	uxtb	r3, r3
 8009754:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8009756:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 8009758:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 800975c:	d9f2      	bls.n	8009744 <chvprintf+0x74>
        c -= '0';
      else if (c == '*')
 800975e:	2a2a      	cmp	r2, #42	; 0x2a
 8009760:	d0ec      	beq.n	800973c <chvprintf+0x6c>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8009762:	2a2e      	cmp	r2, #46	; 0x2e
 8009764:	f04f 0800 	mov.w	r8, #0
 8009768:	d045      	beq.n	80097f6 <chvprintf+0x126>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800976a:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 800976e:	2b4c      	cmp	r3, #76	; 0x4c
 8009770:	d050      	beq.n	8009814 <chvprintf+0x144>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8009772:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8009776:	2b34      	cmp	r3, #52	; 0x34
 8009778:	f200 81c7 	bhi.w	8009b0a <chvprintf+0x43a>
 800977c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8009780:	01c501b5 	.word	0x01c501b5
 8009784:	01c501c5 	.word	0x01c501c5
 8009788:	01b501c5 	.word	0x01b501c5
 800978c:	01c501c5 	.word	0x01c501c5
 8009790:	01c501c5 	.word	0x01c501c5
 8009794:	01b301c5 	.word	0x01b301c5
 8009798:	01c501c5 	.word	0x01c501c5
 800979c:	01c501c5 	.word	0x01c501c5
 80097a0:	010601c5 	.word	0x010601c5
 80097a4:	01c501c5 	.word	0x01c501c5
 80097a8:	01c5008d 	.word	0x01c5008d
 80097ac:	01c501c5 	.word	0x01c501c5
 80097b0:	01c501c5 	.word	0x01c501c5
 80097b4:	01c501c5 	.word	0x01c501c5
 80097b8:	01c501c5 	.word	0x01c501c5
 80097bc:	01a501c5 	.word	0x01a501c5
 80097c0:	01c501b5 	.word	0x01c501b5
 80097c4:	01c50108 	.word	0x01c50108
 80097c8:	01b501c5 	.word	0x01b501c5
 80097cc:	01c501c5 	.word	0x01c501c5
 80097d0:	01c501c5 	.word	0x01c501c5
 80097d4:	01b301c5 	.word	0x01b301c5
 80097d8:	01c501c5 	.word	0x01c501c5
 80097dc:	00db01c5 	.word	0x00db01c5
 80097e0:	010601c5 	.word	0x010601c5
 80097e4:	01c501c5 	.word	0x01c501c5
 80097e8:	008d      	.short	0x008d
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 80097ea:	f89a 3000 	ldrb.w	r3, [sl]
 80097ee:	f10a 0a04 	add.w	sl, sl, #4
        else
          break;
        precision *= 10;
        precision += c;
 80097f2:	eb03 0841 	add.w	r8, r3, r1, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 80097f6:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 80097fa:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80097fe:	b2db      	uxtb	r3, r3
 8009800:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8009802:	eb08 0188 	add.w	r1, r8, r8, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 8009806:	d9f4      	bls.n	80097f2 <chvprintf+0x122>
          c -= '0';
        else if (c == '*')
 8009808:	2a2a      	cmp	r2, #42	; 0x2a
 800980a:	d0ee      	beq.n	80097ea <chvprintf+0x11a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800980c:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8009810:	2b4c      	cmp	r3, #76	; 0x4c
 8009812:	d1ae      	bne.n	8009772 <chvprintf+0xa2>
      is_long = TRUE;
      if (*fmt)
 8009814:	f89b 1000 	ldrb.w	r1, [fp]
 8009818:	2900      	cmp	r1, #0
 800981a:	f000 8176 	beq.w	8009b0a <chvprintf+0x43a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800981e:	f1a1 0344 	sub.w	r3, r1, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8009822:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8009826:	2b34      	cmp	r3, #52	; 0x34
 8009828:	f200 816e 	bhi.w	8009b08 <chvprintf+0x438>
 800982c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8009830:	016c015d 	.word	0x016c015d
 8009834:	016c016c 	.word	0x016c016c
 8009838:	015d016c 	.word	0x015d016c
 800983c:	016c016c 	.word	0x016c016c
 8009840:	016c016c 	.word	0x016c016c
 8009844:	015b016c 	.word	0x015b016c
 8009848:	016c016c 	.word	0x016c016c
 800984c:	016c016c 	.word	0x016c016c
 8009850:	00ae016c 	.word	0x00ae016c
 8009854:	016c016c 	.word	0x016c016c
 8009858:	016c0035 	.word	0x016c0035
 800985c:	016c016c 	.word	0x016c016c
 8009860:	016c016c 	.word	0x016c016c
 8009864:	016c016c 	.word	0x016c016c
 8009868:	016c016c 	.word	0x016c016c
 800986c:	014d016c 	.word	0x014d016c
 8009870:	016c015d 	.word	0x016c015d
 8009874:	016c00b0 	.word	0x016c00b0
 8009878:	015d016c 	.word	0x015d016c
 800987c:	016c016c 	.word	0x016c016c
 8009880:	016c016c 	.word	0x016c016c
 8009884:	015b016c 	.word	0x015b016c
 8009888:	016c016c 	.word	0x016c016c
 800988c:	0083016c 	.word	0x0083016c
 8009890:	00ae016c 	.word	0x00ae016c
 8009894:	016c016c 	.word	0x016c016c
 8009898:	0035      	.short	0x0035
 800989a:	2210      	movs	r2, #16
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
 800989c:	ad0a      	add	r5, sp, #40	; 0x28
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 800989e:	f8da 1000 	ldr.w	r1, [sl]
      p = ch_ltoa(p, l, c);
 80098a2:	4628      	mov	r0, r5
 80098a4:	f7ff feec 	bl	8009680 <ch_ltoa>
 80098a8:	1b40      	subs	r0, r0, r5
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80098aa:	f10a 0a04 	add.w	sl, sl, #4
 80098ae:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 80098b2:	9b01      	ldr	r3, [sp, #4]
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 80098b4:	1a24      	subs	r4, r4, r0
 80098b6:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
      width = 0;
    if (left_align == FALSE)
 80098ba:	2b00      	cmp	r3, #0
 80098bc:	d162      	bne.n	8009984 <chvprintf+0x2b4>
      width = -width;
 80098be:	f1c4 0900 	rsb	r9, r4, #0
    if (width < 0) {
 80098c2:	f1b9 0f00 	cmp.w	r9, #0
 80098c6:	f000 8129 	beq.w	8009b1c <chvprintf+0x44c>
      if (*s == '-' && filler == '0') {
 80098ca:	7829      	ldrb	r1, [r5, #0]
 80098cc:	292d      	cmp	r1, #45	; 0x2d
 80098ce:	f000 8138 	beq.w	8009b42 <chvprintf+0x472>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 80098d2:	6833      	ldr	r3, [r6, #0]
 80098d4:	4639      	mov	r1, r7
 80098d6:	689b      	ldr	r3, [r3, #8]
 80098d8:	4630      	mov	r0, r6
 80098da:	4798      	blx	r3
        n++;
      } while (++width != 0);
 80098dc:	f119 0901 	adds.w	r9, r9, #1
 80098e0:	d1f7      	bne.n	80098d2 <chvprintf+0x202>
 80098e2:	9b00      	ldr	r3, [sp, #0]
    }
    while (--i >= 0) {
 80098e4:	f1b8 0f00 	cmp.w	r8, #0
 80098e8:	4423      	add	r3, r4
 80098ea:	9300      	str	r3, [sp, #0]
 80098ec:	f6ff aef8 	blt.w	80096e0 <chvprintf+0x10>
 80098f0:	464c      	mov	r4, r9
 80098f2:	46c1      	mov	r9, r8
      chSequentialStreamPut(chp, (uint8_t)*s++);
 80098f4:	6833      	ldr	r3, [r6, #0]
 80098f6:	f815 1b01 	ldrb.w	r1, [r5], #1
 80098fa:	689b      	ldr	r3, [r3, #8]
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80098fc:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8009900:	4630      	mov	r0, r6
 8009902:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009904:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
 8009908:	d1f4      	bne.n	80098f4 <chvprintf+0x224>
 800990a:	9b00      	ldr	r3, [sp, #0]
 800990c:	3301      	adds	r3, #1
 800990e:	f1b8 0f00 	cmp.w	r8, #0
 8009912:	bfa8      	it	ge
 8009914:	4443      	addge	r3, r8
 8009916:	9300      	str	r3, [sp, #0]
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8009918:	2c00      	cmp	r4, #0
 800991a:	f43f aee1 	beq.w	80096e0 <chvprintf+0x10>
 800991e:	4625      	mov	r5, r4
      chSequentialStreamPut(chp, (uint8_t)filler);
 8009920:	6833      	ldr	r3, [r6, #0]
 8009922:	4639      	mov	r1, r7
 8009924:	689b      	ldr	r3, [r3, #8]
 8009926:	4630      	mov	r0, r6
 8009928:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800992a:	3d01      	subs	r5, #1
 800992c:	d1f8      	bne.n	8009920 <chvprintf+0x250>
 800992e:	9b00      	ldr	r3, [sp, #0]
 8009930:	4423      	add	r3, r4
 8009932:	9300      	str	r3, [sp, #0]
 8009934:	e6d4      	b.n	80096e0 <chvprintf+0x10>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8009936:	f8da 5000 	ldr.w	r5, [sl]
        s = "(null)";
 800993a:	4b99      	ldr	r3, [pc, #612]	; (8009ba0 <chvprintf+0x4d0>)
 800993c:	2d00      	cmp	r5, #0
 800993e:	bf08      	it	eq
 8009940:	461d      	moveq	r5, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8009942:	f10a 0a04 	add.w	sl, sl, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8009946:	782b      	ldrb	r3, [r5, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 8009948:	f1b8 0f00 	cmp.w	r8, #0
 800994c:	f000 80ec 	beq.w	8009b28 <chvprintf+0x458>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8009950:	2b00      	cmp	r3, #0
 8009952:	f000 80ee 	beq.w	8009b32 <chvprintf+0x462>
 8009956:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800995a:	4628      	mov	r0, r5
 800995c:	e002      	b.n	8009964 <chvprintf+0x294>
 800995e:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8009962:	d005      	beq.n	8009970 <chvprintf+0x2a0>
 8009964:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8009968:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800996c:	2b00      	cmp	r3, #0
 800996e:	d1f6      	bne.n	800995e <chvprintf+0x28e>
 8009970:	1b40      	subs	r0, r0, r5
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009972:	9b01      	ldr	r3, [sp, #4]
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8009974:	1a24      	subs	r4, r4, r0
 8009976:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800997a:	2720      	movs	r7, #32
 800997c:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009980:	2b00      	cmp	r3, #0
 8009982:	d09c      	beq.n	80098be <chvprintf+0x1ee>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009984:	f1b8 0f00 	cmp.w	r8, #0
 8009988:	dab3      	bge.n	80098f2 <chvprintf+0x222>
 800998a:	e7c5      	b.n	8009918 <chvprintf+0x248>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 800998c:	220a      	movs	r2, #10
 800998e:	e785      	b.n	800989c <chvprintf+0x1cc>
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8009990:	f10a 0a07 	add.w	sl, sl, #7
 8009994:	f02a 0a07 	bic.w	sl, sl, #7
 8009998:	e9da 0100 	ldrd	r0, r1, [sl]
 800999c:	f7f7 f880 	bl	8000aa0 <__aeabi_d2f>
      if (f < 0) {
 80099a0:	2100      	movs	r1, #0
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 80099a2:	f10a 0a08 	add.w	sl, sl, #8
 80099a6:	4681      	mov	r9, r0
      if (f < 0) {
 80099a8:	f7f7 fb78 	bl	800109c <__aeabi_fcmplt>
 80099ac:	2800      	cmp	r0, #0
 80099ae:	f040 80e8 	bne.w	8009b82 <chvprintf+0x4b2>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 80099b2:	ad0a      	add	r5, sp, #40	; 0x28
 80099b4:	462a      	mov	r2, r5
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 80099b6:	4648      	mov	r0, r9
 80099b8:	9204      	str	r2, [sp, #16]
 80099ba:	f7f6 fddd 	bl	8000578 <__aeabi_f2d>
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 80099be:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 80099c2:	f1b8 0f08 	cmp.w	r8, #8
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 80099c6:	e9cd 0102 	strd	r0, r1, [sp, #8]
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 80099ca:	9a04      	ldr	r2, [sp, #16]
 80099cc:	f200 80c7 	bhi.w	8009b5e <chvprintf+0x48e>
 80099d0:	4b74      	ldr	r3, [pc, #464]	; (8009ba4 <chvprintf+0x4d4>)
 80099d2:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
 80099d6:	4640      	mov	r0, r8
 80099d8:	f7f6 fdac 	bl	8000534 <__aeabi_ui2d>
 80099dc:	4b72      	ldr	r3, [pc, #456]	; (8009ba8 <chvprintf+0x4d8>)
 80099de:	9a04      	ldr	r2, [sp, #16]
 80099e0:	fba3 3808 	umull	r3, r8, r3, r8
 80099e4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80099e8:	ea4f 03d8 	mov.w	r3, r8, lsr #3
 80099ec:	9309      	str	r3, [sp, #36]	; 0x24
 80099ee:	4698      	mov	r8, r3
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
 80099f0:	4648      	mov	r0, r9
 80099f2:	9205      	str	r2, [sp, #20]
 80099f4:	f7f7 fb7c 	bl	80010f0 <__aeabi_f2iz>
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80099f8:	9a05      	ldr	r2, [sp, #20]

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
 80099fa:	9004      	str	r0, [sp, #16]
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80099fc:	f102 030b 	add.w	r3, r2, #11

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
 8009a00:	4686      	mov	lr, r0
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8009a02:	4601      	mov	r1, r0
 8009a04:	9305      	str	r3, [sp, #20]
 8009a06:	4618      	mov	r0, r3
 8009a08:	9208      	str	r2, [sp, #32]
  do {
    i = (int)(l % radix);
 8009a0a:	4b67      	ldr	r3, [pc, #412]	; (8009ba8 <chvprintf+0x4d8>)
 8009a0c:	fba3 230e 	umull	r2, r3, r3, lr
 8009a10:	08db      	lsrs	r3, r3, #3
 8009a12:	eb03 0983 	add.w	r9, r3, r3, lsl #2
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 8009a16:	4a64      	ldr	r2, [pc, #400]	; (8009ba8 <chvprintf+0x4d8>)
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 8009a18:	469c      	mov	ip, r3
 8009a1a:	ebae 0349 	sub.w	r3, lr, r9, lsl #1
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8009a1e:	3330      	adds	r3, #48	; 0x30
    l /= radix;
  } while ((ll /= radix) != 0);
 8009a20:	fba2 2101 	umull	r2, r1, r2, r1
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8009a24:	b2db      	uxtb	r3, r3
    l /= radix;
  } while ((ll /= radix) != 0);
 8009a26:	08c9      	lsrs	r1, r1, #3
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8009a28:	f800 3d01 	strb.w	r3, [r0, #-1]!
    l /= radix;
 8009a2c:	46e6      	mov	lr, ip
  } while ((ll /= radix) != 0);
 8009a2e:	d1ec      	bne.n	8009a0a <chvprintf+0x33a>
 8009a30:	9905      	ldr	r1, [sp, #20]
 8009a32:	9a08      	ldr	r2, [sp, #32]
 8009a34:	ebc0 0901 	rsb	r9, r0, r1
 8009a38:	4491      	add	r9, r2
 8009a3a:	e001      	b.n	8009a40 <chvprintf+0x370>
 8009a3c:	f810 3f01 	ldrb.w	r3, [r0, #1]!

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8009a40:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 8009a44:	454a      	cmp	r2, r9
 8009a46:	d1f9      	bne.n	8009a3c <chvprintf+0x36c>
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
 8009a48:	464a      	mov	r2, r9
 8009a4a:	232e      	movs	r3, #46	; 0x2e
 8009a4c:	f802 3b0c 	strb.w	r3, [r2], #12
  l = (long)((num - l) * precision);
 8009a50:	9804      	ldr	r0, [sp, #16]
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
 8009a52:	9204      	str	r2, [sp, #16]
  l = (long)((num - l) * precision);
 8009a54:	f7f6 fd7e 	bl	8000554 <__aeabi_i2d>
 8009a58:	4602      	mov	r2, r0
 8009a5a:	460b      	mov	r3, r1
 8009a5c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8009a60:	f7f6 fc2a 	bl	80002b8 <__aeabi_dsub>
 8009a64:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8009a68:	f7f6 fdda 	bl	8000620 <__aeabi_dmul>
 8009a6c:	f7f6 fff0 	bl	8000a50 <__aeabi_d2iz>
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
    ll = num;
 8009a70:	9909      	ldr	r1, [sp, #36]	; 0x24
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8009a72:	9a04      	ldr	r2, [sp, #16]
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
    ll = num;
 8009a74:	2900      	cmp	r1, #0
 8009a76:	bf08      	it	eq
 8009a78:	4680      	moveq	r8, r0
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
 8009a7a:	f109 0e01 	add.w	lr, r9, #1
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 8009a7e:	4b4a      	ldr	r3, [pc, #296]	; (8009ba8 <chvprintf+0x4d8>)
 8009a80:	fba3 1300 	umull	r1, r3, r3, r0
 8009a84:	08db      	lsrs	r3, r3, #3
 8009a86:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 8009a8a:	4619      	mov	r1, r3
 8009a8c:	eba0 034c 	sub.w	r3, r0, ip, lsl #1
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 8009a90:	4845      	ldr	r0, [pc, #276]	; (8009ba8 <chvprintf+0x4d8>)
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8009a92:	3330      	adds	r3, #48	; 0x30
    l /= radix;
  } while ((ll /= radix) != 0);
 8009a94:	fba0 0808 	umull	r0, r8, r0, r8
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8009a98:	b2db      	uxtb	r3, r3
    l /= radix;
  } while ((ll /= radix) != 0);
 8009a9a:	ea5f 08d8 	movs.w	r8, r8, lsr #3
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8009a9e:	f802 3d01 	strb.w	r3, [r2, #-1]!
    l /= radix;
 8009aa2:	4608      	mov	r0, r1
  } while ((ll /= radix) != 0);
 8009aa4:	d1eb      	bne.n	8009a7e <chvprintf+0x3ae>
 8009aa6:	9904      	ldr	r1, [sp, #16]
 8009aa8:	1a89      	subs	r1, r1, r2
 8009aaa:	1c48      	adds	r0, r1, #1
 8009aac:	4481      	add	r9, r0

  i = (int)(p + MAX_FILLER - q);
 8009aae:	4670      	mov	r0, lr
 8009ab0:	e001      	b.n	8009ab6 <chvprintf+0x3e6>
 8009ab2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  do
    *p++ = *q++;
 8009ab6:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8009aba:	4581      	cmp	r9, r0
 8009abc:	d1f9      	bne.n	8009ab2 <chvprintf+0x3e2>
 8009abe:	eb0e 0001 	add.w	r0, lr, r1
 8009ac2:	1b40      	subs	r0, r0, r5
 8009ac4:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 8009ac8:	e6f3      	b.n	80098b2 <chvprintf+0x1e2>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8009aca:	ad10      	add	r5, sp, #64	; 0x40
 8009acc:	f8da 3000 	ldr.w	r3, [sl]
 8009ad0:	f805 3d18 	strb.w	r3, [r5, #-24]!
 8009ad4:	f10d 0029 	add.w	r0, sp, #41	; 0x29
 8009ad8:	1b40      	subs	r0, r0, r5
 8009ada:	f10a 0a04 	add.w	sl, sl, #4
 8009ade:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8009ae2:	2720      	movs	r7, #32
      *p++ = va_arg(ap, int);
      break;
 8009ae4:	e6e5      	b.n	80098b2 <chvprintf+0x1e2>
 8009ae6:	2208      	movs	r2, #8
 8009ae8:	e6d8      	b.n	800989c <chvprintf+0x1cc>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8009aea:	f8da 1000 	ldr.w	r1, [sl]
      if (l < 0) {
 8009aee:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8009af0:	f10a 0a04 	add.w	sl, sl, #4
      if (l < 0) {
 8009af4:	db3d      	blt.n	8009b72 <chvprintf+0x4a2>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8009af6:	ad0a      	add	r5, sp, #40	; 0x28
 8009af8:	4628      	mov	r0, r5
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
        l = -l;
      }
      p = ch_ltoa(p, l, 10);
 8009afa:	220a      	movs	r2, #10
 8009afc:	f7ff fdc0 	bl	8009680 <ch_ltoa>
 8009b00:	1b40      	subs	r0, r0, r5
 8009b02:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
      break;
 8009b06:	e6d4      	b.n	80098b2 <chvprintf+0x1e2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8009b08:	460a      	mov	r2, r1
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8009b0a:	ad10      	add	r5, sp, #64	; 0x40
 8009b0c:	f10d 0029 	add.w	r0, sp, #41	; 0x29
 8009b10:	f805 2d18 	strb.w	r2, [r5, #-24]!
 8009b14:	1b40      	subs	r0, r0, r5
 8009b16:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
      break;
 8009b1a:	e6ca      	b.n	80098b2 <chvprintf+0x1e2>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009b1c:	f1b8 0f00 	cmp.w	r8, #0
 8009b20:	f6ff adde 	blt.w	80096e0 <chvprintf+0x10>
 8009b24:	464c      	mov	r4, r9
 8009b26:	e6e4      	b.n	80098f2 <chvprintf+0x222>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8009b28:	f647 78fe 	movw	r8, #32766	; 0x7ffe
 8009b2c:	2b00      	cmp	r3, #0
 8009b2e:	f47f af14 	bne.w	800995a <chvprintf+0x28a>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009b32:	9b01      	ldr	r3, [sp, #4]
 8009b34:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 8009b38:	bb63      	cbnz	r3, 8009b94 <chvprintf+0x4c4>
 8009b3a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 8009b3e:	2720      	movs	r7, #32
 8009b40:	e6bd      	b.n	80098be <chvprintf+0x1ee>
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8009b42:	2f30      	cmp	r7, #48	; 0x30
 8009b44:	f47f aec5 	bne.w	80098d2 <chvprintf+0x202>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8009b48:	6833      	ldr	r3, [r6, #0]
 8009b4a:	4630      	mov	r0, r6
 8009b4c:	689b      	ldr	r3, [r3, #8]
 8009b4e:	4798      	blx	r3
        n++;
 8009b50:	9b00      	ldr	r3, [sp, #0]
 8009b52:	3301      	adds	r3, #1
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8009b54:	3501      	adds	r5, #1
        n++;
 8009b56:	9300      	str	r3, [sp, #0]
 8009b58:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 8009b5c:	e6b9      	b.n	80098d2 <chvprintf+0x202>
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8009b5e:	a10e      	add	r1, pc, #56	; (adr r1, 8009b98 <chvprintf+0x4c8>)
 8009b60:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009b64:	f8df 8044 	ldr.w	r8, [pc, #68]	; 8009bac <chvprintf+0x4dc>
 8009b68:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 8009b6c:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8009b70:	e73e      	b.n	80099f0 <chvprintf+0x320>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8009b72:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8009b74:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8009b76:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8009b7a:	f10d 0029 	add.w	r0, sp, #41	; 0x29
 8009b7e:	ad0a      	add	r5, sp, #40	; 0x28
 8009b80:	e7bb      	b.n	8009afa <chvprintf+0x42a>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8009b82:	232d      	movs	r3, #45	; 0x2d
        f = -f;
 8009b84:	f109 4900 	add.w	r9, r9, #2147483648	; 0x80000000
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8009b88:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8009b8c:	f10d 0229 	add.w	r2, sp, #41	; 0x29
 8009b90:	ad0a      	add	r5, sp, #40	; 0x28
 8009b92:	e710      	b.n	80099b6 <chvprintf+0x2e6>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009b94:	2720      	movs	r7, #32
 8009b96:	e6bf      	b.n	8009918 <chvprintf+0x248>
 8009b98:	00000000 	.word	0x00000000
 8009b9c:	41cdcd65 	.word	0x41cdcd65
 8009ba0:	0800b500 	.word	0x0800b500
 8009ba4:	0800b510 	.word	0x0800b510
 8009ba8:	cccccccd 	.word	0xcccccccd
 8009bac:	05f5e100 	.word	0x05f5e100

08009bb0 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8009bb0:	2902      	cmp	r1, #2
 8009bb2:	d006      	beq.n	8009bc2 <get_descriptor+0x12>
 8009bb4:	2903      	cmp	r1, #3
 8009bb6:	d006      	beq.n	8009bc6 <get_descriptor+0x16>
 8009bb8:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 8009bba:	4806      	ldr	r0, [pc, #24]	; (8009bd4 <get_descriptor+0x24>)
 8009bbc:	bf18      	it	ne
 8009bbe:	2000      	movne	r0, #0
 8009bc0:	4770      	bx	lr
  (void)lang;
  switch (dtype) {
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8009bc2:	4805      	ldr	r0, [pc, #20]	; (8009bd8 <get_descriptor+0x28>)
 8009bc4:	4770      	bx	lr
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8009bc6:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 8009bc8:	bf9a      	itte	ls
 8009bca:	4b04      	ldrls	r3, [pc, #16]	; (8009bdc <get_descriptor+0x2c>)
 8009bcc:	eb03 00c2 	addls.w	r0, r3, r2, lsl #3
  }
  return NULL;
 8009bd0:	2000      	movhi	r0, #0
}
 8009bd2:	4770      	bx	lr
 8009bd4:	0800b6f0 	.word	0x0800b6f0
 8009bd8:	0800b570 	.word	0x0800b570
 8009bdc:	0800b6c0 	.word	0x0800b6c0

08009be0 <usb_event>:
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
  extern SerialUSBDriver SDU1;

  switch (event) {
 8009be0:	2902      	cmp	r1, #2
 8009be2:	d115      	bne.n	8009c10 <usb_event+0x30>
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8009be4:	b538      	push	{r3, r4, r5, lr}
 8009be6:	4605      	mov	r5, r0
 8009be8:	460c      	mov	r4, r1
 8009bea:	2320      	movs	r3, #32
 8009bec:	f383 8811 	msr	BASEPRI, r3
    chSysLockFromISR();

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8009bf0:	4a08      	ldr	r2, [pc, #32]	; (8009c14 <usb_event+0x34>)
 8009bf2:	2101      	movs	r1, #1
 8009bf4:	f7f9 fcec 	bl	80035d0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8009bf8:	4621      	mov	r1, r4
 8009bfa:	4628      	mov	r0, r5
 8009bfc:	4a06      	ldr	r2, [pc, #24]	; (8009c18 <usb_event+0x38>)
 8009bfe:	f7f9 fce7 	bl	80035d0 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 8009c02:	4806      	ldr	r0, [pc, #24]	; (8009c1c <usb_event+0x3c>)
 8009c04:	f7f9 fb84 	bl	8003310 <sduConfigureHookI>
 8009c08:	2300      	movs	r3, #0
 8009c0a:	f383 8811 	msr	BASEPRI, r3
 8009c0e:	bd38      	pop	{r3, r4, r5, pc}
 8009c10:	4770      	bx	lr
 8009c12:	bf00      	nop
 8009c14:	0800b540 	.word	0x0800b540
 8009c18:	0800b580 	.word	0x0800b580
 8009c1c:	20001dc8 	.word	0x20001dc8

08009c20 <adcerrorcallback>:
#define SHELL_WA_SIZE   THD_WORKING_AREA_SIZE(2048)
#define TEST_WA_SIZE    THD_WORKING_AREA_SIZE(256)
#define ADC_GRP1_NUM_CHANNELS   2
#define rb_n 30

static void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8009c20:	4770      	bx	lr
 8009c22:	bf00      	nop
	...

08009c30 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8009c30:	b40e      	push	{r1, r2, r3}
 8009c32:	b500      	push	{lr}
 8009c34:	b082      	sub	sp, #8
 8009c36:	aa03      	add	r2, sp, #12
 8009c38:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8009c3c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009c3e:	f7ff fd47 	bl	80096d0 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8009c42:	b002      	add	sp, #8
 8009c44:	f85d eb04 	ldr.w	lr, [sp], #4
 8009c48:	b003      	add	sp, #12
 8009c4a:	4770      	bx	lr
 8009c4c:	0000      	movs	r0, r0
	...

08009c50 <Thread1>:
/*
 * This is a periodic thread that reads accelerometer and outputs
 * result to SPI2 and PWM.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8009c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  static int8_t xbuf[4], ybuf[4];   /* Last accelerometer data.*/
  systime_t time;                   /* Next deadline.*/

  (void)arg;
  chRegSetThreadName("reader");
 8009c52:	4b4c      	ldr	r3, [pc, #304]	; (8009d84 <Thread1+0x134>)
 8009c54:	4a4c      	ldr	r2, [pc, #304]	; (8009d88 <Thread1+0x138>)
 8009c56:	699b      	ldr	r3, [r3, #24]

  /* LIS302DL initialization.*/
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG1, 0x43);
 8009c58:	484c      	ldr	r0, [pc, #304]	; (8009d8c <Thread1+0x13c>)
static THD_FUNCTION(Thread1, arg) {
  static int8_t xbuf[4], ybuf[4];   /* Last accelerometer data.*/
  systime_t time;                   /* Next deadline.*/

  (void)arg;
  chRegSetThreadName("reader");
 8009c5a:	619a      	str	r2, [r3, #24]

  /* LIS302DL initialization.*/
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG1, 0x43);
 8009c5c:	2120      	movs	r1, #32
 8009c5e:	2243      	movs	r2, #67	; 0x43
 8009c60:	f7ff fafe 	bl	8009260 <lis302dlWriteRegister>
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG2, 0x00);
 8009c64:	2200      	movs	r2, #0
 8009c66:	2121      	movs	r1, #33	; 0x21
 8009c68:	4848      	ldr	r0, [pc, #288]	; (8009d8c <Thread1+0x13c>)
 8009c6a:	f7ff faf9 	bl	8009260 <lis302dlWriteRegister>
  lis302dlWriteRegister(&SPID1, LIS302DL_CTRL_REG3, 0x00);
 8009c6e:	2200      	movs	r2, #0
 8009c70:	2122      	movs	r1, #34	; 0x22
 8009c72:	4846      	ldr	r0, [pc, #280]	; (8009d8c <Thread1+0x13c>)
 8009c74:	f7ff faf4 	bl	8009260 <lis302dlWriteRegister>
 8009c78:	2320      	movs	r3, #32
 8009c7a:	f383 8811 	msr	BASEPRI, r3
 8009c7e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8009c82:	2300      	movs	r3, #0
 8009c84:	6a57      	ldr	r7, [r2, #36]	; 0x24
 8009c86:	f383 8811 	msr	BASEPRI, r3
 8009c8a:	4e41      	ldr	r6, [pc, #260]	; (8009d90 <Thread1+0x140>)
 8009c8c:	4d41      	ldr	r5, [pc, #260]	; (8009d94 <Thread1+0x144>)
 8009c8e:	4942      	ldr	r1, [pc, #264]	; (8009d98 <Thread1+0x148>)
 8009c90:	4a42      	ldr	r2, [pc, #264]	; (8009d9c <Thread1+0x14c>)
 8009c92:	1c4c      	adds	r4, r1, #1
 8009c94:	1c50      	adds	r0, r2, #1
  while (true) {
    int32_t x, y;
    unsigned i;

    /* Keeping an history of the latest four accelerometer readings.*/
    for (i = 3; i > 0; i--) {
 8009c96:	2303      	movs	r3, #3
      xbuf[i] = xbuf[i - 1];
 8009c98:	f911 cd01 	ldrsb.w	ip, [r1, #-1]!
      ybuf[i] = ybuf[i - 1];
 8009c9c:	f912 ed01 	ldrsb.w	lr, [r2, #-1]!
    int32_t x, y;
    unsigned i;

    /* Keeping an history of the latest four accelerometer readings.*/
    for (i = 3; i > 0; i--) {
      xbuf[i] = xbuf[i - 1];
 8009ca0:	f804 cd01 	strb.w	ip, [r4, #-1]!
  while (true) {
    int32_t x, y;
    unsigned i;

    /* Keeping an history of the latest four accelerometer readings.*/
    for (i = 3; i > 0; i--) {
 8009ca4:	3b01      	subs	r3, #1
      xbuf[i] = xbuf[i - 1];
      ybuf[i] = ybuf[i - 1];
 8009ca6:	f800 ed01 	strb.w	lr, [r0, #-1]!
  while (true) {
    int32_t x, y;
    unsigned i;

    /* Keeping an history of the latest four accelerometer readings.*/
    for (i = 3; i > 0; i--) {
 8009caa:	d1f5      	bne.n	8009c98 <Thread1+0x48>
      xbuf[i] = xbuf[i - 1];
      ybuf[i] = ybuf[i - 1];
    }

    /* Reading MEMS accelerometer X and Y registers.*/
    xbuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTX);
 8009cac:	2129      	movs	r1, #41	; 0x29
 8009cae:	4837      	ldr	r0, [pc, #220]	; (8009d8c <Thread1+0x13c>)
 8009cb0:	f7ff fab6 	bl	8009220 <lis302dlReadRegister>
    ybuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTY);
 8009cb4:	212b      	movs	r1, #43	; 0x2b
      xbuf[i] = xbuf[i - 1];
      ybuf[i] = ybuf[i - 1];
    }

    /* Reading MEMS accelerometer X and Y registers.*/
    xbuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTX);
 8009cb6:	7030      	strb	r0, [r6, #0]
    ybuf[0] = (int8_t)lis302dlReadRegister(&SPID1, LIS302DL_OUTY);
 8009cb8:	4834      	ldr	r0, [pc, #208]	; (8009d8c <Thread1+0x13c>)
 8009cba:	f7ff fab1 	bl	8009220 <lis302dlReadRegister>
 8009cbe:	7028      	strb	r0, [r5, #0]

    /* Transmitting accelerometer the data over SPI2.*/
    spiSelect(&SPID2);
 8009cc0:	4837      	ldr	r0, [pc, #220]	; (8009da0 <Thread1+0x150>)
 8009cc2:	f7f9 fc05 	bl	80034d0 <spiSelect>
    spiSend(&SPID2, 4, xbuf);
 8009cc6:	4a32      	ldr	r2, [pc, #200]	; (8009d90 <Thread1+0x140>)
 8009cc8:	4835      	ldr	r0, [pc, #212]	; (8009da0 <Thread1+0x150>)
 8009cca:	2104      	movs	r1, #4
 8009ccc:	f7f9 fc38 	bl	8003540 <spiSend>
    spiSend(&SPID2, 4, ybuf);
 8009cd0:	4a30      	ldr	r2, [pc, #192]	; (8009d94 <Thread1+0x144>)
 8009cd2:	4833      	ldr	r0, [pc, #204]	; (8009da0 <Thread1+0x150>)
 8009cd4:	2104      	movs	r1, #4
 8009cd6:	f7f9 fc33 	bl	8003540 <spiSend>
    spiUnselect(&SPID2);
 8009cda:	4831      	ldr	r0, [pc, #196]	; (8009da0 <Thread1+0x150>)
 8009cdc:	f7f9 fc08 	bl	80034f0 <spiUnselect>

    /* Calculating average of the latest four accelerometer readings.*/
    x = ((int32_t)xbuf[0] + (int32_t)xbuf[1] +
 8009ce0:	f996 3000 	ldrsb.w	r3, [r6]
 8009ce4:	f996 1001 	ldrsb.w	r1, [r6, #1]
 8009ce8:	f996 2002 	ldrsb.w	r2, [r6, #2]
         (int32_t)xbuf[2] + (int32_t)xbuf[3]) / 4;
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
 8009cec:	f995 0001 	ldrsb.w	r0, [r5, #1]
    spiSend(&SPID2, 4, xbuf);
    spiSend(&SPID2, 4, ybuf);
    spiUnselect(&SPID2);

    /* Calculating average of the latest four accelerometer readings.*/
    x = ((int32_t)xbuf[0] + (int32_t)xbuf[1] +
 8009cf0:	f996 4003 	ldrsb.w	r4, [r6, #3]
         (int32_t)xbuf[2] + (int32_t)xbuf[3]) / 4;
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
 8009cf4:	f995 e003 	ldrsb.w	lr, [r5, #3]
    spiSend(&SPID2, 4, xbuf);
    spiSend(&SPID2, 4, ybuf);
    spiUnselect(&SPID2);

    /* Calculating average of the latest four accelerometer readings.*/
    x = ((int32_t)xbuf[0] + (int32_t)xbuf[1] +
 8009cf8:	4419      	add	r1, r3
 8009cfa:	188b      	adds	r3, r1, r2
         (int32_t)xbuf[2] + (int32_t)xbuf[3]) / 4;
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
 8009cfc:	f995 2000 	ldrsb.w	r2, [r5]
 8009d00:	f995 1002 	ldrsb.w	r1, [r5, #2]
 8009d04:	4402      	add	r2, r0
    spiSend(&SPID2, 4, xbuf);
    spiSend(&SPID2, 4, ybuf);
    spiUnselect(&SPID2);

    /* Calculating average of the latest four accelerometer readings.*/
    x = ((int32_t)xbuf[0] + (int32_t)xbuf[1] +
 8009d06:	191b      	adds	r3, r3, r4
         (int32_t)xbuf[2] + (int32_t)xbuf[3]) / 4;
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
 8009d08:	440a      	add	r2, r1
    spiSend(&SPID2, 4, xbuf);
    spiSend(&SPID2, 4, ybuf);
    spiUnselect(&SPID2);

    /* Calculating average of the latest four accelerometer readings.*/
    x = ((int32_t)xbuf[0] + (int32_t)xbuf[1] +
 8009d0a:	bf48      	it	mi
 8009d0c:	3303      	addmi	r3, #3
         (int32_t)xbuf[2] + (int32_t)xbuf[3]) / 4;
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
 8009d0e:	eb12 020e 	adds.w	r2, r2, lr
 8009d12:	bf48      	it	mi
 8009d14:	3203      	addmi	r2, #3
         (int32_t)ybuf[2] + (int32_t)ybuf[3]) / 4;

    /* Reprogramming the four PWM channels using the accelerometer data.*/
    if (y < 0) {
 8009d16:	1092      	asrs	r2, r2, #2
    spiSend(&SPID2, 4, xbuf);
    spiSend(&SPID2, 4, ybuf);
    spiUnselect(&SPID2);

    /* Calculating average of the latest four accelerometer readings.*/
    x = ((int32_t)xbuf[0] + (int32_t)xbuf[1] +
 8009d18:	ea4f 04a3 	mov.w	r4, r3, asr #2
         (int32_t)xbuf[2] + (int32_t)xbuf[3]) / 4;
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
         (int32_t)ybuf[2] + (int32_t)ybuf[3]) / 4;

    /* Reprogramming the four PWM channels using the accelerometer data.*/
    if (y < 0) {
 8009d1c:	d41a      	bmi.n	8009d54 <Thread1+0x104>
      pwmEnableChannel(&PWMD4, 0, (pwmcnt_t)-y);
      pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)0);
    }
    else {
      pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)y);
 8009d1e:	2102      	movs	r1, #2
 8009d20:	4820      	ldr	r0, [pc, #128]	; (8009da4 <Thread1+0x154>)
 8009d22:	f7f9 f955 	bl	8002fd0 <pwmEnableChannel>
      pwmEnableChannel(&PWMD4, 0, (pwmcnt_t)0);
 8009d26:	2200      	movs	r2, #0
 8009d28:	4611      	mov	r1, r2
 8009d2a:	481e      	ldr	r0, [pc, #120]	; (8009da4 <Thread1+0x154>)
 8009d2c:	f7f9 f950 	bl	8002fd0 <pwmEnableChannel>
    }
    if (x < 0) {
 8009d30:	2c00      	cmp	r4, #0
 8009d32:	db1b      	blt.n	8009d6c <Thread1+0x11c>
      pwmEnableChannel(&PWMD4, 1, (pwmcnt_t)-x);
      pwmEnableChannel(&PWMD4, 3, (pwmcnt_t)0);
    }
    else {
      pwmEnableChannel(&PWMD4, 3, (pwmcnt_t)x);
 8009d34:	4622      	mov	r2, r4
 8009d36:	2103      	movs	r1, #3
 8009d38:	481a      	ldr	r0, [pc, #104]	; (8009da4 <Thread1+0x154>)
 8009d3a:	f7f9 f949 	bl	8002fd0 <pwmEnableChannel>
      pwmEnableChannel(&PWMD4, 1, (pwmcnt_t)0);
 8009d3e:	2200      	movs	r2, #0
 8009d40:	2101      	movs	r1, #1
 8009d42:	4818      	ldr	r0, [pc, #96]	; (8009da4 <Thread1+0x154>)
 8009d44:	f7f9 f944 	bl	8002fd0 <pwmEnableChannel>
    }

    /* Waiting until the next 250 milliseconds time interval.*/
    chThdSleepUntil(time += MS2ST(100));
 8009d48:	f507 777a 	add.w	r7, r7, #1000	; 0x3e8
 8009d4c:	4638      	mov	r0, r7
 8009d4e:	f7f7 fdd7 	bl	8001900 <chThdSleepUntil>
  }
 8009d52:	e79c      	b.n	8009c8e <Thread1+0x3e>
    y = ((int32_t)ybuf[0] + (int32_t)ybuf[1] +
         (int32_t)ybuf[2] + (int32_t)ybuf[3]) / 4;

    /* Reprogramming the four PWM channels using the accelerometer data.*/
    if (y < 0) {
      pwmEnableChannel(&PWMD4, 0, (pwmcnt_t)-y);
 8009d54:	4252      	negs	r2, r2
 8009d56:	2100      	movs	r1, #0
 8009d58:	4812      	ldr	r0, [pc, #72]	; (8009da4 <Thread1+0x154>)
 8009d5a:	f7f9 f939 	bl	8002fd0 <pwmEnableChannel>
      pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)0);
 8009d5e:	2200      	movs	r2, #0
 8009d60:	2102      	movs	r1, #2
 8009d62:	4810      	ldr	r0, [pc, #64]	; (8009da4 <Thread1+0x154>)
 8009d64:	f7f9 f934 	bl	8002fd0 <pwmEnableChannel>
    }
    else {
      pwmEnableChannel(&PWMD4, 2, (pwmcnt_t)y);
      pwmEnableChannel(&PWMD4, 0, (pwmcnt_t)0);
    }
    if (x < 0) {
 8009d68:	2c00      	cmp	r4, #0
 8009d6a:	dae3      	bge.n	8009d34 <Thread1+0xe4>
      pwmEnableChannel(&PWMD4, 1, (pwmcnt_t)-x);
 8009d6c:	4262      	negs	r2, r4
 8009d6e:	2101      	movs	r1, #1
 8009d70:	480c      	ldr	r0, [pc, #48]	; (8009da4 <Thread1+0x154>)
 8009d72:	f7f9 f92d 	bl	8002fd0 <pwmEnableChannel>
      pwmEnableChannel(&PWMD4, 3, (pwmcnt_t)0);
 8009d76:	2200      	movs	r2, #0
 8009d78:	2103      	movs	r1, #3
 8009d7a:	480a      	ldr	r0, [pc, #40]	; (8009da4 <Thread1+0x154>)
 8009d7c:	f7f9 f928 	bl	8002fd0 <pwmEnableChannel>
 8009d80:	e7e2      	b.n	8009d48 <Thread1+0xf8>
 8009d82:	bf00      	nop
 8009d84:	20000e78 	.word	0x20000e78
 8009d88:	0800b750 	.word	0x0800b750
 8009d8c:	20001278 	.word	0x20001278
 8009d90:	20002020 	.word	0x20002020
 8009d94:	200020a4 	.word	0x200020a4
 8009d98:	20002023 	.word	0x20002023
 8009d9c:	200020a7 	.word	0x200020a7
 8009da0:	200012a8 	.word	0x200012a8
 8009da4:	200012dc 	.word	0x200012dc
	...

08009db0 <cmd_test>:

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8009db0:	2900      	cmp	r1, #0
 8009db2:	dd02      	ble.n	8009dba <cmd_test+0xa>
    chprintf(chp, "Usage: test\r\n");
 8009db4:	490e      	ldr	r1, [pc, #56]	; (8009df0 <cmd_test+0x40>)
 8009db6:	f7ff bf3b 	b.w	8009c30 <chprintf>
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009dba:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8009dbc:	4a0d      	ldr	r2, [pc, #52]	; (8009df4 <cmd_test+0x44>)
  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: test\r\n");
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
 8009dbe:	4b0e      	ldr	r3, [pc, #56]	; (8009df8 <cmd_test+0x48>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8009dc0:	6992      	ldr	r2, [r2, #24]
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009dc2:	b082      	sub	sp, #8
 8009dc4:	4604      	mov	r4, r0
  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: test\r\n");
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
 8009dc6:	6892      	ldr	r2, [r2, #8]
 8009dc8:	9000      	str	r0, [sp, #0]
 8009dca:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8009dce:	2000      	movs	r0, #0
 8009dd0:	f7f7 feee 	bl	8001bb0 <chThdCreateFromHeap>
                           TestThread, chp);
  if (tp == NULL) {
 8009dd4:	b120      	cbz	r0, 8009de0 <cmd_test+0x30>
    chprintf(chp, "out of memory\r\n");
    return;
  }
  chThdWait(tp);
}
 8009dd6:	b002      	add	sp, #8
 8009dd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                           TestThread, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
    return;
  }
  chThdWait(tp);
 8009ddc:	f7f7 bde0 	b.w	80019a0 <chThdWait>
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
                           TestThread, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
 8009de0:	4906      	ldr	r1, [pc, #24]	; (8009dfc <cmd_test+0x4c>)
 8009de2:	4620      	mov	r0, r4
    return;
  }
  chThdWait(tp);
}
 8009de4:	b002      	add	sp, #8
 8009de6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
                           TestThread, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
 8009dea:	f7ff bf21 	b.w	8009c30 <chprintf>
 8009dee:	bf00      	nop
 8009df0:	0800b758 	.word	0x0800b758
 8009df4:	20000e78 	.word	0x20000e78
 8009df8:	08005b81 	.word	0x08005b81
 8009dfc:	0800b768 	.word	0x0800b768

08009e00 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8009e00:	2900      	cmp	r1, #0
 8009e02:	dd02      	ble.n	8009e0a <cmd_threads+0xa>
    chprintf(chp, "Usage: threads\r\n");
 8009e04:	4911      	ldr	r1, [pc, #68]	; (8009e4c <cmd_threads+0x4c>)
 8009e06:	f7ff bf13 	b.w	8009c30 <chprintf>
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009e0a:	b570      	push	{r4, r5, r6, lr}
  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: threads\r\n");
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
 8009e0c:	4910      	ldr	r1, [pc, #64]	; (8009e50 <cmd_threads+0x50>)
 8009e0e:	4e11      	ldr	r6, [pc, #68]	; (8009e54 <cmd_threads+0x54>)
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009e10:	b084      	sub	sp, #16
 8009e12:	4605      	mov	r5, r0
  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: threads\r\n");
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
 8009e14:	f7ff ff0c 	bl	8009c30 <chprintf>
  tp = chRegFirstThread();
 8009e18:	f7f7 ff12 	bl	8001c40 <chRegFirstThread>
 8009e1c:	4604      	mov	r4, r0
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 8009e1e:	7f22      	ldrb	r2, [r4, #28]
 8009e20:	68e3      	ldr	r3, [r4, #12]
 8009e22:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 8009e26:	9202      	str	r2, [sp, #8]
 8009e28:	7fa2      	ldrb	r2, [r4, #30]
 8009e2a:	490b      	ldr	r1, [pc, #44]	; (8009e58 <cmd_threads+0x58>)
 8009e2c:	3a01      	subs	r2, #1
 8009e2e:	9201      	str	r2, [sp, #4]
 8009e30:	68a2      	ldr	r2, [r4, #8]
 8009e32:	9200      	str	r2, [sp, #0]
 8009e34:	4628      	mov	r0, r5
 8009e36:	4622      	mov	r2, r4
 8009e38:	f7ff fefa 	bl	8009c30 <chprintf>
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
             states[tp->p_state]);
    tp = chRegNextThread(tp);
 8009e3c:	4620      	mov	r0, r4
 8009e3e:	f7f7 ff0f 	bl	8001c60 <chRegNextThread>
  } while (tp != NULL);
 8009e42:	4604      	mov	r4, r0
 8009e44:	2800      	cmp	r0, #0
 8009e46:	d1ea      	bne.n	8009e1e <cmd_threads+0x1e>
}
 8009e48:	b004      	add	sp, #16
 8009e4a:	bd70      	pop	{r4, r5, r6, pc}
 8009e4c:	0800b778 	.word	0x0800b778
 8009e50:	0800b78c 	.word	0x0800b78c
 8009e54:	0800b960 	.word	0x0800b960
 8009e58:	0800b7b4 	.word	0x0800b7b4
 8009e5c:	00000000 	.word	0x00000000

08009e60 <cmd_mem>:
	   } 

}


static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009e60:	b530      	push	{r4, r5, lr}
  size_t n, size;
 (void)argv;
  if (argc > 0) {
 8009e62:	2900      	cmp	r1, #0
	   } 

}


static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8009e64:	b083      	sub	sp, #12
  size_t n, size;
 (void)argv;
  if (argc > 0) {
 8009e66:	dd04      	ble.n	8009e72 <cmd_mem+0x12>
    chprintf(chp, "Usage: mem\r\n");
 8009e68:	490e      	ldr	r1, [pc, #56]	; (8009ea4 <cmd_mem+0x44>)
 8009e6a:	f7ff fee1 	bl	8009c30 <chprintf>
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}
 8009e6e:	b003      	add	sp, #12
 8009e70:	bd30      	pop	{r4, r5, pc}
 8009e72:	4604      	mov	r4, r0
 (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: mem\r\n");
    return;
  }
  n = chHeapStatus(NULL, &size);
 8009e74:	a901      	add	r1, sp, #4
 8009e76:	2000      	movs	r0, #0
 8009e78:	f7f8 ff5a 	bl	8002d30 <chHeapStatus>
 8009e7c:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
 8009e7e:	f7f8 fe8f 	bl	8002ba0 <chCoreGetStatusX>
 8009e82:	4909      	ldr	r1, [pc, #36]	; (8009ea8 <cmd_mem+0x48>)
 8009e84:	4602      	mov	r2, r0
 8009e86:	4620      	mov	r0, r4
 8009e88:	f7ff fed2 	bl	8009c30 <chprintf>
  chprintf(chp, "heap fragments   : %u\r\n", n);
 8009e8c:	462a      	mov	r2, r5
 8009e8e:	4907      	ldr	r1, [pc, #28]	; (8009eac <cmd_mem+0x4c>)
 8009e90:	4620      	mov	r0, r4
 8009e92:	f7ff fecd 	bl	8009c30 <chprintf>
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 8009e96:	4620      	mov	r0, r4
 8009e98:	9a01      	ldr	r2, [sp, #4]
 8009e9a:	4905      	ldr	r1, [pc, #20]	; (8009eb0 <cmd_mem+0x50>)
 8009e9c:	f7ff fec8 	bl	8009c30 <chprintf>
}
 8009ea0:	b003      	add	sp, #12
 8009ea2:	bd30      	pop	{r4, r5, pc}
 8009ea4:	0800b7d0 	.word	0x0800b7d0
 8009ea8:	0800b7e0 	.word	0x0800b7e0
 8009eac:	0800b800 	.word	0x0800b800
 8009eb0:	0800b818 	.word	0x0800b818
	...

08009ec0 <calc_mean>:
//const int rb_n = 5;   //FİLTRE ELEMAN SAYISI
int rb_i = 0;
float rb_data[rb_n];
float tempOflm35;
float rb_get_element(int j){
	int t = rb_i + j;
 8009ec0:	4913      	ldr	r1, [pc, #76]	; (8009f10 <calc_mean+0x50>)
 8009ec2:	680b      	ldr	r3, [r1, #0]
 8009ec4:	f103 021d 	add.w	r2, r3, #29
	if(t > rb_n-1){
 8009ec8:	2a1d      	cmp	r2, #29
	  t = t - rb_n ;
 8009eca:	bfca      	itet	gt
 8009ecc:	f103 32ff 	addgt.w	r2, r3, #4294967295	; 0xffffffff
 8009ed0:	f103 33ff 	addle.w	r3, r3, #4294967295	; 0xffffffff
 8009ed4:	4613      	movgt	r3, r2
}

float rb_put_element(float v){
	float r = rb_get_element(rb_n-1);
	rb_i = rb_i - 1 ;
	if(rb_i<0){
 8009ed6:	2b00      	cmp	r3, #0
}

float mean = 0;

float calc_mean(float input)
{
 8009ed8:	b570      	push	{r4, r5, r6, lr}

float rb_put_element(float v){
	float r = rb_get_element(rb_n-1);
	rb_i = rb_i - 1 ;
	if(rb_i<0){
	rb_i = rb_n-1;
 8009eda:	bfb8      	it	lt
 8009edc:	231d      	movlt	r3, #29
float rb_get_element(int j){
	int t = rb_i + j;
	if(t > rb_n-1){
	  t = t - rb_n ;
	}
	return rb_data[t];
 8009ede:	4d0d      	ldr	r5, [pc, #52]	; (8009f14 <calc_mean+0x54>)
{
	float v0;
	float vout;
	v0 = input;
	vout  = rb_put_element(v0);  // v0 new data , vout old data
	mean = mean  + v0/rb_n  - vout/rb_n;
 8009ee0:	4c0d      	ldr	r4, [pc, #52]	; (8009f18 <calc_mean+0x58>)
float rb_get_element(int j){
	int t = rb_i + j;
	if(t > rb_n-1){
	  t = t - rb_n ;
	}
	return rb_data[t];
 8009ee2:	f855 6022 	ldr.w	r6, [r5, r2, lsl #2]

float rb_put_element(float v){
	float r = rb_get_element(rb_n-1);
	rb_i = rb_i - 1 ;
	if(rb_i<0){
	rb_i = rb_n-1;
 8009ee6:	600b      	str	r3, [r1, #0]
	} 
	rb_data[rb_i] = v;
 8009ee8:	f845 0023 	str.w	r0, [r5, r3, lsl #2]
{
	float v0;
	float vout;
	v0 = input;
	vout  = rb_put_element(v0);  // v0 new data , vout old data
	mean = mean  + v0/rb_n  - vout/rb_n;
 8009eec:	490b      	ldr	r1, [pc, #44]	; (8009f1c <calc_mean+0x5c>)
 8009eee:	f7f6 ffeb 	bl	8000ec8 <__aeabi_fdiv>
 8009ef2:	6821      	ldr	r1, [r4, #0]
 8009ef4:	f7f6 fe2a 	bl	8000b4c <__addsf3>
 8009ef8:	4908      	ldr	r1, [pc, #32]	; (8009f1c <calc_mean+0x5c>)
 8009efa:	4605      	mov	r5, r0
 8009efc:	4630      	mov	r0, r6
 8009efe:	f7f6 ffe3 	bl	8000ec8 <__aeabi_fdiv>
 8009f02:	4601      	mov	r1, r0
 8009f04:	4628      	mov	r0, r5
 8009f06:	f7f6 fe1f 	bl	8000b48 <__aeabi_fsub>
 8009f0a:	6020      	str	r0, [r4, #0]
  return mean;
}
 8009f0c:	bd70      	pop	{r4, r5, r6, pc}
 8009f0e:	bf00      	nop
 8009f10:	200020a8 	.word	0x200020a8
 8009f14:	20002024 	.word	0x20002024
 8009f18:	200020a0 	.word	0x200020a0
 8009f1c:	41f00000 	.word	0x41f00000

08009f20 <getTemperature>:

float getTemperature(void)
{
 8009f20:	b510      	push	{r4, lr}

  adcStart(&ADCD1, NULL);   // Config file is emty so using  null
 8009f22:	4c15      	ldr	r4, [pc, #84]	; (8009f78 <getTemperature+0x58>)
	mean = mean  + v0/rb_n  - vout/rb_n;
  return mean;
}

float getTemperature(void)
{
 8009f24:	b082      	sub	sp, #8

  adcStart(&ADCD1, NULL);   // Config file is emty so using  null
 8009f26:	4620      	mov	r0, r4
 8009f28:	2100      	movs	r1, #0
 8009f2a:	f7f9 f801 	bl	8002f30 <adcStart>
  adcSTM32EnableTSVREFE();
 8009f2e:	f7fa faaf 	bl	8004490 <adcSTM32EnableTSVREFE>
  adcsample_t sample[1];
  adcConvert(&ADCD1, &adcgrpcfg1, sample, 1);
 8009f32:	aa01      	add	r2, sp, #4
 8009f34:	2301      	movs	r3, #1
 8009f36:	4620      	mov	r0, r4
 8009f38:	4910      	ldr	r1, [pc, #64]	; (8009f7c <getTemperature+0x5c>)
 8009f3a:	f7f9 f809 	bl	8002f50 <adcConvert>
  tempOflm35 = ((sample[0]*3.0/4096)/0.01) ;  // for lm35 temperature sensor
 8009f3e:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8009f42:	f7f6 fb07 	bl	8000554 <__aeabi_i2d>
 8009f46:	2200      	movs	r2, #0
 8009f48:	4b0d      	ldr	r3, [pc, #52]	; (8009f80 <getTemperature+0x60>)
 8009f4a:	f7f6 fb69 	bl	8000620 <__aeabi_dmul>
 8009f4e:	2200      	movs	r2, #0
 8009f50:	4b0c      	ldr	r3, [pc, #48]	; (8009f84 <getTemperature+0x64>)
 8009f52:	f7f6 fb65 	bl	8000620 <__aeabi_dmul>
 8009f56:	a306      	add	r3, pc, #24	; (adr r3, 8009f70 <getTemperature+0x50>)
 8009f58:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009f5c:	f7f6 fc8a 	bl	8000874 <__aeabi_ddiv>
 8009f60:	f7f6 fd9e 	bl	8000aa0 <__aeabi_d2f>
 8009f64:	4b08      	ldr	r3, [pc, #32]	; (8009f88 <getTemperature+0x68>)
 8009f66:	6018      	str	r0, [r3, #0]

  return tempOflm35;
}
 8009f68:	b002      	add	sp, #8
 8009f6a:	bd10      	pop	{r4, pc}
 8009f6c:	f3af 8000 	nop.w
 8009f70:	47ae147b 	.word	0x47ae147b
 8009f74:	3f847ae1 	.word	0x3f847ae1
 8009f78:	20001074 	.word	0x20001074
 8009f7c:	0800b920 	.word	0x0800b920
 8009f80:	40080000 	.word	0x40080000
 8009f84:	3f300000 	.word	0x3f300000
 8009f88:	2000209c 	.word	0x2000209c
 8009f8c:	00000000 	.word	0x00000000

08009f90 <pin_on_remote>:
  char led_off_data_loc[] = {0x7E, 0x00, 0x05, 0x08, 0x01, 0x44, 0x35, 0x04, 0x79};     //led off
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , led_off_data_loc, sizeof(led_off_data_loc));
}

void pin_on_remote(void)
{
 8009f90:	b5f0      	push	{r4, r5, r6, r7, lr}

  char pin_on_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x05, 0x6C};
 8009f92:	4d0a      	ldr	r5, [pc, #40]	; (8009fbc <pin_on_remote+0x2c>)
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_on_data_rem, sizeof(pin_on_data_rem));
 8009f94:	4e0a      	ldr	r6, [pc, #40]	; (8009fc0 <pin_on_remote+0x30>)
}

void pin_on_remote(void)
{

  char pin_on_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x05, 0x6C};
 8009f96:	f855 0f18 	ldr.w	r0, [r5, #24]!
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_on_data_rem, sizeof(pin_on_data_rem));
 8009f9a:	6837      	ldr	r7, [r6, #0]
}

void pin_on_remote(void)
{

  char pin_on_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x05, 0x6C};
 8009f9c:	6869      	ldr	r1, [r5, #4]
 8009f9e:	68aa      	ldr	r2, [r5, #8]
 8009fa0:	68eb      	ldr	r3, [r5, #12]
  char led_off_data_loc[] = {0x7E, 0x00, 0x05, 0x08, 0x01, 0x44, 0x35, 0x04, 0x79};     //led off
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , led_off_data_loc, sizeof(led_off_data_loc));
}

void pin_on_remote(void)
{
 8009fa2:	b087      	sub	sp, #28

  char pin_on_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x05, 0x6C};
 8009fa4:	ac01      	add	r4, sp, #4
 8009fa6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8009fa8:	6928      	ldr	r0, [r5, #16]
 8009faa:	6020      	str	r0, [r4, #0]
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_on_data_rem, sizeof(pin_on_data_rem));
 8009fac:	683b      	ldr	r3, [r7, #0]
 8009fae:	4630      	mov	r0, r6
 8009fb0:	2214      	movs	r2, #20
 8009fb2:	a901      	add	r1, sp, #4
 8009fb4:	4798      	blx	r3
}
 8009fb6:	b007      	add	sp, #28
 8009fb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009fba:	bf00      	nop
 8009fbc:	0800a3f0 	.word	0x0800a3f0
 8009fc0:	200012f8 	.word	0x200012f8
	...

08009fd0 <pin_off_remote>:

void pin_off_remote(void){
 8009fd0:	b5f0      	push	{r4, r5, r6, r7, lr}

  char pin_off_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x04, 0x6D};
 8009fd2:	4d0a      	ldr	r5, [pc, #40]	; (8009ffc <pin_off_remote+0x2c>)
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_off_data_rem, sizeof(pin_off_data_rem)); 
 8009fd4:	4e0a      	ldr	r6, [pc, #40]	; (800a000 <pin_off_remote+0x30>)
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_on_data_rem, sizeof(pin_on_data_rem));
}

void pin_off_remote(void){

  char pin_off_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x04, 0x6D};
 8009fd6:	f855 0f2c 	ldr.w	r0, [r5, #44]!
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_off_data_rem, sizeof(pin_off_data_rem)); 
 8009fda:	6837      	ldr	r7, [r6, #0]
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_on_data_rem, sizeof(pin_on_data_rem));
}

void pin_off_remote(void){

  char pin_off_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x04, 0x6D};
 8009fdc:	6869      	ldr	r1, [r5, #4]
 8009fde:	68aa      	ldr	r2, [r5, #8]
 8009fe0:	68eb      	ldr	r3, [r5, #12]

  char pin_on_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x05, 0x6C};
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_on_data_rem, sizeof(pin_on_data_rem));
}

void pin_off_remote(void){
 8009fe2:	b087      	sub	sp, #28

  char pin_off_data_rem[] = {0x7E, 0x00, 0x10, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x02, 0x44, 0x35, 0x04, 0x6D};
 8009fe4:	ac01      	add	r4, sp, #4
 8009fe6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8009fe8:	6928      	ldr	r0, [r5, #16]
 8009fea:	6020      	str	r0, [r4, #0]
  chSequentialStreamWrite((BaseSequentialStream* ) &SD2 , pin_off_data_rem, sizeof(pin_off_data_rem)); 
 8009fec:	683b      	ldr	r3, [r7, #0]
 8009fee:	4630      	mov	r0, r6
 8009ff0:	2214      	movs	r2, #20
 8009ff2:	a901      	add	r1, sp, #4
 8009ff4:	4798      	blx	r3

}
 8009ff6:	b007      	add	sp, #28
 8009ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009ffa:	bf00      	nop
 8009ffc:	0800a3f0 	.word	0x0800a3f0
 800a000:	200012f8 	.word	0x200012f8
	...

0800a010 <Thread2>:


static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
 800a010:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800a014:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 800a0f8 <Thread2+0xe8>
 800a018:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 800a0fc <Thread2+0xec>
 800a01c:	b086      	sub	sp, #24
  (void)arg;
  float diff;
  float prevSample = 0;
  int state = 0;      
  int base_counter = rb_n;
 800a01e:	271e      	movs	r7, #30
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
  (void)arg;
  float diff;
  float prevSample = 0;
  int state = 0;      
 800a020:	2400      	movs	r4, #0

static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
  (void)arg;
  float diff;
  float prevSample = 0;
 800a022:	f04f 0800 	mov.w	r8, #0
  int state = 0;      
  int base_counter = rb_n;

	  while(true)
	   {  
	  	float temp = getTemperature();
 800a026:	f7ff ff7b 	bl	8009f20 <getTemperature>
 800a02a:	4606      	mov	r6, r0
      float filteredTemp = calc_mean(temp);
 800a02c:	f7ff ff48 	bl	8009ec0 <calc_mean>
 800a030:	4605      	mov	r5, r0
      diff = filteredTemp - prevSample;
      chThdSleepMilliseconds(1000);
 800a032:	f242 7010 	movw	r0, #10000	; 0x2710
 800a036:	f7f7 fc53 	bl	80018e0 <chThdSleep>
      
      if (SDU1.config->usbp->state == USB_ACTIVE) {
 800a03a:	f8d9 3254 	ldr.w	r3, [r9, #596]	; 0x254
 800a03e:	681b      	ldr	r3, [r3, #0]
 800a040:	781b      	ldrb	r3, [r3, #0]
 800a042:	2b04      	cmp	r3, #4
 800a044:	d018      	beq.n	800a078 <Thread2+0x68>
       chprintf((BaseSequentialStream*)&SDU1, "%f,%f,%f\r\n",mean,temp,diff);
      }
	   
      prevSample = filteredTemp;
      
      if (state == 0 )     //pre-wait
 800a046:	2c00      	cmp	r4, #0
 800a048:	d133      	bne.n	800a0b2 <Thread2+0xa2>
      { 
       base_counter--;
       if(base_counter == 0) state = 1;  
 800a04a:	3f01      	subs	r7, #1
 800a04c:	d112      	bne.n	800a074 <Thread2+0x64>
      }
      if(state == 1)       //wait state
      {
        if( temp > 60 && temp-mean > 1.5) state = 2 ;   
 800a04e:	4928      	ldr	r1, [pc, #160]	; (800a0f0 <Thread2+0xe0>)
 800a050:	4630      	mov	r0, r6
 800a052:	f7f7 f841 	bl	80010d8 <__aeabi_fcmpgt>
 800a056:	2800      	cmp	r0, #0
 800a058:	d048      	beq.n	800a0ec <Thread2+0xdc>
 800a05a:	f8da 1000 	ldr.w	r1, [sl]
 800a05e:	4630      	mov	r0, r6
 800a060:	f7f6 fd72 	bl	8000b48 <__aeabi_fsub>
 800a064:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 800a068:	f7f7 f836 	bl	80010d8 <__aeabi_fcmpgt>
 800a06c:	2800      	cmp	r0, #0
 800a06e:	bf14      	ite	ne
 800a070:	2402      	movne	r4, #2
 800a072:	2401      	moveq	r4, #1
 800a074:	46a8      	mov	r8, r5
 800a076:	e7d6      	b.n	800a026 <Thread2+0x16>
      float filteredTemp = calc_mean(temp);
      diff = filteredTemp - prevSample;
      chThdSleepMilliseconds(1000);
      
      if (SDU1.config->usbp->state == USB_ACTIVE) {
       chprintf((BaseSequentialStream*)&SDU1, "%f,%f,%f\r\n",mean,temp,diff);
 800a078:	f8da 0000 	ldr.w	r0, [sl]
 800a07c:	f7f6 fa7c 	bl	8000578 <__aeabi_f2d>
 800a080:	4602      	mov	r2, r0
 800a082:	460b      	mov	r3, r1
 800a084:	4628      	mov	r0, r5
 800a086:	4641      	mov	r1, r8
 800a088:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800a08c:	f7f6 fd5c 	bl	8000b48 <__aeabi_fsub>
 800a090:	f7f6 fa72 	bl	8000578 <__aeabi_f2d>
 800a094:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a098:	4630      	mov	r0, r6
 800a09a:	f7f6 fa6d 	bl	8000578 <__aeabi_f2d>
 800a09e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800a0a2:	e9cd 0100 	strd	r0, r1, [sp]
 800a0a6:	4913      	ldr	r1, [pc, #76]	; (800a0f4 <Thread2+0xe4>)
 800a0a8:	4813      	ldr	r0, [pc, #76]	; (800a0f8 <Thread2+0xe8>)
 800a0aa:	f7ff fdc1 	bl	8009c30 <chprintf>
      }
	   
      prevSample = filteredTemp;
      
      if (state == 0 )     //pre-wait
 800a0ae:	2c00      	cmp	r4, #0
 800a0b0:	d0cb      	beq.n	800a04a <Thread2+0x3a>
      { 
       base_counter--;
       if(base_counter == 0) state = 1;  
      }
      if(state == 1)       //wait state
 800a0b2:	2c01      	cmp	r4, #1
 800a0b4:	d0cb      	beq.n	800a04e <Thread2+0x3e>
      {
        if( temp > 60 && temp-mean > 1.5) state = 2 ;   

      }
      else if(state == 2)  //started state
 800a0b6:	2c02      	cmp	r4, #2
 800a0b8:	d00b      	beq.n	800a0d2 <Thread2+0xc2>
      {
        if(temp-mean < 0.5 ) state = 3 ;  
      }
      else if(state ==3)   //finish state
 800a0ba:	2c03      	cmp	r4, #3
 800a0bc:	d1da      	bne.n	800a074 <Thread2+0x64>
      {
        pin_on_remote();
 800a0be:	f7ff ff67 	bl	8009f90 <pin_on_remote>
        chThdSleepMilliseconds(4000);
 800a0c2:	f649 4040 	movw	r0, #40000	; 0x9c40
 800a0c6:	f7f7 fc0b 	bl	80018e0 <chThdSleep>
        pin_off_remote();
          
        state = 0;
 800a0ca:	2400      	movs	r4, #0
      }
      else if(state ==3)   //finish state
      {
        pin_on_remote();
        chThdSleepMilliseconds(4000);
        pin_off_remote();
 800a0cc:	f7ff ff80 	bl	8009fd0 <pin_off_remote>
 800a0d0:	e7d0      	b.n	800a074 <Thread2+0x64>
        if( temp > 60 && temp-mean > 1.5) state = 2 ;   

      }
      else if(state == 2)  //started state
      {
        if(temp-mean < 0.5 ) state = 3 ;  
 800a0d2:	f8da 1000 	ldr.w	r1, [sl]
 800a0d6:	4630      	mov	r0, r6
 800a0d8:	f7f6 fd36 	bl	8000b48 <__aeabi_fsub>
 800a0dc:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800a0e0:	f7f6 ffdc 	bl	800109c <__aeabi_fcmplt>
 800a0e4:	2800      	cmp	r0, #0
 800a0e6:	bf18      	it	ne
 800a0e8:	2403      	movne	r4, #3
 800a0ea:	e7c3      	b.n	800a074 <Thread2+0x64>
 800a0ec:	2401      	movs	r4, #1
 800a0ee:	e7c1      	b.n	800a074 <Thread2+0x64>
 800a0f0:	42700000 	.word	0x42700000
 800a0f4:	0800b838 	.word	0x0800b838
 800a0f8:	20001dc8 	.word	0x20001dc8
 800a0fc:	200020a0 	.word	0x200020a0

0800a100 <main>:

/*
 * Application entry point.
 */

int main(void) {
 800a100:	b570      	push	{r4, r5, r6, lr}
 800a102:	b082      	sub	sp, #8
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 800a104:	f7f8 febc 	bl	8002e80 <halInit>
 800a108:	4d49      	ldr	r5, [pc, #292]	; (800a230 <main+0x130>)
  /*
   * Initializes a serial-over-USB CDC driver.
   */

  sduObjectInit(&SDU1);
  sduStart(&SDU1, &serusbcfg);
 800a10a:	4e4a      	ldr	r6, [pc, #296]	; (800a234 <main+0x134>)
   * PB13 - SCK.
   * PB14 - MISO.
   * PB15 - MOSI.
   */
  spiStart(&SPID2, &spi2cfg);
  palSetPad(GPIOB, 12);
 800a10c:	4c4a      	ldr	r4, [pc, #296]	; (800a238 <main+0x138>)
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
  chSysInit();
 800a10e:	f7f7 f83f 	bl	8001190 <chSysInit>

  /*
   * Setting up analog inputs used by the demo.
   */
  palSetGroupMode(GPIOC, PAL_PORT_BIT(1) | PAL_PORT_BIT(2),
 800a112:	2203      	movs	r2, #3
 800a114:	2106      	movs	r1, #6
 800a116:	4849      	ldr	r0, [pc, #292]	; (800a23c <main+0x13c>)
 800a118:	f7fa fa9a 	bl	8004650 <_pal_lld_setgroupmode>
                  0, PAL_MODE_INPUT_ANALOG);
  //for buzzer
  palSetPadMode(GPIOD,GPIOD_PIN3,PAL_MODE_OUTPUT_PUSHPULL);
 800a11c:	2201      	movs	r2, #1
 800a11e:	2108      	movs	r1, #8
 800a120:	4847      	ldr	r0, [pc, #284]	; (800a240 <main+0x140>)
 800a122:	f7fa fa95 	bl	8004650 <_pal_lld_setgroupmode>
 

  /*
   * Shell manager initialization.
   */
  shellInit();
 800a126:	f7ff f96b 	bl	8009400 <shellInit>

  /*
   * Initializes a serial-over-USB CDC driver.
   */

  sduObjectInit(&SDU1);
 800a12a:	4628      	mov	r0, r5
 800a12c:	f7f9 f8a8 	bl	8003280 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 800a130:	4631      	mov	r1, r6
 800a132:	4628      	mov	r0, r5
 800a134:	f7f9 f8cc 	bl	80032d0 <sduStart>
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
 800a138:	6833      	ldr	r3, [r6, #0]
 800a13a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a13c:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800a13e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800a142:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(1000);
 800a144:	f242 7010 	movw	r0, #10000	; 0x2710
 800a148:	f7f7 fbca 	bl	80018e0 <chThdSleep>
  usbStart(serusbcfg.usbp, &usbcfg);
 800a14c:	6830      	ldr	r0, [r6, #0]
 800a14e:	493d      	ldr	r1, [pc, #244]	; (800a244 <main+0x144>)
 800a150:	f7f9 fa26 	bl	80035a0 <usbStart>
  usbConnectBus(serusbcfg.usbp);
 800a154:	6833      	ldr	r3, [r6, #0]

  /*
   * Activates the serial driver 2 using the driver default configuration.
   * PA2(TX) and PA3(RX) are routed to USART2.
   */
  sdStart(&SD2, &usart_cfg);
 800a156:	493c      	ldr	r1, [pc, #240]	; (800a248 <main+0x148>)
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
  chThdSleepMilliseconds(1000);
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
 800a158:	6d1a      	ldr	r2, [r3, #80]	; 0x50

  /*
   * Activates the serial driver 2 using the driver default configuration.
   * PA2(TX) and PA3(RX) are routed to USART2.
   */
  sdStart(&SD2, &usart_cfg);
 800a15a:	483c      	ldr	r0, [pc, #240]	; (800a24c <main+0x14c>)
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
  chThdSleepMilliseconds(1000);
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
 800a15c:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800a15e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800a162:	6393      	str	r3, [r2, #56]	; 0x38

  /*
   * Activates the serial driver 2 using the driver default configuration.
   * PA2(TX) and PA3(RX) are routed to USART2.
   */
  sdStart(&SD2, &usart_cfg);
 800a164:	f7f8 ffac 	bl	80030c0 <sdStart>
  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));   // uart pins
 800a168:	f240 3282 	movw	r2, #898	; 0x382
 800a16c:	2104      	movs	r1, #4
 800a16e:	4838      	ldr	r0, [pc, #224]	; (800a250 <main+0x150>)
 800a170:	f7fa fa6e 	bl	8004650 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 800a174:	f240 3282 	movw	r2, #898	; 0x382
 800a178:	2108      	movs	r1, #8
 800a17a:	4835      	ldr	r0, [pc, #212]	; (800a250 <main+0x150>)
 800a17c:	f7fa fa68 	bl	8004650 <_pal_lld_setgroupmode>
  pin_off_remote();
 800a180:	f7ff ff26 	bl	8009fd0 <pin_off_remote>

  /*
   * Initializes the SPI driver 1 in order to access the MEMS. The signals
   * are already initialized in the board file.
   */
  spiStart(&SPID1, &spi1cfg);
 800a184:	4933      	ldr	r1, [pc, #204]	; (800a254 <main+0x154>)
 800a186:	4834      	ldr	r0, [pc, #208]	; (800a258 <main+0x158>)
 800a188:	f7f9 f992 	bl	80034b0 <spiStart>
   * PB12 - NSS.
   * PB13 - SCK.
   * PB14 - MISO.
   * PB15 - MOSI.
   */
  spiStart(&SPID2, &spi2cfg);
 800a18c:	4933      	ldr	r1, [pc, #204]	; (800a25c <main+0x15c>)
 800a18e:	4834      	ldr	r0, [pc, #208]	; (800a260 <main+0x160>)
 800a190:	f7f9 f98e 	bl	80034b0 <spiStart>
  palSetPad(GPIOB, 12);
 800a194:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800a198:	8321      	strh	r1, [r4, #24]
  palSetPadMode(GPIOB, 12, PAL_MODE_OUTPUT_PUSHPULL |
 800a19a:	4620      	mov	r0, r4
 800a19c:	2219      	movs	r2, #25
 800a19e:	f7fa fa57 	bl	8004650 <_pal_lld_setgroupmode>
                           PAL_STM32_OSPEED_HIGHEST);           /* NSS.     */
  palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5) |
 800a1a2:	4620      	mov	r0, r4
 800a1a4:	f240 229a 	movw	r2, #666	; 0x29a
 800a1a8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800a1ac:	f7fa fa50 	bl	8004650 <_pal_lld_setgroupmode>
                           PAL_STM32_OSPEED_HIGHEST);           /* SCK.     */
  palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5));              /* MISO.    */
 800a1b0:	4620      	mov	r0, r4
 800a1b2:	f240 2282 	movw	r2, #642	; 0x282
 800a1b6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800a1ba:	f7fa fa49 	bl	8004650 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(5) |
 800a1be:	4620      	mov	r0, r4
 800a1c0:	f240 229a 	movw	r2, #666	; 0x29a
 800a1c4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800a1c8:	f7fa fa42 	bl	8004650 <_pal_lld_setgroupmode>

  /*
   * Threads
  */

  chThdCreateStatic(waThread1, sizeof(waThread1),
 800a1cc:	2400      	movs	r4, #0
                           PAL_STM32_OSPEED_HIGHEST);           /* MOSI.    */

  /*
   * Initializes the PWM driver 4, routes the TIM4 outputs to the board LEDs.
   */
  pwmStart(&PWMD4, &pwmcfg);
 800a1ce:	4925      	ldr	r1, [pc, #148]	; (800a264 <main+0x164>)
 800a1d0:	4825      	ldr	r0, [pc, #148]	; (800a268 <main+0x168>)
 800a1d2:	f7f8 fee5 	bl	8002fa0 <pwmStart>

  /*
   * Threads
  */

  chThdCreateStatic(waThread1, sizeof(waThread1),
 800a1d6:	4b25      	ldr	r3, [pc, #148]	; (800a26c <main+0x16c>)
 800a1d8:	9400      	str	r4, [sp, #0]
 800a1da:	224a      	movs	r2, #74	; 0x4a
 800a1dc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a1e0:	4823      	ldr	r0, [pc, #140]	; (800a270 <main+0x170>)
 800a1e2:	f7f7 fb0d 	bl	8001800 <chThdCreateStatic>
                    NORMALPRIO + 10, Thread1, NULL);


  chThdCreateStatic(waThread2, sizeof(waThread2),
 800a1e6:	9400      	str	r4, [sp, #0]
 800a1e8:	4b22      	ldr	r3, [pc, #136]	; (800a274 <main+0x174>)
 800a1ea:	4823      	ldr	r0, [pc, #140]	; (800a278 <main+0x178>)
 800a1ec:	224a      	movs	r2, #74	; 0x4a
 800a1ee:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a1f2:	f7f7 fb05 	bl	8001800 <chThdCreateStatic>
  /*
   * Normal main() thread activity, in this demo it just performs
   * a shell respawn upon its termination.
   */
  while (true) {
    if (!shelltp) {
 800a1f6:	b144      	cbz	r4, 800a20a <main+0x10a>
        shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
      }
    }
    else {
      /* If the previous shell exited.*/
      if (chThdTerminatedX(shelltp)) {
 800a1f8:	7f23      	ldrb	r3, [r4, #28]
 800a1fa:	2b0f      	cmp	r3, #15
 800a1fc:	d013      	beq.n	800a226 <main+0x126>
        /* Recovers memory of the previous shell.*/
        chThdRelease(shelltp);
        shelltp = NULL;
      }
    }
    chThdSleepMilliseconds(500);
 800a1fe:	f241 3088 	movw	r0, #5000	; 0x1388
 800a202:	f7f7 fb6d 	bl	80018e0 <chThdSleep>
  /*
   * Normal main() thread activity, in this demo it just performs
   * a shell respawn upon its termination.
   */
  while (true) {
    if (!shelltp) {
 800a206:	2c00      	cmp	r4, #0
 800a208:	d1f6      	bne.n	800a1f8 <main+0xf8>
      if (SDU1.config->usbp->state == USB_ACTIVE) {
 800a20a:	f8d5 3254 	ldr.w	r3, [r5, #596]	; 0x254
 800a20e:	681b      	ldr	r3, [r3, #0]
 800a210:	781b      	ldrb	r3, [r3, #0]
 800a212:	2b04      	cmp	r3, #4
 800a214:	d1f3      	bne.n	800a1fe <main+0xfe>
        /* Spawns a new shell.*/
        shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
 800a216:	2240      	movs	r2, #64	; 0x40
 800a218:	f640 01c8 	movw	r1, #2248	; 0x8c8
 800a21c:	4817      	ldr	r0, [pc, #92]	; (800a27c <main+0x17c>)
 800a21e:	f7ff f8f7 	bl	8009410 <shellCreate>
 800a222:	4604      	mov	r4, r0
 800a224:	e7eb      	b.n	800a1fe <main+0xfe>
    }
    else {
      /* If the previous shell exited.*/
      if (chThdTerminatedX(shelltp)) {
        /* Recovers memory of the previous shell.*/
        chThdRelease(shelltp);
 800a226:	4620      	mov	r0, r4
 800a228:	f7f7 fc9a 	bl	8001b60 <chThdRelease>
        shelltp = NULL;
 800a22c:	2400      	movs	r4, #0
 800a22e:	e7e6      	b.n	800a1fe <main+0xfe>
 800a230:	20001dc8 	.word	0x20001dc8
 800a234:	0800b6e0 	.word	0x0800b6e0
 800a238:	40020400 	.word	0x40020400
 800a23c:	40020800 	.word	0x40020800
 800a240:	40020c00 	.word	0x40020c00
 800a244:	0800b5b0 	.word	0x0800b5b0
 800a248:	0800b740 	.word	0x0800b740
 800a24c:	200012f8 	.word	0x200012f8
 800a250:	40020000 	.word	0x40020000
 800a254:	0800b710 	.word	0x0800b710
 800a258:	20001278 	.word	0x20001278
 800a25c:	0800b700 	.word	0x0800b700
 800a260:	200012a8 	.word	0x200012a8
 800a264:	0800b8e0 	.word	0x0800b8e0
 800a268:	200012dc 	.word	0x200012dc
 800a26c:	08009c51 	.word	0x08009c51
 800a270:	20001b38 	.word	0x20001b38
 800a274:	0800a011 	.word	0x0800a011
 800a278:	20001c80 	.word	0x20001c80
 800a27c:	0800b950 	.word	0x0800b950

0800a280 <strcasecmp>:
 800a280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a282:	4607      	mov	r7, r0
 800a284:	460e      	mov	r6, r1
 800a286:	f817 4b01 	ldrb.w	r4, [r7], #1
 800a28a:	f000 f879 	bl	800a380 <__locale_ctype_ptr>
 800a28e:	4420      	add	r0, r4
 800a290:	4625      	mov	r5, r4
 800a292:	7843      	ldrb	r3, [r0, #1]
 800a294:	f003 0303 	and.w	r3, r3, #3
 800a298:	2b01      	cmp	r3, #1
 800a29a:	bf08      	it	eq
 800a29c:	f104 0520 	addeq.w	r5, r4, #32
 800a2a0:	f816 4b01 	ldrb.w	r4, [r6], #1
 800a2a4:	f000 f86c 	bl	800a380 <__locale_ctype_ptr>
 800a2a8:	4420      	add	r0, r4
 800a2aa:	7843      	ldrb	r3, [r0, #1]
 800a2ac:	f003 0303 	and.w	r3, r3, #3
 800a2b0:	2b01      	cmp	r3, #1
 800a2b2:	d004      	beq.n	800a2be <strcasecmp+0x3e>
 800a2b4:	1b28      	subs	r0, r5, r4
 800a2b6:	d101      	bne.n	800a2bc <strcasecmp+0x3c>
 800a2b8:	2c00      	cmp	r4, #0
 800a2ba:	d1e4      	bne.n	800a286 <strcasecmp+0x6>
 800a2bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a2be:	3420      	adds	r4, #32
 800a2c0:	1b28      	subs	r0, r5, r4
 800a2c2:	d0e0      	beq.n	800a286 <strcasecmp+0x6>
 800a2c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a2c6:	bf00      	nop
	...

0800a2d0 <strpbrk>:
 800a2d0:	b430      	push	{r4, r5}
 800a2d2:	7804      	ldrb	r4, [r0, #0]
 800a2d4:	b1dc      	cbz	r4, 800a30e <strpbrk+0x3e>
 800a2d6:	780d      	ldrb	r5, [r1, #0]
 800a2d8:	b19d      	cbz	r5, 800a302 <strpbrk+0x32>
 800a2da:	42a5      	cmp	r5, r4
 800a2dc:	d00f      	beq.n	800a2fe <strpbrk+0x2e>
 800a2de:	460a      	mov	r2, r1
 800a2e0:	e001      	b.n	800a2e6 <strpbrk+0x16>
 800a2e2:	42a3      	cmp	r3, r4
 800a2e4:	d00b      	beq.n	800a2fe <strpbrk+0x2e>
 800a2e6:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800a2ea:	2b00      	cmp	r3, #0
 800a2ec:	d1f9      	bne.n	800a2e2 <strpbrk+0x12>
 800a2ee:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800a2f2:	2c00      	cmp	r4, #0
 800a2f4:	d1f0      	bne.n	800a2d8 <strpbrk+0x8>
 800a2f6:	7813      	ldrb	r3, [r2, #0]
 800a2f8:	2b00      	cmp	r3, #0
 800a2fa:	bf08      	it	eq
 800a2fc:	2000      	moveq	r0, #0
 800a2fe:	bc30      	pop	{r4, r5}
 800a300:	4770      	bx	lr
 800a302:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800a306:	460a      	mov	r2, r1
 800a308:	2c00      	cmp	r4, #0
 800a30a:	d1e5      	bne.n	800a2d8 <strpbrk+0x8>
 800a30c:	e7f3      	b.n	800a2f6 <strpbrk+0x26>
 800a30e:	4620      	mov	r0, r4
 800a310:	bc30      	pop	{r4, r5}
 800a312:	4770      	bx	lr
	...

0800a320 <strspn>:
 800a320:	b470      	push	{r4, r5, r6}
 800a322:	7804      	ldrb	r4, [r0, #0]
 800a324:	b1a4      	cbz	r4, 800a350 <strspn+0x30>
 800a326:	780e      	ldrb	r6, [r1, #0]
 800a328:	4605      	mov	r5, r0
 800a32a:	b14e      	cbz	r6, 800a340 <strspn+0x20>
 800a32c:	42b4      	cmp	r4, r6
 800a32e:	d00a      	beq.n	800a346 <strspn+0x26>
 800a330:	460a      	mov	r2, r1
 800a332:	e001      	b.n	800a338 <strspn+0x18>
 800a334:	42a3      	cmp	r3, r4
 800a336:	d006      	beq.n	800a346 <strspn+0x26>
 800a338:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800a33c:	2b00      	cmp	r3, #0
 800a33e:	d1f9      	bne.n	800a334 <strspn+0x14>
 800a340:	1a28      	subs	r0, r5, r0
 800a342:	bc70      	pop	{r4, r5, r6}
 800a344:	4770      	bx	lr
 800a346:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800a34a:	2c00      	cmp	r4, #0
 800a34c:	d1ed      	bne.n	800a32a <strspn+0xa>
 800a34e:	e7f7      	b.n	800a340 <strspn+0x20>
 800a350:	4620      	mov	r0, r4
 800a352:	e7f6      	b.n	800a342 <strspn+0x22>
	...

0800a360 <__get_current_locale>:
 800a360:	4a03      	ldr	r2, [pc, #12]	; (800a370 <__get_current_locale+0x10>)
 800a362:	4b04      	ldr	r3, [pc, #16]	; (800a374 <__get_current_locale+0x14>)
 800a364:	6812      	ldr	r2, [r2, #0]
 800a366:	6b50      	ldr	r0, [r2, #52]	; 0x34
 800a368:	2800      	cmp	r0, #0
 800a36a:	bf08      	it	eq
 800a36c:	4618      	moveq	r0, r3
 800a36e:	4770      	bx	lr
 800a370:	20000e70 	.word	0x20000e70
 800a374:	200008d8 	.word	0x200008d8
	...

0800a380 <__locale_ctype_ptr>:
 800a380:	b508      	push	{r3, lr}
 800a382:	4b03      	ldr	r3, [pc, #12]	; (800a390 <__locale_ctype_ptr+0x10>)
 800a384:	6818      	ldr	r0, [r3, #0]
 800a386:	f7ff ffeb 	bl	800a360 <__get_current_locale>
 800a38a:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800a38e:	bd08      	pop	{r3, pc}
 800a390:	20000e70 	.word	0x20000e70
	...

0800a3a0 <__ascii_mbtowc>:
 800a3a0:	b082      	sub	sp, #8
 800a3a2:	b149      	cbz	r1, 800a3b8 <__ascii_mbtowc+0x18>
 800a3a4:	b15a      	cbz	r2, 800a3be <__ascii_mbtowc+0x1e>
 800a3a6:	b16b      	cbz	r3, 800a3c4 <__ascii_mbtowc+0x24>
 800a3a8:	7813      	ldrb	r3, [r2, #0]
 800a3aa:	600b      	str	r3, [r1, #0]
 800a3ac:	7812      	ldrb	r2, [r2, #0]
 800a3ae:	1c10      	adds	r0, r2, #0
 800a3b0:	bf18      	it	ne
 800a3b2:	2001      	movne	r0, #1
 800a3b4:	b002      	add	sp, #8
 800a3b6:	4770      	bx	lr
 800a3b8:	a901      	add	r1, sp, #4
 800a3ba:	2a00      	cmp	r2, #0
 800a3bc:	d1f3      	bne.n	800a3a6 <__ascii_mbtowc+0x6>
 800a3be:	4610      	mov	r0, r2
 800a3c0:	b002      	add	sp, #8
 800a3c2:	4770      	bx	lr
 800a3c4:	f06f 0001 	mvn.w	r0, #1
 800a3c8:	e7f4      	b.n	800a3b4 <__ascii_mbtowc+0x14>
 800a3ca:	bf00      	nop
 800a3cc:	0000      	movs	r0, r0
	...

0800a3d0 <__ascii_wctomb>:
 800a3d0:	b121      	cbz	r1, 800a3dc <__ascii_wctomb+0xc>
 800a3d2:	2aff      	cmp	r2, #255	; 0xff
 800a3d4:	d804      	bhi.n	800a3e0 <__ascii_wctomb+0x10>
 800a3d6:	700a      	strb	r2, [r1, #0]
 800a3d8:	2001      	movs	r0, #1
 800a3da:	4770      	bx	lr
 800a3dc:	4608      	mov	r0, r1
 800a3de:	4770      	bx	lr
 800a3e0:	238a      	movs	r3, #138	; 0x8a
 800a3e2:	6003      	str	r3, [r0, #0]
 800a3e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a3e8:	4770      	bx	lr
 800a3ea:	bf00      	nop
 800a3ec:	0000      	movs	r0, r0
 800a3ee:	0000      	movs	r0, r0
 800a3f0:	0805007e 	.word	0x0805007e
 800a3f4:	05354401 	.word	0x05354401
 800a3f8:	00000078 	.word	0x00000078
 800a3fc:	0805007e 	.word	0x0805007e
 800a400:	04354401 	.word	0x04354401
 800a404:	00000079 	.word	0x00000079
 800a408:	1710007e 	.word	0x1710007e
 800a40c:	00000001 	.word	0x00000001
 800a410:	ff000000 	.word	0xff000000
 800a414:	02feffff 	.word	0x02feffff
 800a418:	6c053544 	.word	0x6c053544
 800a41c:	1710007e 	.word	0x1710007e
 800a420:	00000001 	.word	0x00000001
 800a424:	ff000000 	.word	0xff000000
 800a428:	02feffff 	.word	0x02feffff
 800a42c:	6d043544 	.word	0x6d043544
 800a430:	656c6469 	.word	0x656c6469
	...

0800a440 <ch_debug>:
 800a440:	6e69616d 18001600 08440404 1814100c     main......D.....
 800a450:	1e1d1c00 00000000 00000000 00000000     ................

0800a460 <vmt>:
 800a460:	08003021 08003001 08003061 08003041     !0...0..a0..A0..
 800a470:	08003051 08003031 08003011 08002ff1     Q0..10...0.../..

0800a480 <vmt>:
 800a480:	08003221 08003201 08003261 08003241     !2...2..a2..A2..
 800a490:	08003251 08003231 08003211 080031f1     Q2..12...2...1..

0800a4a0 <zero_status>:
	...

0800a4b0 <active_status>:
	...

0800a4c0 <halted_status>:
 800a4c0:	00000001 00000000 00000000 00000000     ................

0800a4d0 <_stm32_dma_streams>:
 800a4d0:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 800a4e0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 800a4f0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 800a500:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 800a510:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 800a520:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 800a530:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 800a540:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 800a550:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 800a560:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 800a570:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 800a580:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

0800a590 <fsparams>:
 800a590:	00000080 00000140 00000003 00000000     ....@...........
 800a5a0:	5f627375 5f646c6c 706d7570 00000000     usb_lld_pump....

0800a5b0 <ep0config>:
 800a5b0:	00000000 080036d1 08003a11 08003b01     .....6...:...;..
 800a5c0:	00400040 20001258 20001258 00000001     @.@.X.. X.. ....
 800a5d0:	2000126c 00000000 00000000 00000000     l.. ............
 800a5e0:	20414d44 6c696166 00657275 00000000     DMA failure.....

0800a5f0 <default_config>:
 800a5f0:	00009600 40000000 00000000 00000000     .......@........

0800a600 <pal_default_config>:
 800a600:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 800a610:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 800a620:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 800a630:	04000000 00000040 02208001 00000000     ....@..... .....
 800a640:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 800a650:	00060600 55000100 00000000 ffffffff     .......U........
 800a660:	00555055 00000fff 00000000 00000000     UPU.............
 800a670:	00000040 00000000 ffffffff 00000000     @...............
 800a680:	0000ffff 00000000 00000000 00000000     ................
 800a690:	00000000 ffffffff 00000000 0000ffff     ................
	...
 800a6b0:	ffffffff 00000000 0000ffff 00000000     ................
	...
 800a6cc:	ffffffff 00000000 0000ffff 00000000     ................
	...
 800a6e8:	ffffffff 00000000 0000ffff 00000000     ................
	...

0800a700 <wa>:
 800a700:	20001370 200014b8 20001600 20001748     p.. ... ... H.. 
 800a710:	20001890 00000000 00000000 00000000     ... ............

0800a720 <patterns>:
 800a720:	0800afa0 0800a9b0 0800aa90 0800ac00     ................
 800a730:	0800ac60 0800ac70 0800acb0 0800ad60     `...p.......`...
 800a740:	0800add0 0800aeb0 0800aec0 0800afc0     ................
	...
 800a760:	202a2a2a 6e72654b 203a6c65 20202020     *** Kernel:     
 800a770:	00002020 202a2a2a 706d6f43 64656c69       ..*** Compiled
 800a780:	2020203a 00002020 202a2a2a 706d6f43     :     ..*** Comp
 800a790:	72656c69 2020203a 00002020 202a2a2a     iler:     ..*** 
 800a7a0:	68637241 63657469 65727574 0000203a     Architecture: ..
 800a7b0:	202a2a2a 65726f43 72615620 746e6169     *** Core Variant
 800a7c0:	0000203a 202a2a2a 74726f50 666e4920     : ..*** Port Inf
 800a7d0:	20203a6f 00002020 202a2a2a 74616c50     o:    ..*** Plat
 800a7e0:	6d726f66 2020203a 00002020 202a2a2a     form:     ..*** 
 800a7f0:	74736554 616f4220 203a6472 00002020     Test Board:   ..
 800a800:	202d2d2d 74736554 73614320 00002065     --- Test Case ..
 800a810:	00002820 202d2d2d 75736552 203a746c      (..--- Result: 
 800a820:	4c494146 20455255 00002328 00005b20     FAILURE (#.. [..
 800a830:	616e6946 6572206c 746c7573 0000203a     Final result: ..
 800a840:	202a2a2a 62696843 2f534f69 74205452     *** ChibiOS/RT t
 800a850:	20747365 74697573 00000065 002a2a2a     est suite...***.
 800a860:	00000029 0000295d 202d2d2d 75736552     )...])..--- Resu
 800a870:	203a746c 43435553 00535345 4c494146     lt: SUCCESS.FAIL
 800a880:	00455255 2e302e33 00367030 206e614a     URE.3.0.0p6.Jan 
 800a890:	32203920 20373130 3232202d 3a37343a      9 2017 - 22:47:
 800a8a0:	00003831 20434347 2e342e35 30322031     18..GCC 5.4.1 20
 800a8b0:	39303631 28203931 656c6572 29657361     160919 (release)
 800a8c0:	52415b20 6d652f4d 64646562 352d6465      [ARM/embedded-5
 800a8d0:	6172622d 2068636e 69766572 6e6f6973     -branch revision
 800a8e0:	30343220 5d363934 00000000 764d5241      240496]....ARMv
 800a8f0:	454d2d37 00000000 74726f43 4d2d7865     7-ME....Cortex-M
 800a900:	00000034 61766441 6465636e 72656b20     4...Advanced ker
 800a910:	206c656e 65646f6d 00000000 334d5453     nel mode....STM3
 800a920:	30344632 69482037 50206867 6f667265     2F407 High Perfo
 800a930:	6e616d72 77206563 20687469 20505344     rmance with DSP 
 800a940:	20646e61 00555046 694d5453 656f7263     and FPU.STMicroe
 800a950:	7463656c 696e6f72 53207363 32334d54     lectronics STM32
 800a960:	442d3446 6f637369 79726576 00000000     F4-Discovery....

0800a970 <testthd1>:
 800a970:	0800aa2c 00000000 00000000 08005ea1     ,............^..

0800a980 <testthd2>:
 800a980:	0800aa10 00000000 00000000 08005f81     ............._..

0800a990 <testthd3>:
 800a990:	0800a9f4 00000000 00000000 08006061     ............a`..

0800a9a0 <testthd4>:
 800a9a0:	0800a9e4 00000000 00000000 08006191     .............a..

0800a9b0 <patternthd>:
 800a9b0:	0800a970 0800a980 0800a990 0800a9a0     p...............
	...
 800a9d0:	00000043 00000042 00000041 44434241     C...B...A...ABCD
 800a9e0:	00000045 65726854 2c736461 6c656420     E...Threads, del
 800a9f0:	00737961 65726854 2c736461 69727020     ays.Threads, pri
 800aa00:	7469726f 68632079 65676e61 00000000     ority change....
 800aa10:	65726854 2c736461 716e6520 69756575     Threads, enqueui
 800aa20:	7420676e 20747365 00003223 65726854     ng test #2..Thre
 800aa30:	2c736461 716e6520 69756575 7420676e     ads, enqueuing t
 800aa40:	20747365 00003123 00000000 00000000     est #1..........

0800aa50 <testsem1>:
 800aa50:	0800ab08 080063f1 00000000 08006231     .....c......1b..

0800aa60 <testsem2>:
 800aa60:	0800aaf4 080063e1 00000000 08006431     .....c......1d..

0800aa70 <testsem3>:
 800aa70:	0800aad4 080063d1 00000000 08006591     .....c.......e..

0800aa80 <testsem4>:
 800aa80:	0800aab0 00000000 00000000 08006661     ............af..

0800aa90 <patternsem>:
 800aa90:	0800aa50 0800aa60 0800aa70 0800aa80     P...`...p.......
	...
 800aab0:	616e6942 53207972 70616d65 65726f68     Binary Semaphore
 800aac0:	66202c73 74636e75 616e6f69 7974696c     s, functionality
 800aad0:	00000000 616d6553 726f6870 202c7365     ....Semaphores, 
 800aae0:	6d6f7461 73206369 616e6769 61772d6c     atomic signal-wa
 800aaf0:	00007469 616d6553 726f6870 202c7365     it..Semaphores, 
 800ab00:	656d6974 0074756f 616d6553 726f6870     timeout.Semaphor
 800ab10:	202c7365 75716e65 6e697565 00000067     es, enqueuing...

0800ab20 <testmtx5>:
 800ab20:	0800aba8 080068f1 00000000 08006bc1     .....h.......k..

0800ab30 <testmtx6>:
 800ab30:	0800ab90 08006dc1 00000000 08006c81     .....m.......l..

0800ab40 <testmtx7>:
 800ab40:	0800ab78 08006da1 00000000 08006e01     x....m.......n..

0800ab50 <testmtx8>:
 800ab50:	0800ab64 08006dd1 00000000 08006ec1     d....m.......n..
 800ab60:	00434241 646e6f43 2c726156 6f6f6220     ABC.CondVar, boo
 800ab70:	74207473 00747365 646e6f43 2c726156     st test.CondVar,
 800ab80:	6f726220 61636461 74207473 00747365      broadcast test.
 800ab90:	646e6f43 2c726156 67697320 206c616e     CondVar, signal 
 800aba0:	74736574 00000000 6574754d 2c736578     test....Mutexes,
 800abb0:	61747320 00737574 6574754d 2c736578      status.Mutexes,
 800abc0:	69727020 7469726f 65722079 6e727574      priority return
 800abd0:	00000000 6574754d 2c736578 69727020     ....Mutexes, pri
 800abe0:	7469726f 6e652079 75657571 20676e69     ority enqueuing 
 800abf0:	74736574 00000000 00000000 00000000     test............

0800ac00 <patternmtx>:
 800ac00:	0800ac20 0800ac30 0800ab20 0800ab30      ...0... ...0...
 800ac10:	0800ab40 0800ab50 00000000 00000000     @...P...........

0800ac20 <testmtx1>:
 800ac20:	0800abd4 08006901 00000000 080067b1     .....i.......g..

0800ac30 <testmtx4>:
 800ac30:	0800abb8 080068d1 00000000 08006951     .....h......Qi..

0800ac40 <testmsg1>:
 800ac40:	0800ac50 00000000 00000000 08006fa1     P............o..
 800ac50:	7373654d 73656761 6f6c202c 0000706f     Messages, loop..

0800ac60 <patternmsg>:
 800ac60:	0800ac40 00000000 00000000 00000000     @...............

0800ac70 <patternmbox>:
 800ac70:	0800aca0 00000000 00000000 00000000     ................
 800ac80:	6c69614d 65786f62 71202c73 69756575     Mailboxes, queui
 800ac90:	6120676e 7420646e 6f656d69 00737475     ng and timeouts.

0800aca0 <testmbox1>:
 800aca0:	0800ac80 08007621 00000000 08007041     ....!v......Ap..

0800acb0 <patternevt>:
 800acb0:	0800ad30 0800acc0 0800ad50 00000000     0.......P.......

0800acc0 <testevt2>:
 800acc0:	0800ace4 08007711 00000000 08007731     .....w......1w..
 800acd0:	6e657645 202c7374 656d6974 7374756f     Events, timeouts
 800ace0:	00000000 6e657645 202c7374 74696177     ....Events, wait
 800acf0:	646e6120 6f726220 61636461 00007473      and broadcast..
 800ad00:	6e657645 202c7374 69676572 61727473     Events, registra
 800ad10:	6e6f6974 646e6120 73696420 63746170     tion and dispatc
 800ad20:	00000068 00000000 00000000 00000000     h...............

0800ad30 <testevt1>:
 800ad30:	0800ad00 08007721 00000000 08007671     ....!w......qv..

0800ad40 <evhndl>:
 800ad40:	08007661 08007651 08007641 00000000     av..Qv..Av......

0800ad50 <testevt3>:
 800ad50:	0800acd0 08007701 00000000 08007a11     .....w.......z..

0800ad60 <patternheap>:
 800ad60:	0800ada0 00000000 00000000 00000000     ................
 800ad70:	70616548 6c61202c 61636f6c 6e6f6974     Heap, allocation
 800ad80:	646e6120 61726620 6e656d67 69746174      and fragmentati
 800ad90:	74206e6f 00747365 00000000 00000000     on test.........

0800ada0 <testheap1>:
 800ada0:	0800ad70 08007d01 00000000 08007ab1     p....}.......z..
 800adb0:	6f6d654d 50207972 736c6f6f 7571202c     Memory Pools, qu
 800adc0:	2f657565 75716564 00657565 00000000     eue/dequeue.....

0800add0 <patternpools>:
 800add0:	0800ade0 00000000 00000000 00000000     ................

0800ade0 <testpools1>:
 800ade0:	0800adb0 08007d31 00000000 08007d41     ....1}......A}..

0800adf0 <testdyn1>:
 800adf0:	0800ae84 08007f31 00000000 08007e01     ....1........~..

0800ae00 <testdyn2>:
 800ae00:	0800ae54 08008041 00000000 08007f41     T...A.......A...

0800ae10 <testdyn3>:
 800ae10:	0800ae2c 08007f11 00000000 08008081     ,...............
 800ae20:	00004241 44434241 00000000 616e7944     AB..ABCD....Dyna
 800ae30:	2063696d 73495041 6572202c 74736967     mic APIs, regist
 800ae40:	61207972 7220646e 72656665 65636e65     ry and reference
 800ae50:	00000073 616e7944 2063696d 73495041     s...Dynamic APIs
 800ae60:	6874202c 64616572 72632073 69746165     , threads creati
 800ae70:	66206e6f 206d6f72 6f6d656d 70207972     on from memory p
 800ae80:	006c6f6f 616e7944 2063696d 73495041     ool.Dynamic APIs
 800ae90:	6874202c 64616572 72632073 69746165     , threads creati
 800aea0:	66206e6f 206d6f72 70616568 00000000     on from heap....

0800aeb0 <patterndyn>:
 800aeb0:	0800adf0 0800ae00 0800ae10 00000000     ................

0800aec0 <patternqueues>:
 800aec0:	0800af10 0800aed0 00000000 00000000     ................

0800aed0 <testqueues2>:
 800aed0:	0800aee0 08008221 00000000 080084c1     ....!...........
 800aee0:	75657551 202c7365 7074756f 71207475     Queues, output q
 800aef0:	65756575 00000073 75657551 202c7365     ueues...Queues, 
 800af00:	75706e69 75712074 73657565 00000000     input queues....

0800af10 <testqueues1>:
 800af10:	0800aef8 080081e1 00000000 08008251     ............Q...

0800af20 <testsys1>:
 800af20:	0800af80 00000000 00000000 080087d1     ................

0800af30 <testsys2>:
 800af30:	0800af64 00000000 00000000 08008701     d...............

0800af40 <testsys3>:
 800af40:	0800af50 00000000 00000000 08008741     P...........A...
 800af50:	74737953 202c6d65 65746e69 74697267     System, integrit
 800af60:	00000079 74737953 202c6d65 65746e69     y...System, inte
 800af70:	70757272 68207374 6c646e61 00676e69     rrupts handling.
 800af80:	74737953 202c6d65 74697263 6c616369     System, critical
 800af90:	6e6f7a20 00007365 00000000 00000000      zones..........

0800afa0 <patternsys>:
 800afa0:	0800af20 0800af30 0800af40 00000000      ...0...@.......

0800afb0 <testbmk8>:
 800afb0:	0800b230 00000000 00000000 08008ef1     0...............

0800afc0 <patternbmk>:
 800afc0:	0800b000 0800b010 0800b030 0800b050     ........0...P...
 800afd0:	0800b040 0800b370 0800b380 0800afb0     @...p...........
 800afe0:	0800b020 0800b330 0800b340 0800b350      ...0...@...P...
 800aff0:	0800b360 00000000 00000000 00000000     `...............

0800b000 <testbmk1>:
 800b000:	0800b310 00000000 00000000 08008a51     ............Q...

0800b010 <testbmk2>:
 800b010:	0800b2f8 00000000 00000000 08008ac1     ................

0800b020 <testbmk9>:
 800b020:	0800b20c 00000000 00000000 08009001     ................

0800b030 <testbmk3>:
 800b030:	0800b2e0 00000000 00000000 08008b31     ............1...

0800b040 <testbmk5>:
 800b040:	0800b2a4 00000000 00000000 08008d11     ................

0800b050 <testbmk4>:
 800b050:	0800b2c4 00000000 00000000 08008c21     ............!...
 800b060:	202d2d2d 74737953 203a6d65 00000000     --- System: ....
 800b070:	74796220 00007365 202d2d2d 65726854      bytes..--- Thre
 800b080:	203a6461 00000000 202d2d2d 656d6954     ad: ....--- Time
 800b090:	203a2072 00000000 202d2d2d 616d6553     r : ....--- Sema
 800b0a0:	203a6870 00000000 202d2d2d 6e657645     ph: ....--- Even
 800b0b0:	203a5374 00000000 202d2d2d 6e657645     tS: ....--- Even
 800b0c0:	203a4c74 00000000 202d2d2d 6574754d     tL: ....--- Mute
 800b0d0:	203a2078 00000000 202d2d2d 646e6f43     x : ....--- Cond
 800b0e0:	203a2e56 00000000 202d2d2d 75657551     V.: ....--- Queu
 800b0f0:	203a2065 00000000 202d2d2d 6c69614d     e : ....--- Mail
 800b100:	203a2e42 00000000 202d2d2d 726f6353     B.: ....--- Scor
 800b110:	203a2065 00000000 72687420 73646165     e : .... threads
 800b120:	0000532f 67736d20 2c532f73 00000020     /S.. msgs/S, ...
 800b130:	78746320 2f637773 00000053 73657220      ctxswc/S... res
 800b140:	64656863 73656c75 202c532f 00000000     chedules/S, ....
 800b150:	74796220 532f7365 00000000 6d697420      bytes/S.... tim
 800b160:	2f737265 00000053 69617720 69732b74     ers/S... wait+si
 800b170:	6c616e67 0000532f 636f6c20 6e752b6b     gnal/S.. lock+un
 800b180:	6b636f6c 0000532f 636e6542 72616d68     lock/S..Benchmar
 800b190:	52202c6b 66204d41 70746f6f 746e6972     k, RAM footprint
 800b1a0:	00000000 636e6542 72616d68 6d202c6b     ....Benchmark, m
 800b1b0:	78657475 6c207365 2f6b636f 6f6c6e75     utexes lock/unlo
 800b1c0:	00006b63 636e6542 72616d68 73202c6b     ck..Benchmark, s
 800b1d0:	70616d65 65726f68 61772073 732f7469     emaphores wait/s
 800b1e0:	616e6769 0000006c 636e6542 72616d68     ignal...Benchmar
 800b1f0:	76202c6b 75747269 74206c61 72656d69     k, virtual timer
 800b200:	65732073 65722f74 00746573 636e6542     s set/reset.Benc
 800b210:	72616d68 49202c6b 51204f2f 65756575     hmark, I/O Queue
 800b220:	68742073 67756f72 74757068 00000000     s throughput....
 800b230:	636e6542 72616d68 72202c6b 646e756f     Benchmark, round
 800b240:	626f7220 63206e69 65746e6f 73207478      robin context s
 800b250:	63746977 676e6968 00000000 636e6542     witching....Benc
 800b260:	72616d68 6d202c6b 20737361 63736572     hmark, mass resc
 800b270:	75646568 202c656c 68742035 64616572     hedule, 5 thread
 800b280:	00000073 636e6542 72616d68 74202c6b     s...Benchmark, t
 800b290:	61657268 202c7364 61657263 6f206574     hreads, create o
 800b2a0:	00796c6e 636e6542 72616d68 74202c6b     nly.Benchmark, t
 800b2b0:	61657268 202c7364 6c6c7566 63796320     hreads, full cyc
 800b2c0:	0000656c 636e6542 72616d68 63202c6b     le..Benchmark, c
 800b2d0:	65746e6f 73207478 63746977 00000068     ontext switch...
 800b2e0:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 800b2f0:	20736567 00003323 636e6542 72616d68     ges #3..Benchmar
 800b300:	6d202c6b 61737365 20736567 00003223     k, messages #2..
 800b310:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 800b320:	20736567 00003123 00000000 00000000     ges #1..........

0800b330 <testbmk10>:
 800b330:	0800b1e8 00000000 00000000 080090b1     ................

0800b340 <testbmk11>:
 800b340:	0800b1c4 08008ee1 00000000 08009131     ............1...

0800b350 <testbmk12>:
 800b350:	0800b1a4 08009211 00000000 080091a1     ................

0800b360 <testbmk13>:
 800b360:	0800b188 00000000 00000000 08008891     ................

0800b370 <testbmk6>:
 800b370:	0800b284 00000000 00000000 080089a1     ................

0800b380 <testbmk7>:
 800b380:	0800b25c 08008ed1 00000000 08008d91     \...............
 800b390:	74737973 00656d69 67617355 25203a65     systime.Usage: %
 800b3a0:	000a0d73 0d756c25 0000000a 6f666e69     s...%lu.....info
 800b3b0:	00000000 6e72654b 203a6c65 20202020     ....Kernel:     
 800b3c0:	73252020 00000a0d 706d6f43 72656c69       %s....Compiler
 800b3d0:	2020203a 73252020 00000a0d 68637241     :     %s....Arch
 800b3e0:	63657469 65727574 7325203a 00000a0d     itecture: %s....
 800b3f0:	65726f43 72615620 746e6169 7325203a     Core Variant: %s
 800b400:	00000a0d 74726f50 666e4920 20203a6f     ....Port Info:  
 800b410:	73252020 00000a0d 74616c50 6d726f66       %s....Platform
 800b420:	2020203a 73252020 00000a0d 72616f42     :     %s....Boar
 800b430:	20203a64 20202020 73252020 00000a0d     d:        %s....
 800b440:	00202d20 206e614a 32203920 00373130      - .Jan  9 2017.
 800b450:	6c697542 69742064 203a656d 73252020     Build time:   %s
 800b460:	73257325 00000a0d 343a3232 30323a37     %s%s....22:47:20
 800b470:	00000000 00000920 0000445e 6c656873     .... ...^D..shel
 800b480:	0000006c 68430a0d 4f696269 54522f53     l.....ChibiOS/RT
 800b490:	65685320 0a0d6c6c 00000000 203e6863      Shell......ch> 
 800b4a0:	00000000 6f6c0a0d 74756f67 00000000     ......logout....
 800b4b0:	206f6f74 796e616d 67726120 6e656d75     too many argumen
 800b4c0:	0a0d7374 00000000 74697865 00000000     ts......exit....
 800b4d0:	706c6568 00000000 6d6d6f43 73646e61     help....Commands
 800b4e0:	6568203a 6520706c 20746978 00000000     : help exit ....
 800b4f0:	00207325 00007325 0a0d3f20 00000000     %s .%s.. ?......
 800b500:	6c756e28 0000296c 00000000 00000000     (null)..........

0800b510 <pow10>:
 800b510:	0000000a 00000064 000003e8 00002710     ....d........'..
 800b520:	000186a0 000f4240 00989680 05f5e100     ....@B..........
 800b530:	3b9aca00 00000000 00000000 00000000     ...;............

0800b540 <ep1config>:
 800b540:	00000002 00000000 080033a1 08003411     .........3...4..
 800b550:	00400040 20001b10 20001b24 00000002     @.@.... $.. ....
	...

0800b570 <vcom_configuration_descriptor>:
 800b570:	00000043 0800b5c0 00000000 00000000     C...............

0800b580 <ep2config>:
 800b580:	00000003 00000000 08003481 00000000     .........4......
 800b590:	00000010 20001afc 00000000 00000001     ....... ........
	...

0800b5b0 <usbcfg>:
 800b5b0:	08009be1 08009bb1 08003361 00000000     ........a3......

0800b5c0 <vcom_configuration_descriptor_data>:
 800b5c0:	00430209 c0000102 00040932 02020100     ..C.....2.......
 800b5d0:	24050001 05011000 01000124 02022404     ...$....$....$..
 800b5e0:	00062405 82050701 ff000803 00010409     .$..............
 800b5f0:	00000a02 01050700 00004002 02810507     .........@......
 800b600:	00000040 00000000 00000000 00000000     @...............

0800b610 <vcom_device_descriptor_data>:
 800b610:	01100112 40000002 57400483 02010200     .......@..@W....
 800b620:	00000103 00000000 00000000 00000000     ................

0800b630 <vcom_string0>:
 800b630:	04090304 00000000 00000000 00000000     ................

0800b640 <vcom_string1>:
 800b640:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 800b650:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 800b660:	00630069 00000073 00000000 00000000     i.c.s...........

0800b670 <vcom_string2>:
 800b670:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 800b680:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 800b690:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 800b6a0:	006f0050 00740072 00000000 00000000     P.o.r.t.........

0800b6b0 <vcom_string3>:
 800b6b0:	00330308 00300030 00000000 00000000     ..3.0.0.........

0800b6c0 <vcom_strings>:
 800b6c0:	00000004 0800b630 00000026 0800b640     ....0...&...@...
 800b6d0:	00000038 0800b670 00000008 0800b6b0     8...p...........

0800b6e0 <serusbcfg>:
 800b6e0:	200010a8 00020101 00000000 00000000     ... ............

0800b6f0 <vcom_device_descriptor>:
 800b6f0:	00000012 0800b610 00000000 00000000     ................

0800b700 <spi2cfg>:
 800b700:	00000000 40020400 0000000c 00000000     .......@........

0800b710 <spi1cfg>:
 800b710:	00000000 40021000 001b0003 00000000     .......@........

0800b720 <commands>:
 800b720:	0800b8d0 08009e61 0800b8d4 08009e01     ....a...........
 800b730:	0800abf0 08009db1 00000000 00000000     ................

0800b740 <usart_cfg>:
 800b740:	00002580 40000000 00000000 00000000     .%.....@........
 800b750:	64616572 00007265 67617355 74203a65     reader..Usage: t
 800b760:	0d747365 0000000a 2074756f 6d20666f     est.....out of m
 800b770:	726f6d65 000a0d79 67617355 74203a65     emory...Usage: t
 800b780:	61657268 0a0d7364 00000000 20202020     hreads......    
 800b790:	72646461 20202020 63617473 7270206b     addr    stack pr
 800b7a0:	72206f69 20736665 20202020 74617473     io refs     stat
 800b7b0:	000a0d65 6c383025 30252078 20786c38     e...%08lx %08lx 
 800b7c0:	756c3425 6c342520 39252075 000a0d73     %4lu %4lu %9s...
 800b7d0:	67617355 6d203a65 0a0d6d65 00000000     Usage: mem......
 800b7e0:	65726f63 65726620 656d2065 79726f6d     core free memory
 800b7f0:	25203a20 79622075 0d736574 0000000a      : %u bytes.....
 800b800:	70616568 61726620 6e656d67 20207374     heap fragments  
 800b810:	25203a20 000a0d75 70616568 65726620      : %u...heap fre
 800b820:	6f742065 206c6174 25203a20 79622075     e total  : %u by
 800b830:	0d736574 0000000a 252c6625 66252c66     tes.....%f,%f,%f
 800b840:	00000a0d 44414552 00000059 52525543     ....READY...CURR
 800b850:	00544e45 54535457 00545241 50535553     ENT.WTSTART.SUSP
 800b860:	45444e45 00000044 55455551 00004445     ENDED...QUEUED..
 800b870:	45535457 0000004d 544d5457 00000058     WTSEM...WTMTX...
 800b880:	4f435457 0000444e 45454c53 474e4950     WTCOND..SLEEPING
 800b890:	00000000 58455457 00005449 524f5457     ....WTEXIT..WTOR
 800b8a0:	00545645 4e415457 54564544 00000000     EVT.WTANDEVT....
 800b8b0:	4d444e53 00514753 4d444e53 00004753     SNDMSGQ.SNDMSG..
 800b8c0:	534d5457 00000047 414e4946 0000004c     WTMSG...FINAL...
 800b8d0:	006d656d 65726874 00736461 00000000     mem.threads.....

0800b8e0 <pwmcfg>:
 800b8e0:	000186a0 00000080 00000000 00000001     ................
 800b8f0:	00000000 00000001 00000000 00000001     ................
 800b900:	00000000 00000001 00000000 00000000     ................
	...

0800b920 <adcgrpcfg1>:
 800b920:	00020000 00000000 08009c21 00000000     ........!.......
 800b930:	40000000 00000038 00000000 00100000     ...@8...........
 800b940:	00000000 0000000b 00000000 00000000     ................

0800b950 <shell_cfg1>:
 800b950:	20001dc8 0800b720 00000000 00000000     ...  ...........

0800b960 <states.7876>:
 800b960:	0800b844 0800b84c 0800b854 0800b85c     D...L...T...\...
 800b970:	0800b868 0800b870 0800b878 0800b880     h...p...x.......
 800b980:	0800b888 0800b894 0800b89c 0800b8a4     ................
 800b990:	0800b8b0 0800b8b8 0800b8c0 0800b8c8     ................
 800b9a0:	49534f50 00000058 0000002e 00000000     POSIX...........

0800b9b0 <_ctype_>:
 800b9b0:	20202000 20202020 28282020 20282828     .         ((((( 
 800b9c0:	20202020 20202020 20202020 20202020                     
 800b9d0:	10108820 10101010 10101010 10101010      ...............
 800b9e0:	04040410 04040404 10040404 10101010     ................
 800b9f0:	41411010 41414141 01010101 01010101     ..AAAAAA........
 800ba00:	01010101 01010101 01010101 10101010     ................
 800ba10:	42421010 42424242 02020202 02020202     ..BBBBBB........
 800ba20:	02020202 02020202 02020202 10101010     ................
 800ba30:	00000020 00000000 00000000 00000000      ...............
	...
